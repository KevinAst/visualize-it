{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte"
  ],
  "sourcesContent": [
    "<script context=\"module\">\n import ePkgStoreManager  from './vitStoreTest/ePkgStoreManager'; // NOTE: .js is optional in this svelte tooling\n // pretend SmartPkg is registering it's ePkgStores\n const ePkg1 = {\n   getEPkgId() { return '111' },\n   crc: 111000001,\n   getCrc() { return this.crc; },\n   baseCrc: 111000001,\n   getBaseCrc() { return this.baseCrc; },\n };\n const ePkg2 = {\n   getEPkgId() { return '222' },\n   crc: 222000001,\n   getCrc() { return this.crc; },\n   baseCrc: 222000001,\n   getBaseCrc() { return this.baseCrc; },\n };\n ePkgStoreManager.registerEPkgStore(ePkg1);\n ePkgStoreManager.registerEPkgStore(ePkg2);\n</script>\n\n<script>\n import SomeComp    from './someSubStruct/SomeComp.svelte'; // NOTE: .svelte is REQUIRED\n import Tab         from './someSubStruct/Tab.svelte';\n import VitReactive from './someSubStruct/VitReactive.svelte';\n export let name;\n \n const myComp = {\n   id: 123,\n   getId()   { return this.id; },\n   setId(id) { this.id = id; },\n\n   name: 'Kevin',\n   getName()   { return this.name; },\n\n };\n\n // try some changes to myComp object\n\n // TEST1: Direct assignment of an object attribute WITHIN svelte comp IS REFLECTIVE\n //        - even to sub-comps where myComp is passed as props\n //        - the granularity of reflectiveness is ANYTHING referecing myComp\n // setInterval( () => myComp.id = myComp.id + 2, 1000 );\n\n // TEST2: HOWEVER, when the assignment occurs ouside of the svelte component, it is NOT FEFLECTIVE\n //        - here our change (assignment) is in the object setter, and NO REGENERATION OCCURS\n // setInterval( () => myComp.setId(myComp.getId()+2), 1000 );\n\n // TEST3: Assignement of the object \"to itself\" is considered to be changed and IS REFLECTIVE\n //        - weird that JavaScript allows a const to be assigned to itself\n //  setInterval( () => {\n //    myComp.setId(myComp.getId()+2); // as shown above, this is NOT REFLECTIVE (the assignment is outside svelte visibility)\n //    myComp = myComp;                // HOWEVER this IS REFLECTIVE (WEIRD: allows const assignment to self)\n // // myComp = { // cannot assign a const to another object (AS EXPECTED): ERROR: Assignment to constant variable\n // //   id: 999,\n // //   getId()   { return this.id; },\n // //   setId(id) { this.id = id; }\n // // };\n //  }, 1000 );\n\n // TEST4: pretend ID is our hash value (showing change)\n //        - conditional logic proves that reflectiveness occurs ONLY when assignment occurs\n //        - the granularity of reflectiveness is ANYTHING referecing myComp\n // let lastId    = myComp.getId();\n // let alternate = true; // inncrement every-other time\n // setInterval( () => {\n // \n //   // only increment ever other time\n //   // ... this works (the reactiveness is every other time)\n //   alternate = !alternate;\n //   if (alternate) {\n //     myComp.setId(myComp.getId()+2); // KJB: as shown above, NOT reflective when the assignment is outside svelte visibility :=()\n //   }\n // \n //   // in monitoring changes to myComp (through our pretend hash)\n //   // ... GREAT: we can indicate myComp has changed (through the assignement below)\n //   // >>> BAD 1: \"self asignment\" to a property is the same as \"self assignment\" to the object itself\n //   //            ... the entire object is consider to have changed, and ANY reference to the OBJECT will be re-rendered :-(\n //   // >>> BAD 2: assume this logic has to be seen in the svelte component\n //   if (lastId !== myComp.getId()) {\n //     lastId = myComp.getId();  // reset our cache\n //     myComp.id = myComp.id;  // KJB: HOWEVER assignment to self marks the object as changed in Svelte (WEIRD: allows const assignment to self)\n //   }\n // }, 10000 );\n\n\n // TEST my ePkgStore\n const ePkgStore1 = ePkgStoreManager.getEPkgStore('111');\n const ePkgStore2 = ePkgStoreManager.getEPkgStore('222');\n\n const ePkgInSyncStore1 = ePkgStoreManager.getEPkgInSyncStore('111');\n const ePkgInSyncStore2 = ePkgStoreManager.getEPkgInSyncStore('222');\n\n</script>\n\n<style>\n\tmain {\n\t\ttext-align: center;\n\t\tpadding: 1em;\n\t\tmax-width: 240px;\n\t\tmargin: 0 auto;\n\t}\n\n\th1 {\n\t\tcolor: #ff3e00;\n\t\t/*text-transform: uppercase;*/\n\t\tfont-size: 4em;\n\t\tfont-weight: 100;\n\t}\n\n\t@media (min-width: 640px) {\n\t\tmain {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n</style>\n\n<main>\n\t<h1>Hello {name}!</h1>\n\t\n  <p>Visit the <a href=\"https://svelte.dev/tutorial\">Svelte tutorial</a> to learn how to build Svelte apps.</p>\n\n  <SomeComp myParam=\"Testing 1 2 3\"/>\n  <SomeComp myParam={new Date()}/>\n  <SomeComp myParam=\"We are finished testing SomeComp\"/>\n\n  <VitReactive myComp={myComp}/>\n\n  <div>\n    <p>\n      ePkgStore1: crc: {$ePkgStore1.crc}, baseCrc: {$ePkgStore1.baseCrc}, dispMode: {$ePkgStore1.dispMode}\n      <button on:click={() => {\n                       // GREAT: directly updating store SHOULD NOT WORK:\n                       // console.log('ePkgStore1.crc: ', ePkgStore1.crc) // don't even have access to .crc directly (without subscribing) IS undefined\n                       // ePkgStore1.crc++;\n                       // GREAT: following is a simulation of how it would work in visualize-it\n                       // ... pretend our EPkg has changed\n                       ePkg1.crc++;\n                       // ... simulate changeManager notification of change\n                       ePkgStore1.crcChanged(ePkg1.getCrc(), ePkg1.getBaseCrc());\n                       }}>Change EPkg1</button>\n      <button on:click={() => {\n                       // ... pretend our EPkg has changed\n                       ePkg1.crc--;\n                       // ... simulate changeManager notification of change\n                       ePkgStore1.crcChanged(ePkg1.getCrc(), ePkg1.getBaseCrc());\n                       }}>Undo EPkg1</button>\n\n      <!-- PROB: does NOT update ... suspect need to subscribe to access it ... don't really like this approach anyway\n           inSync: {ePkgStore1.isInSync()}\n           BETTER:\n      -->\n      inSync: {$ePkgInSyncStore1}\n\n    </p>\n    <p>\n      ePkgStore2: crc: {$ePkgStore2.crc}, baseCrc: {$ePkgStore2.baseCrc}, dispMode: {$ePkgStore2.dispMode}\n      <button on:click={() => {\n                       // GREAT: following is a simulation of how it would work in visualize-it\n                       // ... pretend our EPkg has changed\n                       ePkg2.crc++;\n                       // ... simulate changeManager notification of change\n                       ePkgStore2.crcChanged(ePkg2.getCrc(), ePkg2.getBaseCrc());\n                       }}>Change EPkg2</button>\n      <button on:click={() => {\n                       // ... pretend our EPkg has changed\n                       ePkg2.crc--;\n                       // ... simulate changeManager notification of change\n                       ePkgStore2.crcChanged(ePkg2.getCrc(), ePkg2.getBaseCrc());\n                       }}>Undo EPkg2</button>\n      inSync: {$ePkgInSyncStore2}\n    </p>\n\n    <Tab ePkg={ePkg1}/>\n    <Tab ePkg={ePkg2}/>\n  </div>\n\n</main>\n"
  ],
  "names": [],
  "mappings": "AAgGC,IAAI,eAAC,CAAC,AACL,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AAED,EAAE,eAAC,CAAC,AACH,KAAK,CAAE,OAAO,CAEd,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,AACjB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,IAAI,eAAC,CAAC,AACL,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC"
}
{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\AppLayout.svelte",
    "..\\..\\ToolBar.svelte",
    "..\\..\\StartUpPage.svelte",
    "..\\..\\ViewPkg.svelte",
    "..\\..\\ViewPkgTree.svelte",
    "..\\..\\Notify.svelte",
    "..\\..\\TabEntry.svelte",
    "..\\..\\TabPanel.svelte",
    "..\\..\\Tabs.svelte"
  ],
  "sourcesContent": [
    "<script context=\"module\">\r\n import LeftNav  from './LeftNav.svelte';\r\n import verify   from '../util/verify';\r\n\r\n // DESC: <AppLayout> provides the layout of visualize-it.\r\n //       It is a \"singleton\" UI Component, instantiated one time in the app root.\r\n\r\n // NOTE: vars prefixed with underbar (\"_\"):\r\n //       - represent component instance state of the one-and-only <AppLayout> instance\r\n //       - are initialized through life-cycle-hooks (e.g. onMount())\r\n //       - are indirectly used for public promotion to the outside world\r\n\r\n let _leftNavComp; // ... our one-and-only <LeftNav/> component instance\r\n const activateSingleton = (leftNavComp) => {\r\n   // verify singleton restriction\r\n   verify(!isActive(), 'only ONE <AppLayout/> component should be instantated (at the app root)');\r\n\r\n   // register component binding\r\n   _leftNavComp = leftNavComp;\r\n\r\n   // process any prior cached requests\r\n   if (cachedLeftNavComps.length) {\r\n     cachedLeftNavComps.forEach( (comp) => registerLeftNavEntry(comp));\r\n     cachedLeftNavComps = [];\r\n   }\r\n };\r\n const deactivateSingleton = () => _leftNavComp = null;\r\n const isActive            = () => _leftNavComp ? true : false;\r\n\r\n //***\r\n //*** PUBLIC API\r\n //***\r\n\r\n let cachedLeftNavComps = [];\r\n\r\n // + registerLeftNavEntry(comp): void ... dynamically add supplied component entry to LeftNav\r\n export function registerLeftNavEntry(comp) {\r\n   // process request ... when we are active\r\n   if (isActive()) {\r\n     _leftNavComp.registerLeftNavEntry(comp);\r\n   }\r\n   // cache requests ... when we are inactive\r\n   else {\r\n     cachedLeftNavComps.push(comp);\r\n   }\r\n }\r\n</script>\r\n\r\n\r\n<script>\r\n import Drawer, {AppContent} from '@smui/drawer';\r\n import TopAppBar, {Row, Section, Title as AppBarTitle} from '@smui/top-app-bar';\r\n import IconButton   from '@smui/icon-button';\r\n import ToolBar      from './ToolBar.svelte';\r\n import {isPkgEntry} from '../util/typeCheck';\r\n import {toast}      from '../util/ui/notify';\r\n import Icon         from '../util/ui/Icon.svelte';\r\n import {onMount}    from 'svelte';\r\n import {PkgEntryTabs, \r\n         activeTab}  from '../pkgEntryTabs';\r\n\r\n // maintain our reflexive App Title ... either \"Visualize It\" or the Pkg Name of the active tab\r\n $: pkgEntry        = $activeTab           ? $activeTab.getTabContext()                 : null;\r\n $: appTitle        = $activeTab           ? $activeTab.getTabQualifyingDesc()          : 'Visualize It';\r\n $: titleToolTip    = isPkgEntry(pkgEntry) ? `Package: ${pkgEntry.getPkg().getPkgId()}` : '';\r\n $: titleIcon       = isPkgEntry(pkgEntry) ? pkgEntry.getPkg().getIconName()            : 'NONE';\r\n // ... for in-sync qualifiers, we monitor the SmartPkg's changeManager (reflexive store)\r\n //     derived from the ActivtTab's PkgEntry\r\n $: changeManager   = isPkgEntry(pkgEntry) ? pkgEntry.getPkg().changeManager            : null;\r\n $: inSyncTitleIcon = changeManager        ? $changeManager.inSyncIcon()                : 'NONE';\r\n $: if (changeManager && !$changeManager.inSync) {\r\n   titleToolTip += ' (modified - needs to be saved)';\r\n }\r\n\r\n // support for LeftNav (Drawer) dynamic sizing\r\n //  - the @smui way of setting <Drawer> size is through a sass variable:\r\n //    EX: in src/theme/_smui-theme.scss\r\n //           $mdc-drawer-width: 400px;\r\n //  - PROBLEM:  This is CANNOT be dynamic :-(\r\n //              SASS is a CSS preprocessor which means it is compiled into CSS at build time.\r\n //  - SOLUTION: Interpret the DOM resulting from the compiled CSS \r\n //              and override in-line styles at run-time with JavaScript\r\n //      <div class=\"vit-drawer-container\">\r\n //        <aside class=\"vit-drawer\"         <<< our drawerElm\r\n //               style=\"width: 550px;\">     <<< dynamic in-line style (managing width)\r\n //          <span bind:this={drawerHook}/>  <<< our hook into this DOM\r\n //          ... snip snip (drawer content)\r\n //        </aside> \r\n //        <div class=\"vit-drawer-app-content\"   <<< our appContentElm\r\n //             style=\"margin-left: 550px;\">     <<< dynamic in-line style (managing position when Drawer collapsed/expanded)\r\n //          <span bind:this={appContentHook}/>  <<< our hook into this DOM\r\n //          ... snip snip (app content)\r\n //        </div>\r\n //      </div>\r\n let drawerWidth = 256; // dynamic adjustement of drawer size (in pixels)\r\n let drawerHook,     drawerElm;\r\n let appContentHook, appContentElm;\r\n let resizerInitialized = false;\r\n $: if (drawerElm) {\r\n   drawerElm.style.width = `${drawerWidth}px`; // set Drawer width\r\n\r\n   // register our CSS-based resize controler\r\n   if (!resizerInitialized) { // ... one time only\r\n     resizerInitialized = true;\r\n\r\n     // promote a CSS-based resize control in our drawer's lower-right\r\n     drawerElm.style.resize   = 'horizontal';\r\n     drawerElm.style.minWidth = '200px';\r\n     drawerElm.style.maxWidth = '750px';\r\n\r\n     // register an observer to sync our state when resize occurs\r\n     // ... becase resize control is CSS-based\r\n     //     and we need visibility of this in our code\r\n     new ResizeObserver(resizeOccurred).observe(drawerElm);\r\n   }\r\n }\r\n $: if (appContentElm) {\r\n   // adjust appContent placement (consistent with LeftNav width)\r\n   appContentElm.style.marginLeft = drawerOpen ? `${drawerWidth}px`: '0px';\r\n }\r\n function resizeOccurred() { // sync our state when resize occurs\r\n   let width = drawerElm.offsetWidth;\r\n   // console.log(`XX resizeOccurred() width: ${width}`);\r\n   \r\n   // reflex content to our state, making the operation complete\r\n   // ... ONLY when our drawer is open (so as to NOT perminently loose our width)\r\n   if (drawerOpen) {\r\n     drawerWidth = width; // reflex to our state (making the operation complete)\r\n   }\r\n }\r\n\r\n // maintain our external bindings (once <AppLayout> is mounted)\r\n let leftNavComp; // ... maintained by `bind:this` (see below)\r\n onMount(() => {\r\n   activateSingleton(leftNavComp);\r\n\r\n   // binding for LeftNav (Drawer) dynamic sizing\r\n   drawerElm     = drawerHook.parentElement;\r\n   appContentElm = appContentHook.parentElement;\r\n\r\n   return deactivateSingleton;\r\n });\r\n\r\n // toggle Drawer (LeftNav) open/closed\r\n let drawerOpen = true;\r\n function toggleDrawer() {\r\n   drawerOpen = !drawerOpen;\r\n }\r\n</script>\r\n\r\n\r\n<!-- top-level page container ... manages 1. vit-page-app-bar and 2: vit-page-content -->\r\n<div class=\"vit-page-container\">\r\n\r\n  <!-- top-level page app-bar -->\r\n  <div class=\"vit-page-app-bar\">\r\n  <TopAppBar variant=\"static\" dense color=\"secondary\">\r\n    <Row>\r\n      <Section>\r\n        <IconButton class=\"material-icons\" title=\"Toggle Left Nav Package View\" on:click={toggleDrawer}>menu</IconButton>\r\n        <AppBarTitle title={titleToolTip}>\r\n          <Icon name={titleIcon}\r\n                size=\"1.0rem\"/>\r\n          {appTitle}\r\n          <Icon name={inSyncTitleIcon}\r\n                size=\"1.0rem\"/>\r\n        </AppBarTitle>\r\n      </Section>\r\n      <ToolBar/>\r\n    </Row>\r\n  </TopAppBar>\r\n  </div>\r\n\r\n  <!-- vit-page-content:     everything MINUS vit-page-app-bar -->\r\n  <!-- vit-drawer-container: manages 1. vit-drawer 2: vit-drawer-app-content -->\r\n  <div class=\"vit-page-content vit-drawer-container\">\r\n\r\n    <!-- vit-drawer (LeftNav) -->\r\n    <Drawer class=\"vit-drawer\" variant=\"dismissible\" bind:open={drawerOpen}>\r\n      <span bind:this={drawerHook}/>\r\n      <!-- farm this out to our LeftNav feature -->\r\n      <LeftNav bind:this={leftNavComp}/>\r\n    </Drawer>\r\n\r\n    <!-- vit-drawer-app-content: everything MINUS vit-drawer -->\r\n    <!-- vit-tabs-container:     flex container for util/ui/tabManager/Tabs (really TabEntry/TabPanel) -->\r\n    <AppContent class=\"vit-drawer-app-content vit-tabs-container\">\r\n      <span bind:this={appContentHook}/>\r\n      <!-- our dynamic Pkgentry tabs -->\r\n      <PkgEntryTabs/>\r\n    </AppContent>\r\n  </div>\r\n</div>\r\n\r\n\r\n<style>\r\n /* NOTE: clarification of the usage of: :global() -and- universal selector (*)\r\n\r\n    - example:\r\n  * :global(.vit-drawer-app-content) {\r\n    ... rules (snip snip)\r\n    }\r\n\r\n    - :global()\r\n\r\n    This is a Svelte feature that allows you to apply styles to a\r\n    selector globally.\r\n\r\n    In the example (above) it applies to ALL elements with class\r\n    vit-drawer-app-content, in any component that are decendants of\r\n    any element belonging to this component.\r\n\r\n    AI: I don't fully understand this, but without this in some\r\n    cases (as the one above), the generated css doesn't show up.\r\n\r\n    - descendant combinator using the universal selector (*) \r\n\r\n    This is simply providing a \"more specific\" rule that overrides\r\n    the implicit mdc classes injected by the @smui UI Kit.\r\n\r\n    In the example above the implicit .mdc-drawer-app-content\r\n    (injected by the @smui UI Kit) takes precidence WITHOUT the\r\n    descendant combinator.  With it, it has the effect of making the\r\n    rule more \"important\"!\r\n\r\n    I believe this is due to a combination of Svelte heuristics -and-\r\n    the @smui UI Kit I am using.\r\n  */\r\n\r\n /* top-level page container ... manages 1. vit-page-app-bar and 2: vit-page-content */\r\n .vit-page-container {\r\n   /* baseline our size to fill the entire page (i.e. the browser window) */\r\n   width:          100%;\r\n   height:         100%;\r\n\r\n   /* flex container characteristics: */\r\n   display:        flex; /* AI: flex seems to work just as well as: inline-flex */\r\n   flex-direction: column;\r\n   flex-wrap:      nowrap;\r\n   align-items:    stretch;\r\n }\r\n\r\n /* top-level page app-bar */\r\n /* AI: NOT really needed: currently all characteristics are coming from @smui <TopAppBar> */\r\n * :global(.vit-page-app-bar) {\r\n   /* flex item characteristics: */\r\n   flex-grow:  0;\r\n\r\n   /* color: red; /* xx diagnostic */\r\n }\r\n\r\n /* vit-page-content: everything MINUS vit-page-app-bar */\r\n .vit-page-content {\r\n\r\n   /* flex item characteristics: */\r\n   flex-grow:  1;  /* fill out to all space */\r\n\r\n   overflow:   auto; /* inject scroll-bars at this level */\r\n\r\n   /* NOTE: flex container characteristics for our <Drawer> (LeftNav)\r\n      is supplied via a seperate class: vit-drawer-container */\r\n\r\n   /* general characteristics: */\r\n   /* background-color: lightgrey; /* diagnostic */\r\n }\r\n\r\n /* vit-drawer-container: manages 1. vit-drawer 2: vit-drawer-app-content */\r\n .vit-drawer-container {\r\n   /* flex container characteristics: */\r\n   display:        flex; /* AI: flex seems to work just as well as: inline-flex */\r\n   flex-direction: row;\r\n   flex-wrap:      nowrap;\r\n   align-items:    stretch;\r\n\r\n   position: relative; /* REQUIRED (for Drawer): WEIRD: without this causes: browser scroll bar the height of <TopAppBar> */\r\n   /* z-index:  0;        /* doesn't appear to be needed - suspect Drawer related for modal only */\r\n }\r\n\r\n /* vit-drawer (LeftNav) */\r\n /* AI: NOT used: currently all characteristics are coming from @smui <Drawer> */\r\n * :global(.vit-drawer) {\r\n   color: red; /* xx diagnostic */\r\n }\r\n\r\n /* vit-drawer-app-content: everything MINUS vit-drawer */\r\n * :global(.vit-drawer-app-content) {\r\n\r\n   /* flex item characteristics: */\r\n   flex-grow: 1;    /* fill out to all space */\r\n   overflow:  auto; /* inject scroll-bars at this level ... without it, scrolls BOTH vit-drawer and vit-drawer-app-content */\r\n\r\n   /* background-color: pink; /* diagnostic */\r\n   /* color:            red;  /* diagnostic */\r\n }\r\n\r\n /* vit-tabs-container: flex container for util/ui/tabManager/Tabs (really TabEntry/TabPanel) */\r\n :global(.vit-tabs-container) {\r\n   /* flex container characteristics: */\r\n   display:        flex;\r\n   flex-direction: column;\r\n   flex-wrap:      nowrap;\r\n   align-items:    stretch;\r\n }\r\n\r\n</style>\r\n",
    "<script>\r\n import {Section}    from '@smui/top-app-bar';\r\n import IconButton   from '@smui/icon-button';\r\n import Menu                          from '@smui/menu';\r\n import List, {Item, Text, Separator} from '@smui/list';\r\n import {activeTab}  from '../pkgEntryTabs';\r\n import DispMode     from '../core/DispMode';\r\n import {toast}      from '../util/ui/notify';\r\n\r\n // our reflection is based on the active tab's PkgEntry\r\n // ... for PkgEntries, we utilize it's changeManager reflexive store\r\n //     NOTE: getTabContext() isA PkgEntry ONLY for TabControllerPkgEntry type\r\n //           ... otherwize the .changeManager will be undefined\r\n //               which is OK in this context (see sub-comments below)\r\n $: pkgEntry      = $activeTab    ? $activeTab.getTabContext() : null; // rougue value (when NON PkgEntry activeTab), null (when no activeTab)\r\n $: changeManager = pkgEntry      ? pkgEntry.changeManager     : null; // undefined (when NOT a PkgEntry type),       null (when no activeTab)\r\n $: dispMode      = changeManager ? $changeManager.dispMode    : null;\r\n $: undoAvail     = changeManager ? $changeManager.undoAvail   : false;\r\n $: redoAvail     = changeManager ? $changeManager.redoAvail   : false;\r\n\r\n $: selectedDispMode = dispMode;\r\n function handleDispModeChange() {\r\n   // console.log(`xx handleDispModeChange(): ${selectedDispMode.enumKey}`);\r\n   changeManager.changeDispMode(selectedDispMode);\r\n }\r\n // AI: handleDispModeChange() reflexivity is WORKING correctly, however I'm not exactly sure how ... hmmmm\r\n //     ... all reflexivity is triggered as changed (activate logs below and see for yourself)\r\n //     ... it has NOTHING to do with the logic of handleDispModeChange() ... can no-op it and reflexivity still occurs\r\n // $: console.log(`xx <ToolBar> $activeTab    changed: ${$activeTab    ? 'whatever'               : 'undefined'}`);\r\n // $: console.log(`xx <ToolBar> pkgEntry      changed: ${pkgEntry      ? pkgEntry.getPkgEntryId() : 'undefined'}`);\r\n // $: console.log(`xx <ToolBar> changeManager changed: ${changeManager ? 'whatever'               : 'undefined'}`);\r\n // $: console.log(`xx <ToolBar> dispMode      changed: ${dispMode      ? dispMode.enumKey         : 'undefined'}`);\r\n\r\n function handleUndo() {\r\n   changeManager.applyUndo();\r\n }\r\n\r\n function handleRedo() {\r\n   changeManager.applyRedo();\r\n }\r\n\r\n\r\n //***\r\n //*** global ToolBar items\r\n //***\r\n\r\n // our systemMenu binding\r\n let systemMenu;\r\n\r\n function handleAbout() {\r\n   // AI: figure out HOW to glean this info directly from our package.json\r\n   const name        = \"visualize-it\";\r\n   const version     = \"0.1.2\";\r\n   const description = \"Your View into External Systems\";\r\n   toast({msg: `${name}\r\n\r\n${description}\r\n\r\nversion: ${version}\r\n - Tabs can now be re-positioned (via DnD)\r\n - and LeftNav can be re-sized\r\n`});\r\n }\r\n\r\n</script>\r\n\r\n<Section align=\"end\" toolbar>\r\n\r\n  <!-- ToolBar items specific to activeTabs of PkgEntry types -->\r\n  {#if changeManager}\r\n\r\n    <!-- DispMode -->\r\n    <select bind:value={selectedDispMode}\r\n            on:change={handleDispModeChange}\r\n            class=\"mdc-typography--subtitle2\"\r\n            title=\"Disp Mode\">\r\n      {#each Array.from(DispMode) as dm (dm.enumKey)}\r\n        <option value={dm}\r\n                disabled={!pkgEntry.canHandleDispMode(dm)}>{dm.enumKey}</option>\r\n\t    {/each}\r\n    </select>\r\n    \r\n    <!-- Undo/Redo (only active in edit DispMode) -->\r\n    {#if dispMode === DispMode.edit}\r\n      <span>\r\n        <IconButton class=\"material-icons\"\r\n                    disabled={!undoAvail}\r\n                    title=\"Undo\"\r\n                    on:click={handleUndo}>undo</IconButton>\r\n        <IconButton class=\"material-icons\"\r\n                    disabled={!redoAvail}\r\n                    title=\"Redo\"\r\n                    on:click={handleRedo}>redo</IconButton>\r\n      </span>\r\n    {/if}\r\n\r\n  {/if}\r\n\r\n  <!-- global ToolBar items -->\r\n  <span>\r\n    <IconButton class=\"material-icons\"\r\n                title=\"System Info\"\r\n                on:click={() => systemMenu.setOpen(true)}>account_circle</IconButton>\r\n    \r\n    <Menu bind:this={systemMenu} anchorCorner=\"BOTTOM_LEFT\">\r\n      <List class=\"mdc-typography--subtitle2\">\r\n        <Item on:SMUI:action={handleAbout}><Text>About ...</Text></Item>\r\n   <!-- <Separator/> -->\r\n      </List>\r\n    </Menu>\r\n  </span>\r\n\r\n</Section>\r\n\r\n\r\n<style>\r\n select { /* customize our DispMode selector */\r\n   border:        2px solid #102027;  /* THEME: $mdc-theme-secondary-dark */\r\n   border-radius: 0.5rem;\r\n   font-size:     0.8rem;\r\n   background-color: #26a69a;  /* THEME: $mdc-theme-primary */\r\n }\r\n\r\n span :global(button:disabled) { /* disabled button */\r\n   color: #62727b;\r\n }\r\n</style>\r\n",
    "<script>\r\n import Paper, {Title, Content} from '@smui/paper';\r\n</script>\r\n\r\n\r\n<div class=\"splash-container\">\r\n  <Paper class=\"splash\">\r\n    <Content>\r\n      <img src=\"visualize-it-logo.png\" width=\"30%\" alt=\"Logo\"/>\r\n      <Title>Your View into External Systems!</Title>\r\n      <img src=\"visualize-it-logo-eyes.jpg\" width=\"80%\" alt=\"Logo Eyes\"/>\r\n    </Content>\r\n  </Paper>\r\n</div>\r\n\r\n\r\n<style>\r\n .splash-container {\r\n   padding: 11px;\r\n }\r\n\r\n * :global(.splash) {\r\n   margin:     0 auto;\r\n   max-width:  600px;\r\n   text-align: center /* center content */\r\n }\r\n</style>\r\n",
    "<script>\r\n import List, {Item, Meta, Text, Separator} from '@smui/list';\r\n import Menu            from '@smui/menu';\r\n import Icon            from '../util/ui/Icon.svelte';\r\n import verify          from '../util/verify';\r\n import {isPkg}         from '../util/typeCheck';\r\n import {toast}         from '../util/ui/notify';\r\n import discloseError   from '../util/discloseError';\r\n import ViewPkgTree     from './ViewPkgTree.svelte';\r\n import DispMode        from '../core/DispMode';\r\n import {savePkg as savePkgService} from '../core/pkgPersist';\r\n\r\n // component parameters\r\n export let pkg;\r\n\r\n // validate supplied parameters\r\n const check = verify.prefix('<ViewPkg> parameter violation: ');\r\n // ... pkg\r\n check(pkg,        'pkg is required');\r\n check(isPkg(pkg), `pkg must be a SmartPkg ... NOT: ${pkg}`);\r\n\r\n // diagnostic showing entire tree\r\n // $: console.log(`XX <ViewPkg> rendering \"enhanced\" ${pkg.toString('tree')}`);\r\n\r\n // maintain our reflexive expansion state\r\n let expanded = true;\r\n $: expandedIndicator = expanded ? '' : '...';\r\n\r\n // maintain our reflexive in-sync qualifiers\r\n const changeManager = pkg.changeManager;\r\n $: inSyncIcon       = $changeManager.inSyncIcon();\r\n $: pkgNameToolTip   = `Package: ${pkg.getPkgId()}` + ($changeManager.inSync ? '' : ' (modified - needs to be saved)');\r\n\r\n // our context menu binding\r\n let menu;\r\n\r\n // save our SmartPkg to an external resource (ex: web or local file)\r\n async function savePkg(saveAs=false) { // saveAs - true: save in a newly user selected file, false: save in the original pkg's `pkgResourcePath`\r\n   try {\r\n     // insure the package is a candidate for saving\r\n     if (!pkg.canPersist()) {\r\n       toast({msg: `The \"${pkg.getPkgName()}\" package cannot be saved ... it contains code, which cannot be persisted!`});\r\n       return;\r\n     }\r\n\r\n     // save the package\r\n     const result = await savePkgService(pkg, saveAs);\r\n     if (result === 'UserCancel') {\r\n     }\r\n     else if (result === 'SaveNotNeeded') {\r\n       toast({msg: `The \"${pkg.getName()}\" package does NOT need to be saved ... you must first apply some changes`});\r\n     }\r\n     else {\r\n       toast({msg: `The \"${pkg.getPkgName()}\" package has been saved!`});\r\n     }\r\n   }\r\n   catch(err) {\r\n     // gracefully report unexpected conditions to user\r\n     discloseError({err, logIt:true});\r\n   }\r\n }\r\n\r\n // our edit/view status ... a boolean\r\n $: inEditMode = pkg.getDispMode() === DispMode.edit; // true: edit package structure, false: package is read-only\r\n $: style      = inEditMode ? 'color: blue;' : '';\r\n $: undoAvail  = $changeManager.undoAvail;\r\n $: redoAvail  = $changeManager.redoAvail;\r\n\r\n // edit the structure of our SmartPkg (EPkg name/id, add/remove PkgEntry, dir structure, etc.)\r\n // ... changes the visual rendering to accomidate edits\r\n function editPkg() {\r\n   // insure our pkg can be saved before we allow it to be edited\r\n   if (!pkg.canPersist()) {\r\n     toast({msg: `The \"${pkg.getName()}\" package cannot be edited ` + \r\n                 `because it contains code ... therefore you would not be able to save your changes.`});\r\n     return;\r\n   }\r\n   // enable the edit mode\r\n   changeManager.changeDispMode(DispMode.edit);\r\n   pkg = pkg; // ... make responsive to Svelte\r\n   // toast({msg: `The \"${pkg.getPkgName()}\" package structure can now be edited (add/remove/reposition entries/directories, name/id changes, etc.)`});\r\n }\r\n\r\n // complete the edit operation of our SmartPkg (EPkg name/id, add/remove PkgEntry, dir structure, etc.)\r\n // ... reverting back to the \"normal\" usage mode (DispMode.view)\r\n function editPkgComplete() {\r\n   changeManager.changeDispMode(DispMode.view);\r\n   pkg = pkg; // ... make responsive to Svelte\r\n   // toast({msg: `The \"${pkg.getPkgName()}\" package structure is now in a view mode (edits are disabled)`});\r\n }\r\n\r\n // register our package structure GUI synchronization process (invoked via changeManager)\r\n pkg.syncPkgStructureGuiChanges = syncPkgStructureGuiChanges;\r\n function syncPkgStructureGuiChanges() {\r\n   pkg = pkg; // ... make responsive to Svelte\r\n }\r\n</script>\r\n\r\n<!-- NOTE: using activated strictly for it's coloring :-) -->\r\n<Item class=\"vit-drawer-item\"\r\n      activated\r\n      on:SMUI:action={() => expanded = !expanded}\r\n      title={pkgNameToolTip}>\r\n  <Icon name=\"{pkg.getIconName()}\"\r\n        {style}\r\n        size=\"1.0rem\"/>\r\n  <Text {style}>\r\n    {pkg.getPkgName()}\r\n    {expandedIndicator}\r\n  </Text>\r\n  <Icon name={inSyncIcon}\r\n        title=\"Package has been modified (needs to be saved) NOT SHOWING (qualified in pkgNameToolTip)\"\r\n        size=\"1.0rem\"/>\r\n  <Meta>\r\n    <Icon name=\"save\"\r\n          title=\"Save Package\"\r\n          on:click={(e) => {e.stopPropagation(); savePkg();} }/>\r\n\r\n    {#if inEditMode} <!-- for edit mode -->\r\n      <Icon name=\"check\"\r\n            title=\"Complete Package Edit\"\r\n            on:click={(e) => {e.stopPropagation(); editPkgComplete();} }/>\r\n    {:else} <!-- for view mode -->\r\n      <Icon name=\"edit\"\r\n            title=\"Edit Package Structure\"\r\n            on:click={(e) => {e.stopPropagation(); editPkg();} }/>\r\n    {/if}\r\n\r\n    <Icon name=\"more_vert\"\r\n          title=\"Manage Package\"\r\n          on:click={(e) => {e.stopPropagation(); menu.setOpen(true);} }/>\r\n  </Meta>\r\n</Item>\r\n\r\n<span>\r\n  <Menu bind:this={menu}>\r\n    <List>\r\n      <Item on:SMUI:action={() => savePkg()}>    <Text>Save {pkg.getPkgName()}</Text></Item>\r\n      <Item on:SMUI:action={() => savePkg(true)}><Text>Save As ...</Text></Item>\r\n      <Separator/>\r\n      {#if inEditMode} <!-- for edit mode -->\r\n        <Item on:SMUI:action={() => editPkgComplete()}><Text>Complete Package Edit</Text></Item>\r\n        <Item on:SMUI:action={() => changeManager.applyUndo()} disabled={!undoAvail}><Text>Undo</Text></Item>\r\n        <Item on:SMUI:action={() => changeManager.applyRedo()} disabled={!redoAvail}><Text>Redo</Text></Item>\r\n      {:else} <!-- for view mode -->\r\n        <Item on:SMUI:action={() => editPkg()}><Text>Edit Package Structure</Text></Item>\r\n      {/if}\r\n      <Separator/>\r\n      <Item on:SMUI:action={() => alert('FUTURE: Close')}><Text>Close</Text></Item>\r\n    </List>\r\n  </Menu>\r\n</span>\r\n\r\n{#if expanded}\r\n  <ViewPkgTree pkgTree={pkg.rootDir}/>\r\n{/if}\r\n\r\n\r\n<style>\r\n /* vit-drawer-item: attempt to space out <ViewPkgTree> content a bit better */\r\n * :global(.vit-drawer-item) {\r\n   margin: 8px 8px 0px 8px !important;\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n // retain ModuleScoped expansion state for each tree node\r\n // ... so collapsing a parent doesn't loose expansion state of children :-)\r\n const _expansionState = {\r\n   // pkgTreeKey: expanded <boolean>\r\n };\r\n</script>\r\n\r\n<script>\r\n import {getRegisteredTab,\r\n         activateTab}        from '../pkgEntryTabs';\r\n import {isPkg}              from '../util/typeCheck';\r\n import genDualClickHandler  from '../util/ui/genDualClickHandler';\r\n import Icon                 from '../util/ui/Icon.svelte';\r\n import DispMode             from '../core/DispMode';\r\n import {slide}              from 'svelte/transition'; // visually animated transitions for tree node expansion/contraction\r\n import {findAncestorWithCssClass} from '../util/ui/domUtil';\r\n\r\n // component props\r\n export let pkgTree;  // the PkgTree to display (will recurse into any sub-structure)\r\n\r\n // our primary reflexive state\r\n $: pkg        = pkgTree.getPkg();\r\n $: inEditMode = pkg.getDispMode() === DispMode.edit; // true: edit package structure, false: package is read-only\r\n $: pkgTreeKey = pkgTree.getKey();\r\n $: style      = inEditMode ? 'color: blue;' : '';    // edit/view styling\r\n $: top        = pkgTree.isRoot();\r\n \r\n // maintain our reflexive in-sync label qualifier\r\n // ... for PkgEntries, we utilize it's changeManager reflexive store\r\n const pkgEntry      = pkgTree.isEntry() ? pkgTree.getEntry()     : null;\r\n const changeManager = pkgEntry          ? pkgEntry.changeManager : null;\r\n let inSyncIcon;\r\n let pkgEntryToolTip;\r\n $: if (changeManager && !$changeManager.inSync) {\r\n   inSyncIcon       = $changeManager.inSyncIcon();\r\n   pkgEntryToolTip += ' (modified - Package needs to be saved)';\r\n }\r\n else {\r\n   inSyncIcon      = 'NONE';\r\n   pkgEntryToolTip = pkgEntry ? `${pkgEntry.diagClassName()}: ${pkgEntry.getEPkgId()}` : '';\r\n }\r\n\r\n // decompose self's tree node\r\n $: label    = pkgTree.getName();\r\n $: children = pkgTree.getChildren();\r\n\r\n // maintain expansion state\r\n // ... initialize from any prior expansion state\r\n // ... default to NOT expanded (false) on first occurance\r\n $: expanded  = _expansionState[pkgTreeKey] || false;\r\n $: arrowDown = expanded;\r\n const toggleExpansion = () => {\r\n   expanded = _expansionState[pkgTreeKey] = !expanded;\r\n };\r\n\r\n // locate the tabController pre-registered to this pkgEntry\r\n // ... preregisterTab() occurs in PkgViewer.svelte\r\n // ... NOTE: pkgEntry.getPkgEntryId() is the the tabId of a TabControllerPkgEntry object\r\n const tabController = pkgEntry ? getRegisteredTab(pkgEntry.getPkgEntryId()) : null;\r\n\r\n const displayEntry = genDualClickHandler(\r\n   () => activateTab(tabController.getTabId(), /*preview*/true),  // single-click\r\n   () => activateTab(tabController.getTabId(), /*preview*/false), // double-click\r\n );\r\n\r\n // support drag (of DnD), based on a combination of two polymorphic APIs: SmartObj.copyable() -and- PkgTree.copyable()\r\n const copySrcPkgEntry = pkgEntry ? pkgEntry.copyable() : null;\r\n $:    copySrcPkgTree  = pkgTree.copyable();\r\n $:    draggable       = copySrcPkgEntry || copySrcPkgTree  ? true : false;\r\n function handleDragStart(e) { // ... conditionally invoked when `draggable` is true (via draggleble DOM attribute - below)\r\n   // console.log(`xx ViewPkgTree handleDragStart(): starting`);\r\n\r\n   // specify cursor effects that ARE allowed\r\n   // ... subsequently later in dragenter/dragover events (via the dropEffect prop)\r\n   // ... multiple effects used ('linkMove'):\r\n   //     - link: for PkgEntry (to link a copy into Comp/Scene/Collage)\r\n   //     - move: for PkgTree  (to move SmartPkg PkgTree directory structure)\r\n\t e.dataTransfer.effectAllowed = 'linkMove';\r\n\r\n   // pack the data for our drag operation\r\n   // NOTE: We can use our own meta type (however NOTE that is is forced to be lower-case)\r\n   // ... PkgEntry (to link a copy into Comp/Scene/Collage))\r\n   if (copySrcPkgEntry) {\r\n     e.dataTransfer.setData(copySrcPkgEntry.type, copySrcPkgEntry.key);\r\n   }\r\n   // ... PkgTree (to move SmartPkg PkgTree directory structure)\r\n   if (copySrcPkgTree) {\r\n     e.dataTransfer.setData(copySrcPkgTree.type, copySrcPkgTree.key);\r\n   }\r\n };\r\n\r\n // allow DnD drops based on polymorphic PkgTree.pastable()\r\n // ... GRRR: Must implement BOTH dragenter/dragover BECAUSE have to override the default implementation (which prevents a drop).\r\n //           This is optimized by caching, since nothing changes (for us) in drag over.\r\n let isAllowed = null;\r\n let dropZone   = null; // null, 'before', 'in', 'after'\r\n $: dropZoneCssClass = dropZone ? `dropZone-${dropZone}` : '';\r\n function allowDrops_enter(e) {\r\n   isAllowed = pkgTree.pastable(e);\r\n   // console.log(`xx allowDrops_enter on: `, {isAllowed, pkgTree, types: e.dataTransfer.types});\r\n   allowDrops_over(e);\r\n };\r\n function allowDrops_over(e) {\r\n   // console.log(`xx allowDrops_over`);\r\n   if (isAllowed) {\r\n     e.preventDefault(); // allow drop (nullify default disallow behavior)\r\n     // console.log(`xx dropEffect BEFORE: ${e.dataTransfer.dropEffect}`);\r\n     e.dataTransfer.dropEffect = 'move'; // change cursor to reflect droppable\r\n     // console.log(`xx dropEffect AFTER: ${e.dataTransfer.dropEffect}`);\r\n\r\n     // maintain our visual drop zone (before/in/after)\r\n     dropZone = getDropZone(e);\r\n   }\r\n }\r\n\r\n // determine drop zone of the supplied DnD event (before/in/after)\r\n function getDropZone(e) {\r\n\r\n   // for sizing heuristics, we MUST use the DOM element that is managing our DnD event\r\n   // ... NOT: one of it's subordinates!\r\n   //          This insures the overall sizing is correct and NOT sporadic!!\r\n   const dropTargetElm = findAncestorWithCssClass(e.target, 'dropTarget');\r\n   // if (dropTargetElm !== e.target) {\r\n   //   console.log(`XX <ViewPkgTree> getDropZone(): using different target: `, {dropTargetElm, event_target: e.target});\r\n   // }\r\n\r\n   const boundingRect  = dropTargetElm.getBoundingClientRect();\r\n   let   {top, bottom} = boundingRect;       // ... tiny range (in our UI context): 17 pixels to work with\r\n   const clientY       = e.clientY;          // ... this WILL be in the top/bottom range\r\n   const numSections   = children ? 3 : 2;   // ... 3 sections for directories, 2 sections for entries\r\n   const boundry       = (bottom - top) / numSections; // ... divide up our sections evenly (in our case, rouphly 5 pixels for directories)\r\n\r\n   // prevent oscillation by stripping out the varying borders\r\n   // ... this is a brute force technique (a bit ugly)\r\n   //     I tried using CSS (box-sizing: border-box), \r\n   //     but this ONLY impacts boundingRect height, NOT top/bottom\r\n   const styling      = getComputedStyle(e.target);\r\n   const topBorder    = styling.getPropertyValue('border-top-width');\r\n   const bottomBorder = styling.getPropertyValue('border-bottom-width');\r\n   top    += parseInt(topBorder); // ... convert \"4px\" to 4\r\n   bottom -= parseInt(bottomBorder);\r\n\r\n   // define our dropZone\r\n   const rtnDropZone   = clientY > bottom-boundry ? 'after' : (clientY < top+boundry ? 'before' : 'in')\r\n\r\n   // console.log(`XX getDropZone():`, {rtnDropZone, clientY, top, bottom, boundry, topBorder, bottomBorder});\r\n   // console.log(`XX getDropZone(): ${rtnDropZone}`);\r\n   return rtnDropZone;\r\n }\r\n\r\n // perform DnD drop based on polymorphic PkgTree.paste()\r\n function handleDrop(e) {\r\n   // console.log(`\\n\\nxx handleDrop invoking paste() on: `, {pkgTree});\r\n   pkgTree.paste(e, dropZone);\r\n   dropZone = null; // clear visual dropZone\r\n };\r\n\r\n // console.log(`xx <ViewPkgTree> for ${pkgTreeKey}`);\r\n</script>\r\n\r\n<!-- omit the top root directory node - a \"/\" (it is implied by our Package Header) -->\r\n{#if top && children}\r\n  {#each children as child (child.getKey())}\r\n    <svelte:self pkgTree={child}/>\r\n  {/each}\r\n{:else}\r\n  <ul class:top transition:slide=\"{{duration: 500}}\">\r\n    <li>\r\n      {#if children}\r\n        <span class=\"mdc-typography--subtitle2 expander dropTarget {dropZoneCssClass}\"\r\n              title=\"Directory (click to expand/contract)\"\r\n              {draggable}\r\n              {style}\r\n              on:dragstart={handleDragStart}\r\n              on:dragenter={allowDrops_enter}\r\n              on:dragover={allowDrops_over}\r\n              on:dragleave={()=>dropZone=null}\r\n              on:drop|preventDefault={handleDrop}\r\n              on:click={toggleExpansion}>\r\n          <span class=\"arrow\" class:arrowDown>&#x25b6</span>\r\n          {label}\r\n        </span>\r\n        {#if expanded}\r\n          {#each children as child (child.getKey())}\r\n            <svelte:self pkgTree={child}/>\r\n          {/each}\r\n        {/if}\r\n      {:else}\r\n        <span class=\"mdc-typography--subtitle2 pkg-entry\"\r\n              title={pkgEntryToolTip}\r\n              on:click={displayEntry}>\r\n          <span class=\"dropTarget {dropZoneCssClass}\"\r\n                {draggable}\r\n                {style}\r\n                on:dragstart={handleDragStart}\r\n                on:dragenter={allowDrops_enter}\r\n                on:dragover={allowDrops_over}\r\n                on:dragleave={()=>dropZone=null}\r\n                on:drop|preventDefault={handleDrop}>\r\n            <Icon name=\"{pkgEntry.getIconName()}\"\r\n                  size=\"1.0rem\"/>\r\n            {label}\r\n          </span>\r\n          <Icon name={inSyncIcon}\r\n                {style}\r\n                size=\"1.0rem\"/>\r\n        </span>\r\n      {/if}\r\n    </li>\r\n  </ul>\r\n{/if}\r\n\r\n<style>\r\n ul {\r\n   margin:          0;      /* nix default <ul> spacing: 1em, 0 */\r\n   list-style-type: none;   /* nix traditional list bullets */\r\n   padding-left:    1.2rem; /* lesser list indendation */\r\n   user-select:     none;   /* disable selectable text */\r\n }\r\n ul.top { /* NO indentation FOR top-level node only */\r\n   margin:  0;\r\n   padding: 0;\r\n }\r\n .expander {\r\n   cursor:  pointer;\r\n }\r\n .pkg-entry{\r\n   cursor:  pointer;\r\n }\r\n .arrow {\r\n/* color:               red; /* AI: how to access scss vars */\r\n   display:             inline-block;\r\n   transition-duration: 500ms;\r\n   transition-property: transform;\r\n }\r\n .arrowDown {\r\n   transform: rotate(90deg);\r\n }\r\n .dropZone-before {\r\n   border-top: 4px solid;\r\n }\r\n .dropZone-in {\r\n   border: 2px dotted;\r\n }\r\n .dropZone-after {\r\n   border-bottom: 4px solid;\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n import verify from '../../verify';\r\n\r\n // function in our one-and-only <Notify/> component instance\r\n // ... maintained by <Notify/> life-cycle-hooks\r\n let _pushMsgOnSnackbar$comp;\r\n\r\n // pushMsgOnSnackbar(): our exposed programatic interface\r\n // ... accessed via: import {pushMsgOnSnackbar} from './Notify.svelte'\r\n export function pushMsgOnSnackbar(snackbarParams) {\r\n   // verify the proper context\r\n   verify(_pushMsgOnSnackbar$comp, 'toast() setup violation: a <Notify/> component is required to be instantated (at the app root)');\r\n\r\n   // propogate request to our one-and-only <Notify/> component instance\r\n   _pushMsgOnSnackbar$comp(snackbarParams);\r\n }\r\n</script>\r\n\r\n<script>\r\n import Kitchen     from '@smui/snackbar/kitchen';\r\n import {onMount}   from 'svelte';\r\n\r\n // our programmatic interface to the Snackbar kitchen\r\n // ... initialized via bind:this\r\n let kitchen;\r\n\r\n function pushMsgOnSnackbar$comp(snackbarParams) {\r\n   kitchen.push(snackbarParams);\r\n }\r\n\r\n // maintain our external functional binding (when <Notify> is mounted)\r\n onMount(() => {\r\n   // insure only one <Notify/> component\r\n   verify(!_pushMsgOnSnackbar$comp, 'only ONE <Notify/> component should be instantated (at the app root)');\r\n\r\n   // retain our external binding\r\n   _pushMsgOnSnackbar$comp = pushMsgOnSnackbar$comp;\r\n\r\n   // return function to invoke with unmounted\r\n\t return () => _pushMsgOnSnackbar$comp = null;\r\n });\r\n</script>\r\n\r\n<Kitchen bind:this={kitchen}\r\n         snackbar$leading={true}\r\n         snackbar$timeoutMs={4000}\r\n         dismiss$class=\"material-icons\"/>\r\n<!-- snackbar$leading:   grrr - can only set Snackbar position at <Kitchen> instantiation time -->\r\n<!-- snackbar$timeoutMs: grrr - can only define timeout at <Kitchen> instantiation time (4000–10000) -->\r\n<!-- dismiss$class:      configure the close/dismiss control to be the X icon ... FYI: SMUI injects any dismiss$ prefixed prop onto it's dissmiss IconButton -->\r\n\r\n<style>\r\n /* control layout of the snackbar message text */\r\n :global(.mdc-snackbar__label) {\r\n   white-space: pre-wrap; /* honor cr/lf breaks and overall spacing */\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n const CLOSE = 'cancel_presentation';\r\n const STALE = 'fiber_manual_record';\r\n</script>\r\n\r\n<script>\r\n import Icon from '../Icon.svelte';\r\n import Menu                          from '@smui/menu';\r\n import List, {Item, Text, Separator} from '@smui/list';\r\n import {findAncestorWithCssClass}    from '../domUtil';\r\n\r\n // accept component props\r\n export let tab;        // ... the TabController we are displaying\r\n export let tabManager; // ... the TabManager governing our set of dynamic tabs\r\n\r\n // validate component props\r\n // ... because this is an internal component, we bypass this step :-)\r\n\r\n // extract the various controls needed from our tabManager\r\n const {activeTab, previewTab, activateTab, closeTab, closeOtherTabs, closeTabsToRight, closeAllTabs, repositionTab} = tabManager;\r\n\r\n // extract needed primitives out of our tab\r\n // ... this optimizes svelte, because it uses primitive staleness identity semantics\r\n const tabId   = tab.getTabId();\r\n const tabName = tab.getTabName();\r\n\r\n // the app-specific suplement to our popup context menu\r\n // ... if any (null for none)\r\n const AppContextMenu = tab.getAppContextMenu();\r\n\r\n // maintain our dynamic css classes\r\n $: classes = `tab-entry mdc-typography--subtitle2\r\n               ${tab===$activeTab  ? 'active-tab'  : ''}\r\n               ${tab===$previewTab ? 'preview-tab' : ''}`;\r\n\r\n // maintain our closeIcon -and- staleness reflexive state\r\n // NOTE: This is patterned after VSCode tabs, and cleans up the clutter by:\r\n //       - only displaying the closeIcon when it is active (or hovered over)\r\n //       - re-uses the closeIcon with a stale indicator (for modified tab resources)\r\n // NOTE: Regarding the TabContext usage:\r\n //       - for TabControllerPkgEntry derivations, the context will be a PkgEntry\r\n //         * in this case we utilize it's changeManager reflexive store\r\n //         * otherwize the changeManager will be undefined\r\n //       - AI: this is a slightly inappropriate coupling (app knowledge in this generic utility)\r\n const tabContext    = tab.getTabContext();\r\n const changeManager = tabContext.changeManager; // reflexive store ... undefined if tabContext is NOT PkgEntry (see NOTE above)\r\n\r\n let closeIconName;          // {string):  the icon name to use for our closeIcon control (reused for stale indicator)\r\n let closeIconVisible;       // {boolean}: is the closeIcon control visable? (generally NOT when tab is not-active)\r\n let closeIconStyle   = '';  // {string}:  the CSS styling used to make icon visable/hidden\r\n let closeIconToolTip = '';  // {string}:  the closeIcon tooltip (changes to reflect modified resources)\r\n let tabHover       = false; // {boolean}: is mouse hovered over the overall tab? (forces the tab to display the closeIcon control, even when non active)\r\n let closeIconHover = false; // {boolean}: is mouse hovered over the closeIcon control? (forces a stale indicator to morph back into the actual close icon)\r\n $: {\r\n   // by default, our close icon is only visible on active tabs\r\n   closeIconName    = CLOSE;\r\n   closeIconVisible = tab===$activeTab;\r\n   closeIconToolTip = 'Close Tab';\r\n   \r\n   // override: when resource is stale (i.e. needs saving) we morph our close icon to STALE\r\n   //           and display it AT ALL TIMES\r\n   if (changeManager && !$changeManager.inSync) {\r\n     closeIconName    = STALE;\r\n     closeIconVisible = true;\r\n     closeIconToolTip = 'Close Modified Tab (resource is still held in package)';\r\n   }\r\n\r\n   // when mouse is hovered over our tab, show the closeIcon\r\n   if (tabHover) {\r\n     closeIconVisible = true;\r\n   }\r\n\r\n   // when mouse is hovered over the close icon, morph it into the \"true close\"\r\n   if (closeIconHover) {\r\n     closeIconName    = CLOSE;\r\n     closeIconVisible = true;\r\n   }\r\n\r\n   // maintain our close visibility via CSS styling\r\n   closeIconStyle = closeIconVisible ? '' : 'visibility: hidden;';\r\n   // console.log(`xx TabEntry (${tabId}) reflexing ... closeIconName: '${closeIconName}' ... closeIconVisible: ${closeIconVisible} ... closeIconStyle: \"${closeIconStyle}\"`);\r\n }\r\n\r\n // our popup contextMenu binding\r\n let contextMenu;\r\n\r\n\r\n //***\r\n //*** DnD support of tabs order\r\n //***\r\n\r\n const dndPastableType = 'visualize-it/TabEntry'.toLowerCase();\r\n function handleDragStart(e) {\r\n\t e.dataTransfer.effectAllowed = 'move';\r\n   e.dataTransfer.setData(dndPastableType, tab.getTabId());\r\n };\r\n\r\n let isDropAllowed = false;\r\n let dropZone      = null; // null, 'before', 'after'\r\n $: dropZoneCssClass = dropZone ? `dropZone-${dropZone}` : '';\r\n\r\n function allowDrops_enter(e) { // of interest: this is actually executed more than you would think (on sub-elms of our tab-entry)\r\n   // maintain closure state that is UNCHANGED for allowDrops_over\r\n   isDropAllowed = e.dataTransfer.types.includes(dndPastableType);\r\n\r\n   // defer to allowDrops_over\r\n   allowDrops_over(e);\r\n };\r\n\r\n function allowDrops_over(e) {\r\n   if (isDropAllowed) {\r\n     e.preventDefault(); // allow drop (nullify default disallow behavior)\r\n     // console.log(`xx dropEffect BEFORE: ${e.dataTransfer.dropEffect}`);\r\n     e.dataTransfer.dropEffect = 'move'; // change cursor to reflect droppable\r\n     // console.log(`xx dropEffect AFTER: ${e.dataTransfer.dropEffect}`);\r\n\r\n     // maintain our visual drop zone (before/in/after)\r\n     dropZone = getDropZone(e);\r\n     // console.log(`xx allowDrops_over ... dropZone: ${dropZone}`);\r\n   }\r\n }\r\n\r\n function getDropZone(e) { // determine drop zone of the supplied DnD event (before/after)\r\n\r\n   // for sizing heuristics, we MUST use the DOM element that is managing our DnD event\r\n   // ... NOT: one of it's subordinates!\r\n   //          This insures the overall sizing is correct and NOT sporadic!!\r\n   const tabEntryElm = findAncestorWithCssClass(e.target, 'tab-entry');\r\n\r\n   const boundingRect  = tabEntryElm.getBoundingClientRect();\r\n   const {left, right} = boundingRect;\r\n   const clientX       = e.clientX;          // ... this WILL be in the left/right range\r\n   const numSections   = 2;                  // ... 2 sections (before/after)\r\n   const boundry       = (right - left) / numSections; // ... divide up our sections evenly\r\n\r\n   // calculate/return our dropZone\r\n   const rtnDropZone = clientX > right-boundry ? 'after' : 'before';\r\n   // console.log(`XX getDropZone():`, {rtnDropZone, clientX, left, right, boundry/*, leftBorder, rightBorder*/});\r\n   // console.log(`XX getDropZone(): ${rtnDropZone}`);\r\n   return rtnDropZone;\r\n }\r\n\r\n // last drop event (used in detecting duplicate drop events)\r\n let lastDropEvent = null;\r\n\r\n function handleDrop(e) {\r\n   const fromTabId = e.dataTransfer.getData(dndPastableType);\r\n   const toTabId   = tab.getTabId();\r\n   // console.log('XX handleDrop: ', {fromTabId, toTabId, dropZone});\r\n\r\n   // NO-OP when duplicate drop events are detected\r\n   // BUG: This is a work-aroung for now\r\n   //      ... see similar situation (fully explained) in SmartPkg.js (search: lastPkgTreePasteEvent)\r\n   if (lastDropEvent === e) {\r\n     // console.log('XX <TabEntry> handleDrop(): NO-OP ... detected duplicate drop event :-(');\r\n     return;\r\n   }\r\n   else {\r\n     lastDropEvent = e;\r\n   }\r\n\r\n   // reposition the tabs\r\n   repositionTab(fromTabId, toTabId, dropZone);\r\n\r\n   // clear visual dropZone\r\n   dropZone = null;\r\n };\r\n\r\n</script>\r\n\r\n\r\n<!-- in lieu of genDualClickHandler(), \r\n     double registration of click/dblclick WORKS (in this case),\r\n     and is more responsive! -->\r\n<div class=\"{classes} {dropZoneCssClass}\"\r\n     on:mouseover= {() => tabHover=true}\r\n     on:mouseout=  {() => tabHover=false}\r\n     on:click=     {() => activateTab(tabId, /*preview*/true)}\r\n     on:dblclick=  {() => activateTab(tabId, /*preview*/false)}\r\n     on:contextmenu|preventDefault={() => contextMenu.setOpen(true)}\r\n     draggable={true}\r\n     on:dragstart={handleDragStart}\r\n     on:dragenter={allowDrops_enter}\r\n     on:dragover={allowDrops_over}\r\n     on:dragleave={()=>dropZone=null}\r\n     on:drop|preventDefault={handleDrop}>\r\n\r\n  <!-- classification icon -->\r\n  <Icon name=\"{tabContext.getIconName()}\"\r\n        size=\"1.0rem\"/>\r\n\r\n  <!-- tab label -->\r\n  {tabName}\r\n\r\n  <!-- close tab control -->\r\n  <span on:mouseover= {() => closeIconHover=true}\r\n        on:mouseout=  {() => closeIconHover=false}>\r\n    <Icon name={closeIconName}\r\n          size=\"1.0rem\"\r\n          style={closeIconStyle}\r\n          title={closeIconToolTip}\r\n          on:click={(e)=> { e.stopPropagation(); closeTab(tabId); }}/>\r\n  </span>\r\n\r\n</div>\r\n\r\n<!-- context menu -->\r\n<!-- NOTE: this menu MUST be outside of <div> (above) because KRAZY @smui on:SMUI:action is invoking on:click of that <div> invoking activateTab() -->\r\n<span>\r\n  <Menu bind:this={contextMenu}>\r\n    <List class=\"mdc-typography--subtitle2\">\r\n\r\n      <svelte:component this={AppContextMenu} tab={tab}/>\r\n\r\n      <Item on:SMUI:action={() => closeTab(tabId)}><Text>Close Tab</Text></Item>\r\n      <Item on:SMUI:action={() => closeOtherTabs(tabId)}><Text>Close Others</Text></Item>\r\n      <Item on:SMUI:action={() => closeTabsToRight(tabId)}><Text>Close to the Right</Text></Item>\r\n      <Item on:SMUI:action={() => closeAllTabs()}><Text>Close All</Text></Item>\r\n      <Separator />\r\n      <Item on:SMUI:action={() => alert('FUTURE: Reveal in Left Nav')}><Text>Reveal in Left Nav</Text></Item>\r\n    </List>\r\n  </Menu>\r\n</span>\r\n\r\n\r\n<style>\r\n .tab-entry {\r\n   cursor:      pointer;\r\n   user-select: none;\r\n   font-weight: 500;\r\n\t padding:     0.2rem 0.5rem;\r\n   transition:  all, 0.3s;  /* transition animation for active-tab changes */\r\n\t border:                  solid lightgray 1px;\r\n\t border-bottom:           none;\r\n\t border-top-left-radius:  10px;\r\n\t border-top-right-radius: 10px;\r\n }\r\n\r\n .active-tab {\r\n\t background-color: #26a69a; /* cheap hard-coded match of current system */\r\n\t color:            #F5F5F5; /* whitesmoke */\r\n }\r\n\r\n .preview-tab {\r\n\t font-style: italic;\r\n }\r\n\r\n .dropZone-before {\r\n   border-left: 10px solid DarkRed;\r\n }\r\n .dropZone-after {\r\n   border-right: 10px solid DarkRed;\r\n }\r\n\r\n</style>\r\n",
    "<script>\r\n // accept component props\r\n export let tab;        // ... the TabController we are displaying\r\n export let isActive;   // ... boolean indicator as to whether self is active or not\r\n\r\n // validate component props\r\n // ... because this is an internal component, we bypass this step :-)\r\n\r\n // extract needed items out of our tab\r\n const {Comp, props} = tab.getTabPanel();\r\n\r\n // NIX DELAY: remove artificial delay of tab activation for animation purposes\r\n //? // simple TabPanel animation technique - delay activation to match animation duration of TabEntry\r\n //? // ... use half of the time in TabEntry animation\r\n //? let delayedActivation = false;\r\n //? $: setTimeout(()=>delayedActivation=isActive, 150);\r\n</script>\r\n\r\n\r\n<!-- .main-content: our payload! -->\r\n<!-- NIX DELAY: isActive WAS delayedActivation -->\r\n<main class=\"main-content\" style=\"display: {isActive ? 'block' : 'none'};\">\r\n  <svelte:component this={Comp} {...props}/>\r\n</main>\r\n\r\n\r\n<style>\r\n /* main-content: our payload! */\r\n .main-content {\r\n   /* flex item characteristics: */\r\n   flex-grow:  1;  /* fill out to all space (taken from old vit-tabs-content, however doesn't appear to be needed ... keep for now) */\r\n   overflow: auto; /* KEY: provide scroll bars within main-content only (without this, will scroll tabs too) */\r\n\r\n   /* general characteristics: */\r\n   box-sizing: border-box; /* VERY KOOL: account for border/padding in specified width/height */\r\n   padding:    4px;        /* nicety */\r\n\r\n   background-color: #ececec;            /* THEME: $mdc-theme-background NOT (just a little darker) */\r\n   border:           2px solid #26a69a;  /* THEME: $mdc-theme-primary */\r\n }\r\n</style>\r\n",
    "<script>\r\n import TabEntry    from './TabEntry.svelte';\r\n import TabPanel    from './TabPanel.svelte';\r\n import verify      from '../../verify';\r\n import {isClass}   from '../../typeCheck';\r\n import {flip}      from 'svelte/animate';\r\n import {backInOut as easing} from 'svelte/easing'; // like back/circ/expo\r\n\r\n // accept component props\r\n export let tabManager; // ... the TabManager governing our set of dynamic tabs\r\n export let splashComp; // ... the UI Component to use when NO tabs are present\r\n\r\n // validate component props\r\n const check = verify.prefix('<Tabs> property violation: ');\r\n // ... tabManager\r\n check(tabManager,                'tabManager is required');\r\n check(tabManager.preregisterTab, 'tabManager must be a TabManager instance');\r\n // ... splashComp\r\n check(splashComp,                'splashComp is required');\r\n check(isClass(splashComp),       'splashComp must be a Svelte UI Component');\r\n\r\n // pull out our tabs store (a reactive svlete store representing ALL visualized tabs)\r\n const {tabs, activeTab} = tabManager;\r\n</script>\r\n\r\n\r\n{#if $tabs.length > 0}\r\n  <!-- TabBar with TabEntries -->\r\n  <div class=\"tab-bar\">\r\n    {#each $tabs as tab (tab.getTabId())}\r\n      <span animate:flip={{duration: 800, easing}}>\r\n        <TabEntry {tab} {tabManager}/>\r\n      </span>\r\n  \t{/each}\r\n  </div>\r\n  \r\n  <!-- TabPanels  -->\r\n  {#each $tabs as tab (tab.getTabId())}\r\n    <TabPanel {tab} isActive={tab===$activeTab}/>\r\n  {/each}\r\n{:else}\r\n  <svelte:component this={splashComp}/>\r\n{/if}\r\n\r\n\r\n<style>\r\n .tab-bar {\r\n\t border-bottom: solid lightgray 1px;\r\n\t display:       flex;\r\n\t flex-wrap:     wrap; /* wrap tabs to 2nd line (simple technique when too many tabs to fit) */\r\n }\r\n</style>\r\n"
  ],
  "names": [],
  "mappings": "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"
}
{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\AppLayout.svelte",
    "..\\..\\ToolBar.svelte",
    "..\\..\\StartUpPage.svelte",
    "..\\..\\ViewPkg.svelte",
    "..\\..\\ViewPkgTree.svelte",
    "..\\..\\Notify.svelte",
    "..\\..\\TabEntry.svelte",
    "..\\..\\TabPanel.svelte",
    "..\\..\\Tabs.svelte"
  ],
  "sourcesContent": [
    "<script context=\"module\">\r\n import LeftNav  from './LeftNav.svelte';\r\n import verify   from '../util/verify';\r\n\r\n // DESC: <AppLayout> provides the layout of visualize-it.\r\n //       It is a \"singleton\" UI Component, instantiated one time in the app root.\r\n\r\n // NOTE: vars prefixed with underbar (\"_\"):\r\n //       - represent component instance state of the one-and-only <AppLayout> instance\r\n //       - are initialized through life-cycle-hooks (e.g. onMount())\r\n //       - are indirectly used for public promotion to the outside world\r\n\r\n let _leftNavComp; // ... our one-and-only <LeftNav/> component instance\r\n const activateSingleton = (leftNavComp) => {\r\n   // verify singleton restriction\r\n   verify(!isActive(), 'only ONE <AppLayout/> component should be instantated (at the app root)');\r\n\r\n   // register component binding\r\n   _leftNavComp = leftNavComp;\r\n\r\n   // process any prior cached requests\r\n   if (cachedLeftNavComps.length) {\r\n     cachedLeftNavComps.forEach( (comp) => registerLeftNavEntry(comp));\r\n     cachedLeftNavComps = [];\r\n   }\r\n };\r\n const deactivateSingleton = () => _leftNavComp = null;\r\n const isActive            = () => _leftNavComp ? true : false;\r\n\r\n //***\r\n //*** PUBLIC API\r\n //***\r\n\r\n let cachedLeftNavComps = [];\r\n\r\n // + registerLeftNavEntry(comp): void ... dynamically add supplied component entry to LeftNav\r\n export function registerLeftNavEntry(comp) {\r\n   // process request ... when we are active\r\n   if (isActive()) {\r\n     _leftNavComp.registerLeftNavEntry(comp);\r\n   }\r\n   // cache requests ... when we are inactive\r\n   else {\r\n     cachedLeftNavComps.push(comp);\r\n   }\r\n }\r\n</script>\r\n\r\n\r\n<script>\r\n import Drawer, {AppContent} from '@smui/drawer';\r\n import TopAppBar, {Row, Section, Title as AppBarTitle} from '@smui/top-app-bar';\r\n import IconButton   from '@smui/icon-button';\r\n import ToolBar      from './ToolBar.svelte';\r\n import {isPkgEntry} from '../util/typeCheck';\r\n import {toast}      from '../util/ui/notify';\r\n import Icon         from '../util/ui/Icon.svelte';\r\n import {onMount}    from 'svelte';\r\n import {PkgEntryTabs, \r\n         activeTab}  from '../pkgEntryTabs';\r\n\r\n // maintain our reflexive App Title ... either \"Visualize It\" or the Pkg Name of the active tab\r\n $: pkgEntry        = $activeTab           ? $activeTab.getTabContext()                 : null;\r\n $: appTitle        = $activeTab           ? $activeTab.getTabQualifyingDesc()          : 'Visualize It';\r\n $: titleToolTip    = isPkgEntry(pkgEntry) ? `Package: ${pkgEntry.getPkg().getPkgId()}` : '';\r\n $: titleIcon       = isPkgEntry(pkgEntry) ? pkgEntry.getPkg().getIconName()            : 'NONE';\r\n // ... for in-sync qualifiers, we monitor the SmartPkg's changeManager (reflexive store)\r\n //     derived from the ActivtTab's PkgEntry\r\n $: changeManager   = isPkgEntry(pkgEntry) ? pkgEntry.getPkg().changeManager            : null;\r\n $: inSyncTitleIcon = changeManager        ? $changeManager.inSyncIcon()                : 'NONE';\r\n $: if (changeManager && !$changeManager.inSync) {\r\n   titleToolTip += ' (modified - needs to be saved)';\r\n }\r\n\r\n // maintain our external bindings (once <AppLayout> is mounted)\r\n let leftNavComp; // ... maintained by `bind:this` (see below)\r\n onMount(() => {\r\n   activateSingleton(leftNavComp);\r\n   return deactivateSingleton;\r\n });\r\n\r\n // toggle Drawer (LeftNav) open/closed\r\n let drawerOpen = true;\r\n function toggleDrawer() {\r\n   drawerOpen = !drawerOpen;\r\n }\r\n</script>\r\n\r\n\r\n<!-- top-level page container ... manages 1. vit-page-app-bar and 2: vit-page-content -->\r\n<div class=\"vit-page-container\">\r\n\r\n  <!-- top-level page app-bar -->\r\n  <div class=\"vit-page-app-bar\">\r\n  <TopAppBar variant=\"static\" dense color=\"secondary\">\r\n    <Row>\r\n      <Section>\r\n        <IconButton class=\"material-icons\" title=\"Toggle Left Nav Package View\" on:click={toggleDrawer}>menu</IconButton>\r\n        <AppBarTitle title={titleToolTip}>\r\n          <Icon name={titleIcon}\r\n                size=\"1.0rem\"/>\r\n          {appTitle}\r\n          <Icon name={inSyncTitleIcon}\r\n                size=\"1.0rem\"/>\r\n        </AppBarTitle>\r\n      </Section>\r\n      <ToolBar/>\r\n    </Row>\r\n  </TopAppBar>\r\n  </div>\r\n\r\n  <!-- vit-page-content:     everything MINUS vit-page-app-bar -->\r\n  <!-- vit-drawer-container: manages 1. vit-drawer 2: vit-drawer-app-content -->\r\n  <div class=\"vit-page-content vit-drawer-container\">\r\n\r\n    <!-- vit-drawer (LeftNav) -->\r\n    <Drawer class=\"vit-drawer\" variant=\"dismissible\" bind:open={drawerOpen}>\r\n      <!-- farm this out to our LeftNav feature -->\r\n      <LeftNav bind:this={leftNavComp}/>\r\n    </Drawer>\r\n\r\n    <!-- vit-drawer-app-content: everything MINUS vit-drawer -->\r\n    <!-- vit-tabs-container:     flex container for util/ui/tabManager/Tabs (really TabEntry/TabPanel) -->\r\n    <AppContent class=\"vit-drawer-app-content vit-tabs-container\">\r\n      <!-- our dynamic Pkgentry tabs -->\r\n      <PkgEntryTabs/>\r\n    </AppContent>\r\n  </div>\r\n</div>\r\n\r\n\r\n<style>\r\n /* NOTE: clarification of the usage of: :global() -and- universal selector (*)\r\n\r\n    - example:\r\n  * :global(.vit-drawer-app-content) {\r\n    ... rules (snip snip)\r\n    }\r\n\r\n    - :global()\r\n\r\n    This is a Svelte feature that allows you to apply styles to a\r\n    selector globally.\r\n\r\n    In the example (above) it applies to ALL elements with class\r\n    vit-drawer-app-content, in any component that are decendants of\r\n    any element belonging to this component.\r\n\r\n    AI: I don't fully understand this, but without this in some\r\n    cases (as the one above), the generated css doesn't show up.\r\n\r\n    - descendant combinator using the universal selector (*) \r\n\r\n    This is simply providing a \"more specific\" rule that overrides\r\n    the implicit mdc classes injected by the @smui UI Kit.\r\n\r\n    In the example above the implicit .mdc-drawer-app-content\r\n    (injected by the @smui UI Kit) takes precidence WITHOUT the\r\n    descendant combinator.  With it, it has the effect of making the\r\n    rule more \"important\"!\r\n\r\n    I believe this is due to a combination of Svelte heuristics -and-\r\n    the @smui UI Kit I am using.\r\n  */\r\n\r\n /* top-level page container ... manages 1. vit-page-app-bar and 2: vit-page-content */\r\n .vit-page-container {\r\n   /* baseline our size to fill the entire page (i.e. the browser window) */\r\n   width:          100%;\r\n   height:         100%;\r\n\r\n   /* flex container characteristics: */\r\n   display:        flex; /* AI: flex seems to work just as well as: inline-flex */\r\n   flex-direction: column;\r\n   flex-wrap:      nowrap;\r\n   align-items:    stretch;\r\n }\r\n\r\n /* top-level page app-bar */\r\n /* AI: NOT really needed: currently all characteristics are coming from @smui <TopAppBar> */\r\n * :global(.vit-page-app-bar) {\r\n   /* flex item characteristics: */\r\n   flex-grow:  0;\r\n\r\n   /* color: red; /* xx diagnostic */\r\n }\r\n\r\n /* vit-page-content: everything MINUS vit-page-app-bar */\r\n .vit-page-content {\r\n\r\n   /* flex item characteristics: */\r\n   flex-grow:  1;  /* fill out to all space */\r\n\r\n   overflow:   auto; /* inject scroll-bars at this level */\r\n\r\n   /* NOTE: flex container characteristics for our <Drawer> (LeftNav)\r\n      is supplied via a seperate class: vit-drawer-container */\r\n\r\n   /* general characteristics: */\r\n   /* background-color: lightgrey; /* diagnostic */\r\n }\r\n\r\n /* vit-drawer-container: manages 1. vit-drawer 2: vit-drawer-app-content */\r\n .vit-drawer-container {\r\n   /* flex container characteristics: */\r\n   display:        flex; /* AI: flex seems to work just as well as: inline-flex */\r\n   flex-direction: row;\r\n   flex-wrap:      nowrap;\r\n   align-items:    stretch;\r\n\r\n   position: relative; /* REQUIRED (for Drawer): WEIRD: without this causes: browser scroll bar the height of <TopAppBar> */\r\n   /* z-index:  0;        /* doesn't appear to be needed - suspect Drawer related for modal only */\r\n }\r\n\r\n /* vit-drawer (LeftNav) */\r\n /* AI: NOT used: currently all characteristics are coming from @smui <Drawer> */\r\n * :global(.vit-drawer) {\r\n   color: red; /* xx diagnostic */\r\n }\r\n\r\n /* vit-drawer-app-content: everything MINUS vit-drawer */\r\n * :global(.vit-drawer-app-content) {\r\n\r\n   /* flex item characteristics: */\r\n   flex-grow: 1;    /* fill out to all space */\r\n   overflow:  auto; /* inject scroll-bars at this level ... without it, scrolls BOTH vit-drawer and vit-drawer-app-content */\r\n\r\n   /* background-color: pink; /* diagnostic */\r\n   /* color:            red;  /* diagnostic */\r\n }\r\n\r\n /* vit-tabs-container: flex container for util/ui/tabManager/Tabs (really TabEntry/TabPanel) */\r\n :global(.vit-tabs-container) {\r\n   /* flex container characteristics: */\r\n   display:        flex;\r\n   flex-direction: column;\r\n   flex-wrap:      nowrap;\r\n   align-items:    stretch;\r\n }\r\n\r\n</style>\r\n",
    "<script>\r\n import {Section}    from '@smui/top-app-bar';\r\n import IconButton   from '@smui/icon-button';\r\n import Menu                          from '@smui/menu';\r\n import List, {Item, Text, Separator} from '@smui/list';\r\n import {activeTab}  from '../pkgEntryTabs';\r\n import DispMode     from '../core/DispMode';\r\n import {toast}      from '../util/ui/notify';\r\n\r\n // our reflection is based on the active tab's PkgEntry\r\n // ... for PkgEntries, we utilize it's changeManager reflexive store\r\n //     NOTE: getTabContext() isA PkgEntry ONLY for TabControllerPkgEntry type\r\n //           ... otherwize the .changeManager will be undefined\r\n //               which is OK in this context (see sub-comments below)\r\n $: pkgEntry      = $activeTab    ? $activeTab.getTabContext() : null; // rougue value (when NON PkgEntry activeTab), null (when no activeTab)\r\n $: changeManager = pkgEntry      ? pkgEntry.changeManager     : null; // undefined (when NOT a PkgEntry type),       null (when no activeTab)\r\n $: dispMode      = changeManager ? $changeManager.dispMode    : null;\r\n $: undoAvail     = changeManager ? $changeManager.undoAvail   : false;\r\n $: redoAvail     = changeManager ? $changeManager.redoAvail   : false;\r\n\r\n $: selectedDispMode = dispMode;\r\n function handleDispModeChange() {\r\n   // console.log(`xx handleDispModeChange(): ${selectedDispMode.enumKey}`);\r\n   changeManager.changeDispMode(selectedDispMode);\r\n }\r\n // AI: handleDispModeChange() reflexivity is WORKING correctly, however I'm not exactly sure how ... hmmmm\r\n //     ... all reflexivity is triggered as changed (activate logs below and see for yourself)\r\n //     ... it has NOTHING to do with the logic of handleDispModeChange() ... can no-op it and reflexivity still occurs\r\n // $: console.log(`xx <ToolBar> $activeTab    changed: ${$activeTab    ? 'whatever'               : 'undefined'}`);\r\n // $: console.log(`xx <ToolBar> pkgEntry      changed: ${pkgEntry      ? pkgEntry.getPkgEntryId() : 'undefined'}`);\r\n // $: console.log(`xx <ToolBar> changeManager changed: ${changeManager ? 'whatever'               : 'undefined'}`);\r\n // $: console.log(`xx <ToolBar> dispMode      changed: ${dispMode      ? dispMode.enumKey         : 'undefined'}`);\r\n\r\n function handleUndo() {\r\n   changeManager.applyUndo();\r\n }\r\n\r\n function handleRedo() {\r\n   changeManager.applyRedo();\r\n }\r\n\r\n\r\n //***\r\n //*** global ToolBar items\r\n //***\r\n\r\n // our systemMenu binding\r\n let systemMenu;\r\n\r\n function handleAbout() {\r\n   // AI: figure out HOW to glean this info directly from our package.json\r\n   const name         = \"visualize-it\";\r\n   const version     = \"0.1.0\";\r\n   const description = \"Your View into External Systems\";\r\n   toast({msg: `${name}\r\n\r\n${description}\r\n\r\nversion: ${version}`});\r\n }\r\n\r\n</script>\r\n\r\n<Section align=\"end\" toolbar>\r\n\r\n  <!-- ToolBar items specific to activeTabs of PkgEntry types -->\r\n  {#if changeManager}\r\n\r\n    <!-- DispMode -->\r\n    <select bind:value={selectedDispMode}\r\n            on:change={handleDispModeChange}\r\n            class=\"mdc-typography--subtitle2\"\r\n            title=\"Disp Mode\">\r\n      {#each Array.from(DispMode) as dm (dm.enumKey)}\r\n        <option value={dm}\r\n                disabled={!pkgEntry.canHandleDispMode(dm)}>{dm.enumKey}</option>\r\n\t    {/each}\r\n    </select>\r\n    \r\n    <!-- Undo/Redo (only active in edit DispMode) -->\r\n    {#if dispMode === DispMode.edit}\r\n      <span>\r\n        <IconButton class=\"material-icons\"\r\n                    disabled={!undoAvail}\r\n                    title=\"Undo\"\r\n                    on:click={handleUndo}>undo</IconButton>\r\n        <IconButton class=\"material-icons\"\r\n                    disabled={!redoAvail}\r\n                    title=\"Redo\"\r\n                    on:click={handleRedo}>redo</IconButton>\r\n      </span>\r\n    {/if}\r\n\r\n  {/if}\r\n\r\n  <!-- global ToolBar items -->\r\n  <span>\r\n    <IconButton class=\"material-icons\"\r\n                title=\"System Info\"\r\n                on:click={() => systemMenu.setOpen(true)}>account_circle</IconButton>\r\n    \r\n    <Menu bind:this={systemMenu} anchorCorner=\"BOTTOM_LEFT\">\r\n      <List class=\"mdc-typography--subtitle2\">\r\n        <Item on:SMUI:action={handleAbout}><Text>About ...</Text></Item>\r\n   <!-- <Separator/> -->\r\n      </List>\r\n    </Menu>\r\n  </span>\r\n\r\n</Section>\r\n\r\n\r\n<style>\r\n select { /* customize our DispMode selector */\r\n   border:        2px solid #102027;  /* THEME: $mdc-theme-secondary-dark */\r\n   border-radius: 0.5rem;\r\n   font-size:     0.8rem;\r\n   background-color: #26a69a;  /* THEME: $mdc-theme-primary */\r\n }\r\n\r\n span :global(button:disabled) { /* disabled button */\r\n   color: #62727b;\r\n }\r\n</style>\r\n",
    "<script>\r\n import Paper, {Title, Content} from '@smui/paper';\r\n</script>\r\n\r\n\r\n<div class=\"splash-container\">\r\n  <Paper class=\"splash\">\r\n    <Content>\r\n      <img src=\"visualize-it-logo.png\" width=\"30%\" alt=\"Logo\"/>\r\n      <Title>Your View into External Systems!</Title>\r\n      <img src=\"visualize-it-logo-eyes.jpg\" width=\"80%\" alt=\"Logo Eyes\"/>\r\n    </Content>\r\n  </Paper>\r\n</div>\r\n\r\n\r\n<style>\r\n .splash-container {\r\n   padding: 11px;\r\n }\r\n\r\n * :global(.splash) {\r\n   margin:     0 auto;\r\n   max-width:  600px;\r\n   text-align: center /* center content */\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n import List, {Item, Meta, Text, Separator} from '@smui/list';\r\n import Menu            from '@smui/menu';\r\n import Icon            from '../util/ui/Icon.svelte';\r\n import verify          from '../util/verify';\r\n import {isPkg}         from '../util/typeCheck';\r\n import {toast}         from '../util/ui/notify';\r\n import {savePkg}       from '../core/pkgPersist';\r\n import discloseError   from '../util/discloseError';\r\n import ViewPkgTree     from './ViewPkgTree.svelte';\r\n\r\n /**\r\n  * Save the supplied SmartPkg to an external resource (ex: web or\r\n  * local file).\r\n  *\r\n  * @param {SmartPkg} pkg - the SmartPkg to save.\r\n  * @param {boolean} [saveAs=false] - true: save in a newly user\r\n  * selected file, false: save in the original pkg's `pkgResourcePath`.\r\n  */\r\n async function handleSavePkg(pkg, saveAs=false) {\r\n   try {\r\n     // insure the package is a candidate for saving\r\n     if (!pkg.canPersist()) {\r\n       toast({msg: `The \"${pkg.getPkgName()}\" package cannot be saved ... it contains code, which cannot be persisted!`});\r\n       return;\r\n     }\r\n\r\n     // save the package\r\n     const result = await savePkg(pkg, saveAs);\r\n     if (result === 'UserCancel') {\r\n     }\r\n     else if (result === 'SaveNotNeeded') {\r\n       toast({msg: `The \"${pkg.getName()}\" package does NOT need to be saved ... you must first apply some changes`});\r\n     }\r\n     else {\r\n       toast({msg: `The \"${pkg.getPkgName()}\" package has been saved!`});\r\n     }\r\n   }\r\n   catch(err) {\r\n     // gracefully report unexpected conditions to user\r\n     discloseError({err, logIt:true});\r\n   }\r\n }\r\n</script>\r\n\r\n<script>\r\n // component parameters\r\n export let pkg;\r\n\r\n // validate supplied parameters\r\n const check = verify.prefix('<ViewPkg> parameter violation: ');\r\n // ... pkg\r\n check(pkg,        'pkg is required');\r\n check(isPkg(pkg), `pkg must be a SmartPkg ... NOT: ${pkg}`);\r\n\r\n // maintain our reflexive expansion state\r\n let expanded = true;\r\n $: expandedIndicator = expanded ? '' : '...';\r\n\r\n // maintain our reflexive in-sync qualifiers\r\n const changeManager = pkg.changeManager;\r\n $: inSyncIcon       = $changeManager.inSyncIcon();\r\n $: pkgNameToolTip   = `Package: ${pkg.getPkgId()}` + ($changeManager.inSync ? '' : ' (modified - needs to be saved)');\r\n\r\n let menu;\r\n</script>\r\n\r\n<!-- using activated strictly for it's coloring :-) -->\r\n<Item class=\"vit-drawer-item\"\r\n      activated\r\n      on:SMUI:action={() => expanded = !expanded}\r\n      title={pkgNameToolTip}>\r\n  <Icon name=\"{pkg.getIconName()}\"\r\n        size=\"1.0rem\"/>\r\n  <Text>\r\n    {pkg.getPkgName()}\r\n    {expandedIndicator}\r\n    <Icon name={inSyncIcon}\r\n          title=\"Package has been modified (needs to be saved) NOT SHOWING (qualified in pkgNameToolTip)\"\r\n          size=\"1.0rem\"/>\r\n  </Text>\r\n  <Meta>\r\n    <Icon name=\"save\"\r\n          title=\"Save Package\"\r\n          on:click={(e) => {e.stopPropagation(); handleSavePkg(pkg);} }/>\r\n\r\n    <Icon name=\"more_vert\"\r\n          title=\"Manage Package\"\r\n          on:click={(e) => {e.stopPropagation(); menu.setOpen(true);} }/>\r\n  </Meta>\r\n</Item>\r\n\r\n<span>\r\n  <Menu bind:this={menu}>\r\n    <List>\r\n      <Item on:SMUI:action={() => handleSavePkg(pkg)}>      <Text>Save {pkg.getPkgName()}</Text></Item>\r\n      <Item on:SMUI:action={() => handleSavePkg(pkg, true)}><Text>Save As ...</Text></Item>\r\n      <Separator/>\r\n      <Item on:SMUI:action={() => alert('FUTURE: Rename')}><Text>Rename</Text></Item>\r\n      <Separator/>\r\n      <Item on:SMUI:action={() => alert('FUTURE: Close')}><Text>Close</Text></Item>\r\n    </List>\r\n  </Menu>\r\n</span>\r\n\r\n{#if expanded}\r\n  <ViewPkgTree {pkg}/>\r\n{/if}\r\n\r\n\r\n<style>\r\n /* vit-drawer-item: attempt to space out <ViewPkgTree> content a bit better */\r\n * :global(.vit-drawer-item) {\r\n   margin: 8px 8px 0px 8px !important;\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n // retain ModuleScoped expansion state for each tree node\r\n // ... so collapsing a parent doesn't loose expansion state of children :-)\r\n const _expansionState = {\r\n   // accumTreeId: expanded <boolean>\r\n };\r\n</script>\r\n\r\n<script>\r\n import {getRegisteredTab,\r\n         activateTab}        from '../pkgEntryTabs';\r\n import {isPkg}              from '../util/typeCheck';\r\n import genDualClickHandler  from '../util/ui/genDualClickHandler';\r\n import Icon                 from '../util/ui/Icon.svelte';\r\n import {slide}              from 'svelte/transition'; // visually animated transitions for tree node expansion/contraction\r\n import Ripple               from '@smui/ripple';\r\n\r\n\r\n // component params\r\n export let pkg;                 // the SmartPkg entry point (for public consumption) ... for internal recursive usage this is a PkgTree\r\n export let accumTreeId = '';    // INTERNAL: accumulative ID throughout tree\r\n\r\n // maintain our primary control indicators\r\n let top = true; // is this the top-level\r\n let pkgTree;    // our PkgTree (entries)\r\n if (isPkg(pkg)) { // ... top-level entry point (a SmartPkg)\r\n   pkgTree     = pkg.rootDir;\r\n   top         = true;\r\n   accumTreeId = pkg.getPkgId();    // force our top accumTreeId to be our pkg id\r\n   // console.log(`xx <ViewPkgTree> for ${pkg.getPkgName()}:\\n`, {pkgTree});\r\n }\r\n else { // ... subordinate levels within internal recursive usage (PkgTree entries)\r\n   pkgTree      = pkg;\r\n   top          = false;\r\n   accumTreeId += ` - ${pkgTree.getName()}`;\r\n }\r\n \r\n // maintain our reflexive in-sync label qualifier\r\n // ... for PkgEntries, we utilize it's changeManager reflexive store\r\n const pkgEntry      = pkgTree.isEntry() ? pkgTree.getEntry()                  : null;\r\n const changeManager = pkgEntry          ? pkgEntry.changeManager              : null;\r\n let inSyncIcon;\r\n let pkgEntryToolTip;\r\n $: if (changeManager && !$changeManager.inSync) {\r\n   inSyncIcon       = $changeManager.inSyncIcon();\r\n   pkgEntryToolTip += ' (modified - Package needs to be saved)';\r\n }\r\n else {\r\n   inSyncIcon      = 'NONE';\r\n   pkgEntryToolTip = pkgEntry ? `${pkgEntry.diagClassName()}: ${pkgEntry.getEPkgId()}` : '';\r\n }\r\n\r\n // decompose self's tree node\r\n $:    label    = pkgTree.getName();\r\n const children = pkgTree.getChildren();\r\n\r\n // maintain expansion state\r\n // ... initialize from any prior expansion state\r\n // ... default to NOT expanded (false) on first occurance\r\n let   expanded        = _expansionState[accumTreeId] || false;\r\n $:    arrowDown       = expanded;\r\n const toggleExpansion = () => {\r\n   expanded = _expansionState[accumTreeId] = !expanded;\r\n };\r\n\r\n // locate the tabController pre-registered to this pkgEntry\r\n // ... preregisterTab() occurs in PkgViewer.svelte\r\n // ... NOTE: pkgEntry.getPkgEntryId() is the the tabId of a TabControllerPkgEntry object\r\n const tabController = pkgEntry ? getRegisteredTab(pkgEntry.getPkgEntryId()) : null;\r\n\r\n const displayEntry = genDualClickHandler(\r\n   () => activateTab(tabController.getTabId(), /*preview*/true),  // single-click\r\n   () => activateTab(tabController.getTabId(), /*preview*/false), // double-click\r\n );\r\n\r\n // console.log(`xx <ViewPkgTree> for ${accumTreeId}`);\r\n</script>\r\n\r\n<!-- omit the top root directory node - a \"/\" (it is implied by our Package Header) -->\r\n{#if top && children}\r\n  {#each children as child}\r\n    <svelte:self pkg={child} {accumTreeId}/>\r\n  {/each}\r\n{:else}\r\n  <ul class:top transition:slide=\"{{duration: 500}}\">\r\n    <li>\r\n      {#if children}\r\n        <span class=\"mdc-typography--subtitle2 expander\"\r\n              title=\"Directory (click to expand/contract)\"\r\n              on:click={toggleExpansion}\r\n              use:Ripple={{ripple: true, color: 'surface', unbounded: false}}>\r\n          <span class=\"arrow\" class:arrowDown>&#x25b6</span>\r\n          {label}\r\n        </span>\r\n        {#if expanded}\r\n          {#each children as child}\r\n            <svelte:self pkg={child} {accumTreeId}/>\r\n          {/each}\r\n        {/if}\r\n      {:else}\r\n        <span class=\"mdc-typography--subtitle2 pkg-entry\"\r\n              title={pkgEntryToolTip}\r\n              on:click={displayEntry}>\r\n          <span class=\"no-arrow-spacer\"/>\r\n\r\n          <Icon name=\"{pkgEntry.getIconName()}\"\r\n                size=\"1.0rem\"/>\r\n\r\n          {label}\r\n\r\n          <Icon name={inSyncIcon}\r\n                size=\"1.0rem\"/>\r\n\r\n        </span>\r\n      {/if}\r\n    </li>\r\n  </ul>\r\n{/if}\r\n\r\n<style>\r\n ul {\r\n   margin:          0;      /* nix default <ul> spacing: 1em, 0 */\r\n   list-style-type: none;   /* nix traditional list bullets */\r\n   padding-left:    1.2rem; /* lesser list indendation */\r\n   user-select:     none;   /* disable selectable text */\r\n }\r\n ul.top { /* NO indentation FOR top-level node only */\r\n   margin:  0;\r\n   padding: 0;\r\n }\r\n .no-arrow-spacer {\r\n   padding-left:    1.0rem;\r\n }\r\n .expander {\r\n   cursor:  pointer;\r\n }\r\n .pkg-entry{\r\n   cursor:  pointer;\r\n }\r\n .arrow {\r\n/* color:               red; /* AI: how to access scss vars */\r\n   display:             inline-block;\r\n   transition-duration: 500ms;\r\n   transition-property: transform;\r\n }\r\n .arrowDown {\r\n   transform: rotate(90deg);\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n import verify from '../../verify';\r\n\r\n // function in our one-and-only <Notify/> component instance\r\n // ... maintained by <Notify/> life-cycle-hooks\r\n let _pushMsgOnSnackbar$comp;\r\n\r\n // pushMsgOnSnackbar(): our exposed programatic interface\r\n // ... accessed via: import {pushMsgOnSnackbar} from './Notify.svelte'\r\n export function pushMsgOnSnackbar(snackbarParams) {\r\n   // verify the proper context\r\n   verify(_pushMsgOnSnackbar$comp, 'toast() setup violation: a <Notify/> component is required to be instantated (at the app root)');\r\n\r\n   // propogate request to our one-and-only <Notify/> component instance\r\n   _pushMsgOnSnackbar$comp(snackbarParams);\r\n }\r\n</script>\r\n\r\n<script>\r\n import Kitchen     from '@smui/snackbar/kitchen';\r\n import {onMount}   from 'svelte';\r\n\r\n // our programmatic interface to the Snackbar kitchen\r\n // ... initialized via bind:this\r\n let kitchen;\r\n\r\n function pushMsgOnSnackbar$comp(snackbarParams) {\r\n   kitchen.push(snackbarParams);\r\n }\r\n\r\n // maintain our external functional binding (when <Notify> is mounted)\r\n onMount(() => {\r\n   // insure only one <Notify/> component\r\n   verify(!_pushMsgOnSnackbar$comp, 'only ONE <Notify/> component should be instantated (at the app root)');\r\n\r\n   // retain our external binding\r\n   _pushMsgOnSnackbar$comp = pushMsgOnSnackbar$comp;\r\n\r\n   // return function to invoke with unmounted\r\n\t return () => _pushMsgOnSnackbar$comp = null;\r\n });\r\n</script>\r\n\r\n<Kitchen bind:this={kitchen}\r\n         snackbar$leading={true}\r\n         snackbar$timeoutMs={4000}\r\n         dismiss$class=\"material-icons\"/>\r\n<!-- snackbar$leading:   grrr - can only set Snackbar position at <Kitchen> instantiation time -->\r\n<!-- snackbar$timeoutMs: grrr - can only define timeout at <Kitchen> instantiation time (4000â€“10000) -->\r\n<!-- dismiss$class:      configure the close/dismiss control to be the X icon ... FYI: SMUI injects any dismiss$ prefixed prop onto it's dissmiss IconButton -->\r\n\r\n<style>\r\n /* control layout of the snackbar message text */\r\n :global(.mdc-snackbar__label) {\r\n   white-space: pre-wrap; /* honor cr/lf breaks and overall spacing */\r\n }\r\n</style>\r\n",
    "<script context=\"module\">\r\n const CLOSE = 'cancel_presentation';\r\n const STALE = 'fiber_manual_record';\r\n</script>\r\n\r\n<script>\r\n import Icon from '../Icon.svelte';\r\n import Menu                          from '@smui/menu';\r\n import List, {Item, Text, Separator} from '@smui/list';\r\n\r\n // accept component props\r\n export let tab;        // ... the TabController we are displaying\r\n export let tabManager; // ... the TabManager governing our set of dynamic tabs\r\n\r\n // validate component props\r\n // ... because this is an internal component, we bypass this step :-)\r\n\r\n // extract the various controls needed from our tabManager\r\n const {activeTab, previewTab, activateTab, closeTab, closeOtherTabs, closeTabsToRight, closeAllTabs} = tabManager;\r\n\r\n // extract needed primitives out of our tab\r\n // ... this optimizes svelte, because it uses primitive staleness identity semantics\r\n const tabId   = tab.getTabId();\r\n const tabName = tab.getTabName();\r\n\r\n // the app-specific suplement to our popup context menu\r\n // ... if any (null for none)\r\n const AppContextMenu = tab.getAppContextMenu();\r\n\r\n // maintain our dynamic css classes\r\n $: classes = `tab-entry mdc-typography--subtitle2\r\n               ${tab===$activeTab  ? 'active-tab'  : ''}\r\n               ${tab===$previewTab ? 'preview-tab' : ''}`;\r\n\r\n // maintain our closeIcon -and- staleness reflexive state\r\n // NOTE: This is patterned after VSCode tabs, and cleans up the clutter by:\r\n //       - only displaying the closeIcon when it is active (or hovered over)\r\n //       - re-uses the closeIcon with a stale indicator (for modified tab resources)\r\n // NOTE: Regarding the TabContext usage:\r\n //       - for TabControllerPkgEntry derivations, the context will be a PkgEntry\r\n //         * in this case we utilize it's changeManager reflexive store\r\n //         * otherwize the changeManager will be undefined\r\n //       - AI: this is a slightly inappropriate coupling (app knowledge in this generic utility)\r\n const tabContext    = tab.getTabContext();\r\n const changeManager = tabContext.changeManager; // reflexive store ... undefined if tabContext is NOT PkgEntry (see NOTE above)\r\n\r\n let closeIconName;          // {string):  the icon name to use for our closeIcon control (reused for stale indicator)\r\n let closeIconVisible;       // {boolean}: is the closeIcon control visable? (generally NOT when tab is not-active)\r\n let closeIconStyle   = '';  // {string}:  the CSS styling used to make icon visable/hidden\r\n let closeIconToolTip = '';  // {string}:  the closeIcon tooltip (changes to reflect modified resources)\r\n let tabHover       = false; // {boolean}: is mouse hovered over the overall tab? (forces the tab to display the closeIcon control, even when non active)\r\n let closeIconHover = false; // {boolean}: is mouse hovered over the closeIcon control? (forces a stale indicator to morph back into the actual close icon)\r\n $: {\r\n   // by default, our close icon is only visible on active tabs\r\n   closeIconName    = CLOSE;\r\n   closeIconVisible = tab===$activeTab;\r\n   closeIconToolTip = 'Close Tab';\r\n   \r\n   // override: when resource is stale (i.e. needs saving) we morph our close icon to STALE\r\n   //           and display it AT ALL TIMES\r\n   if (changeManager && !$changeManager.inSync) {\r\n     closeIconName    = STALE;\r\n     closeIconVisible = true;\r\n     closeIconToolTip = 'Close Modified Tab (resource is still held in package)';\r\n   }\r\n\r\n   // when mouse is hovered over our tab, show the closeIcon\r\n   if (tabHover) {\r\n     closeIconVisible = true;\r\n   }\r\n\r\n   // when mouse is hovered over the close icon, morph it into the \"true close\"\r\n   if (closeIconHover) {\r\n     closeIconName    = CLOSE;\r\n     closeIconVisible = true;\r\n   }\r\n\r\n   // maintain our close visibility via CSS styling\r\n   closeIconStyle = closeIconVisible ? '' : 'visibility: hidden;';\r\n   // console.log(`xx TabEntry (${tabId}) reflexing ... closeIconName: '${closeIconName}' ... closeIconVisible: ${closeIconVisible} ... closeIconStyle: \"${closeIconStyle}\"`);\r\n }\r\n\r\n // our popup contextMenu binding\r\n let contextMenu;\r\n\r\n</script>\r\n\r\n\r\n<!-- in lieu of genDualClickHandler(), \r\n     double registration of click/dblclick WORKS (in this case),\r\n     and is more responsive! -->\r\n<div class={classes}\r\n     on:mouseover= {() => tabHover=true}\r\n     on:mouseout=  {() => tabHover=false}\r\n     on:click=     {() => activateTab(tabId, /*preview*/true)}\r\n     on:dblclick=  {() => activateTab(tabId, /*preview*/false)}\r\n     on:contextmenu|preventDefault={() => contextMenu.setOpen(true)}>\r\n\r\n  <!-- classification icon -->\r\n  <Icon name=\"{tabContext.getIconName()}\"\r\n        size=\"1.0rem\"/>\r\n\r\n  <!-- tab label -->\r\n  {tabName}\r\n\r\n  <!-- close tab control -->\r\n  <span on:mouseover= {() => closeIconHover=true}\r\n        on:mouseout=  {() => closeIconHover=false}>\r\n    <Icon name={closeIconName}\r\n          size=\"1.0rem\"\r\n          style={closeIconStyle}\r\n          title={closeIconToolTip}\r\n          on:click={(e)=> { e.stopPropagation(); closeTab(tabId); }}/>\r\n  </span>\r\n\r\n</div>\r\n\r\n<!-- context menu -->\r\n<!-- NOTE: this menu MUST be outside of <div> (above) because KRAZY @smui on:SMUI:action is invoking on:click of that <div> invoking activateTab() -->\r\n<span>\r\n  <Menu bind:this={contextMenu}>\r\n    <List class=\"mdc-typography--subtitle2\">\r\n\r\n      <svelte:component this={AppContextMenu} tab={tab}/>\r\n\r\n      <Item on:SMUI:action={() => closeTab(tabId)}><Text>Close Tab</Text></Item>\r\n      <Item on:SMUI:action={() => closeOtherTabs(tabId)}><Text>Close Others</Text></Item>\r\n      <Item on:SMUI:action={() => closeTabsToRight(tabId)}><Text>Close to the Right</Text></Item>\r\n      <Item on:SMUI:action={() => closeAllTabs()}><Text>Close All</Text></Item>\r\n      <Separator />\r\n      <Item on:SMUI:action={() => alert('FUTURE: Reveal in Left Nav')}><Text>Reveal in Left Nav</Text></Item>\r\n    </List>\r\n  </Menu>\r\n</span>\r\n\r\n\r\n<style>\r\n .tab-entry {\r\n   cursor:      pointer;\r\n   user-select: none;\r\n   font-weight: 500;\r\n\t padding:     0.2rem 0.5rem;\r\n   transition:  all, 0.3s;  /* transition animation for active-tab changes */\r\n\t border:                  solid lightgray 1px;\r\n\t border-bottom:           none;\r\n\t border-top-left-radius:  10px;\r\n\t border-top-right-radius: 10px;\r\n }\r\n\r\n .active-tab {\r\n\t background-color: #26a69a; /* cheap hard-coded match of current system */\r\n\t color:            #F5F5F5; /* whitesmoke */\r\n }\r\n\r\n .preview-tab {\r\n\t font-style: italic;\r\n }\r\n</style>\r\n",
    "<script>\r\n // accept component props\r\n export let tab;        // ... the TabController we are displaying\r\n export let isActive;   // ... boolean indicator as to whether self is active or not\r\n\r\n // validate component props\r\n // ... because this is an internal component, we bypass this step :-)\r\n\r\n // extract needed items out of our tab\r\n const {Comp, props} = tab.getTabPanel();\r\n\r\n // NIX DELAY: remove artificial delay of tab activation for animation purposes\r\n //? // simple TabPanel animation technique - delay activation to match animation duration of TabEntry\r\n //? // ... use half of the time in TabEntry animation\r\n //? let delayedActivation = false;\r\n //? $: setTimeout(()=>delayedActivation=isActive, 150);\r\n</script>\r\n\r\n\r\n<!-- .main-content: our payload! -->\r\n<!-- NIX DELAY: isActive WAS delayedActivation -->\r\n<main class=\"main-content\" style=\"display: {isActive ? 'block' : 'none'};\">\r\n  <svelte:component this={Comp} {...props}/>\r\n</main>\r\n\r\n\r\n<style>\r\n /* main-content: our payload! */\r\n .main-content {\r\n   /* flex item characteristics: */\r\n   flex-grow:  1;  /* fill out to all space (taken from old vit-tabs-content, however doesn't appear to be needed ... keep for now) */\r\n   overflow: auto; /* KEY: provide scroll bars within main-content only (without this, will scroll tabs too) */\r\n\r\n   /* general characteristics: */\r\n   box-sizing: border-box; /* VERY KOOL: account for border/padding in specified width/height */\r\n   padding:    4px;        /* nicety */\r\n\r\n   background-color: #ececec;            /* THEME: $mdc-theme-background NOT (just a little darker) */\r\n   border:           2px solid #26a69a;  /* THEME: $mdc-theme-primary */\r\n }\r\n</style>\r\n",
    "<script>\r\n import TabEntry    from './TabEntry.svelte';\r\n import TabPanel    from './TabPanel.svelte';\r\n import verify      from '../../verify';\r\n import {isClass}   from '../../typeCheck';\r\n\r\n // accept component props\r\n export let tabManager; // ... the TabManager governing our set of dynamic tabs\r\n export let splashComp; // ... the UI Component to use when NO tabs are present\r\n\r\n // validate component props\r\n const check = verify.prefix('<Tabs> property violation: ');\r\n // ... tabManager\r\n check(tabManager,                'tabManager is required');\r\n check(tabManager.preregisterTab, 'tabManager must be a TabManager instance');\r\n // ... splashComp\r\n check(splashComp,                'splashComp is required');\r\n check(isClass(splashComp),       'splashComp must be a Svelte UI Component');\r\n\r\n // pull out our tabs store (a reactive svlete store representing ALL visualized tabs)\r\n const {tabs, activeTab} = tabManager;\r\n</script>\r\n\r\n\r\n{#if $tabs.length > 0}\r\n  <!-- TabBar with TabEntries -->\r\n  <div class=\"tab-bar\">\r\n    {#each $tabs as tab (tab.getTabId())}\r\n      <TabEntry {tab} {tabManager}/>\r\n  \t{/each}\r\n  </div>\r\n  \r\n  <!-- TabPanels  -->\r\n  {#each $tabs as tab (tab.getTabId())}\r\n    <TabPanel {tab} isActive={tab===$activeTab}/>\r\n  {/each}\r\n{:else}\r\n  <svelte:component this={splashComp}/>\r\n{/if}\r\n\r\n\r\n<style>\r\n .tab-bar {\r\n\t border-bottom: solid lightgray 1px;\r\n\t display:       flex;\r\n\t flex-wrap:     wrap; /* wrap tabs to 2nd line (simple technique when too many tabs to fit) */\r\n }\r\n</style>\r\n"
  ],
  "names": [],
  "mappings": "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"
}
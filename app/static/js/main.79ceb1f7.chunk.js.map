{"version":3,"sources":["util/ErrorExtensionPolyfill.js","util/verify.js","util/typeCheck.js","util/checkUnknownArgs.js","core/pkgManager.js","core/PseudoClass.js","core/DispMode.js","core/createTypeRefHandler.js","util/crc.js","util/notify.js","features/common/changeManager/actions.js","features/common/changeManager/featureName.js","features/common/changeManager/changeManager.js","core/SmartModel.js","core/SmartPallet.js","core/konvaUtil.js","util/logger.js","core/SmartClassRef.js","core/CompRef.js","features/common/baseUI/comp/LeftNavMenuPallet.js","util/genDualClickHandler.js","core/SmartPkg.js","features/common/baseUI/LeftNavManager.js","features/common/baseUI/comp/LeftNavCollapsibleItem.js","features/common/tabManager/TabController.js","features/common/tabManager/tabRegistry.js","util/ReactSmartView.js","core/SmartView.js","features/common/tabManager/TabControllerScene.js","features/common/tabManager/TabControllerCollage.js","features/common/tabManager/TabControllerCompRef.js","core/Scene.js","core/Collage.js","core/preregisterCoreClasses.js","featureFlags.js","util/strUtil.js","core/SmartComp.js","features/sandbox/konvaSandbox/generalComps.js","features/sandbox/konvaSandbox/konvaSandboxSmartPkg.js","features/sandbox/feature.js","util/encoder.js","features/common/initFirebase/initializeFirebase.js","features/common/initFirebase/feature.js","features/common/baseUI/actions.js","features/common/baseUI/featureName.js","util/noOp.js","util/deviceStorage.js","features/common/baseUI/uiThemeStorage.js","features/common/baseUI/responsiveModeStorage.js","features/common/baseUI/state.js","util/reduxFnRef.js","features/common/baseUI/logic.js","features/common/baseUI/comp/LeftNav.js","features/common/baseUI/comp/UserMenu.js","core/pkgPersist.js","util/discloseError.js","features/common/baseUI/comp/FileMenu.js","features/toolBar/actions.js","features/toolBar/featureName.js","features/toolBar/state.js","features/toolBar/comp/VitToolBar.js","features/common/baseUI/comp/AppMotif.js","util/Transition.js","util/SplashScreen.js","util/responsiveBreakpoints.js","features/common/baseUI/comp/MainLayout.js","features/common/baseUI/comp/UserMenuItem.js","features/common/baseUI/comp/ToggleUITheme.js","features/common/baseUI/comp/MaintainResponsiveMode.js","features/common/baseUI/comp/About.js","features/common/baseUI/feature.js","features/common/changeManager/state.js","features/common/changeManager/feature.js","features/common/tabManager/actions.js","features/common/tabManager/featureName.js","features/common/tabManager/state.js","features/common/tabManager/logic.js","features/common/tabManager/comp/TabManager.js","util/CenterItems.js","features/common/tabManager/comp/StartUpPage.js","features/common/tabManager/route.js","features/common/tabManager/feature.js","features/toolBar/logic.js","features/toolBar/feature.js","features/common/diagnostic/logActions/logic.js","features/common/diagnostic/logActions/featureName.js","features/common/diagnostic/logActions/feature.js","features/common/pwa/serviceWorker.js","features/common/pwa/feature.js","features/index.js","aspects/index.js","app.js","index.js"],"names":["Error","prototype","defineUserMsg","userMsg","this","expected","isExpected","isUnexpected","defineAttemptingToMsg","attemptingToMsg","formatUserMsg","prior_toString","toString","call","verify","condition","msg","prefix","msgPrefix","isClass","isFunction","isNumber","ref","isSmartObject","isaSmartObject","isEPkg","isaEPkg","checkUnknownArgs","check","unknownNamedArgs","args","unknownArgKeys","Object","keys","length","PkgManager","pkgCatalog","smartPkg","constructor","unmangledName","isaPkg","pkgId","getPkgId","isString","className","classRef","getClassRef","entryId","getPkgEntry","pkgManager","PseudoClass","id","name","unknownArgs","arguments","isType","pseudoClass","clazz","isPseudoClassMaster","DispMode","Enumify","createTypeRefHandler","handlers","isPlainObject","handleNoRef","handlePrimitive","handleArray","handlePlainObj","handleSmartObj","handleNonSmartObj","handleClass","setupHandlers","accum","undefined","Array","isArray","isObject","view","edit","animate","_","closeEnum","crc","val","accumCrc","valStr","crcUtil","crc32","Notify","props","classes","useStyles","maxSnack","dense","variantSuccess","NotifyAPI_withSnackBar","children","makeStyles","theme","whiteSpace","variantInfo","variantWarning","variantError","_singleton","NotifyAPI","duration","level","position","modal","actions","levelVariant","anchorOrigin","forEach","action","indx","txt","autoHideDuration","actionsCbMap","reduce","map","identityFn","actionButtons","Button","key","color","size","snackbarKey","enqueueSnackbar","variant","onClick","e","closeSnackbar","clientAction","target","textContent","setTimeout","Fragment","React","Component","success","info","warn","error","vertical","horizontal","p","withSnackbar","notify","directive","display","toastBase","funcQual","toast","alertBase","alert","confirmBase","confirm","displayName","generateActions","root","registerEPkg","actionMeta","traits","ePkgChanged","undoRedoChanged","changeManager","dispatch","requestCache","undoRedoHash","dispatchAction","push","ePkg","_changeManagerAct","getEPkgId","getCrc","getBaseCrc","changeFn","undoFn","targetObj","applyChange","pkgEntryId","registerUndoRedoOp","redoFn","undoRedoMgr","UndoRedoMgr","oldState","undoAvail","isUndoAvail","redoAvail","isRedoAvail","registerOp","newState","isEqual","applyUndo","applyRedo","stack","cur","pop","trickleUpChange","SmartModel","diagClassName","dispMode","cbFn","getEncodingProps","prop","propName","defaultValue","propValue","initialAccum","getCrcRefHandler","handlerCache","noRef","primitiveRef","arrRef","item","plainObjRef","entries","subPropName","subPropValue","smartObjRef","otherObjRef","_crc","encodingPropsReduce","_baseCrc","resetBaseCrcRefHandler","values","resetBaseCrc","old_baseCrc","encodingPropsForEach","baseCrcChanged","containingKonvaContext","oldRef","newRef","selfsClassRef","isPseudoClass","getClassVersionCrc","versionCrcUsedInCreation","outOfSyncHandler","accumOutOfSync","areClassesOutOfSync","isClassOutOfSync","syncClassHandler","syncClassInstances","isMounted","newSelf","smartClone","parent","childRefChanged","viewParent","getParent","getPkg","_pkgEntry","isaPkgEntry","getId","isaView","getViewParent","getView","sizeChanged","getSize","oldSize","sizeCache","width","height","newSize","bindSizeChanges","oldCrc","newCrc","crcChanged","canHandleDispMode","enableViewMode","pkg","canPersist","getName","getPkgName","enableEditMode","enableAnimateMode","toSmartJSONRefHandler","accumJSON","subRefName","subRef","toSmartJSON","myJSON","smartType","getClassName","getClassPkgId","isInstance","pseudoClassMaster","pseudoClassRef","smartClassRef","realClassRef","overridingNamedProps","smartCloneRefHandler","accumClone","clonedProps","accumProps","hasOwnProperty","clonedValue","namedProps","clonedCopy","createSmartObject","smartJSON","extraClassResolver","fromSmartJSON","err","console","log","JSON","stringify","getClassRefFromSmartJSON","subName","SmartPallet","containerSizeFudge","createLogger","_enabled","logger","obj","force","isEnabled","enable","disable","SmartClassRef","realClass","pseudoClassContainer","namedParams","newObj","msgQualifier","getFullClassName","CompRef","compClassRef","compName","comp","x","y","scene","Scene","comps","setParent","containingKonvaStage","mount","konvaPreDestroyed","unmount","memo","useDispatch","activateTab","useFassets","handleActivateTab","tabId","tabName","preview","dualHandleActivateTab","onSingleClick","onDoubleClick","delay","timeoutID","rest","clearTimeout","genDualClickHandler","fassets","inSync","useSelector","appState","sel","isEPkgInSync","shallowEqual","LeftNavCollapsibleItem","TreeView","defaultCollapseIcon","defaultExpandIcon","accumTreeItems","entry","accumulativeId","directoryAccum","dirName","dirContent","TreeItem","nodeId","label","arrItem","smartObj","tabController","TabControllerScene","Collage","errMsg","TabControllerCollage","tabRegistry","registerTab","SmartTreeItem","compRef","markAsPkgEntry","getCompInstance","TabControllerCompRef","genTreeItems","flexGrow","maxWidth","SmartPkg","initializeCatalogs","adornContainedClasses","_entryCatalog","pkgResourcePath","entriesContainCode","_classRefCatalog","pseudoClassMasters","pkgIdBeingResolved","resolvePseudoClassMasters","jsonEntry","resolvedObj","newVal","i","leftNavManager","leftNavCache","processAddLeftNav","addLeftNavItem","PaletteIcon","PaletteIconDefault","useState","open","setOpen","toggleExpansion","useCallback","ListItem","button","ListItemIcon","ListItemText","primary","Collapse","in","timeout","Paper","pallet","margin","spacing","padding","TabController","TabPanelComp","createTabPanelComp","getTabId","otherProps","stageElm","useRef","useEffect","current","style","backgroundColor","border","SmartView","setViewParent","method","konvaStage","draw","containingHtmlElm","Konva","Stage","container","destroy","getTabName","collage","encodingProps","konvaSceneLayer","getChildren","each","konvaComp","n","draggable","off","find","on","konvaObj","oldLoc","newLoc","syncSmartObject","loc","syncKonva","findOne","redo","ancestorOfLayer","node","parentNode","transformer","Transformer","add","attachTo","oldTrans","rotation","scaleX","scaleY","newTrans","trans","Layer","shape","shapeBounds","getClientRect","Math","max","scenes","indexOf","sceneSize","registerPkg","core","replaceAll","str","replace","RegExp","escapeRegExp","SmartComp","containingKonvaLayer","compGroup","Group","Valve1","shape1","Rect","fill","stroke","strokeWidth","connector1","Circle","radius","connector2","subGroup","subCircle","Valve2","shadowBlur","cornerRadius","Valve3","generalCompsPkg","scene1","scene2","scene1Copy","scene2Copy","collage1","konvaSandboxSmartPkg","collages","clonedPkg","json","pkgName","jsonStr","rehydratedSmartPkg","parse","createFeature","enabled","featureFlags","appInit","showStatus","getState","addLeftNav","encode","safeguard","encoding","demarkObjEncoding","demarkSafeguard","window","btoa","obfuscate","decode","result","atob","deobfuscate","substring","a","fetch","resp","ok","status","text","includes","firebaseAppConfig","firebase","initializeApp","toggleUITheme","setResponsiveMode","changeView","removeLeftNavItem","noOp","storeItem","value","deviceStorage","setItem","fetchItem","getItem","_localStorageAvailable","type","storage","removeItem","DOMException","code","storageAvailable","keyName","keyValue","localStorage","uiThemeKey","responsiveModeKey","reducer","slicedReducer","expandWithFassets","combineReducers","uiTheme","reducerHash","_baseUIAct","state","responsiveMode","curView","viewName","leftNavItems","leftNavKey","fn","LeftNavComp","fnRef","gfs","getSlicedState","getUITheme","getResponsiveMode","getOrderedLeftNavItems","createSelector","encodedLeftNavComp","sort","k1","k2","localeCompare","createLogic","String","process","done","LeftNav","orderedLeftNavItems","Drawer","leftNav","paper","leftNavPaper","Toolbar","comment","List","flexShrink","UserMenu","curUser","anchorUserMenu","setAnchorUserMenu","userMenuOpen","useMemo","Boolean","openUserMenu","event","currentTarget","_closeUserMenu","userMenuItems","orderedUserMenuItems","item1Key","item2Key","IconButton","Menu","anchorEl","transformOrigin","onClose","closeUserMenu","fassetsKey","UserMenuItem","openPkg","chooseFileSystemEntries","fileHandle","accepts","description","extensions","mimeTypes","message","getFile","file","fileContent","setPkgResourcePath","savePkg","saveAs","isInSync","content","getPkgResourcePath","createWriter","writer","write","close","DYNAMIC_DEFAULT","discloseError","showUser","logIt","FileMenu","anchorFileMenu","setAnchorFileMenu","fileMenuOpen","openFileMenu","_closeFileMenu","activeTabId","getActiveTabId","isActiveTab","Typography","noWrap","closeFileMenu","MenuItem","handleOpenPkg","handleSavePkg","disabled","resolvePkg","getTabController","getTarget","dispModeChanged","getDispMode","enumKey","_toolBarAct","enumValueOf","title","DispModeTool","_toolBarSel","handleDispModeChange","newDispMode","pkgEntry","tooltipOpen","setTooltipOpen","closeTooltip","Tooltip","Select","labelId","onMouseEnter","onMouseLeave","onMouseDown","onChange","from","dm","UndoRedoTool","AppMotif","viewAuxiliaryContent","get","curViewAuxiliaryContent","matchKey","fallbackViewAuxiliaryContent","resolveCurViewAuxiliaryContent","TitleComp","FooterComp","app","AppBar","appBar","toolbar","disableGutters","menuButton","bottomBar","zIndex","drawer","top","bottom","marginRight","overflow","pkgNameLabel","TransitionZoom","forwardRef","Fade","Slide","direction","Zoom","SplashScreen","isCellPhone","useTheme","useMediaQuery","breakpoints","down","useForCellPhone","SplashScreenCommon","fullScreen","SplashScreenProgrammatic","defaultProps","palette","common","white","main","progress","splashState","setSplashState","_setSplashState","splash","_errLastReported","errCntl","Dialog","TransitionComponent","DialogTitle","DialogContent","src","alt","MainLayout","themeInUse","darkTheme","lightTheme","CssBaseline","createMuiTheme","typography","useNextVariants","fontSize","light","dark","contrastText","secondary","ToggleUITheme","ChipIcon","MoonIcon","SunIcon","Chip","icon","Divider","MaintainResponsiveMode","CheckedIcon","maintainResponsiveMode","defineActions","curResponsiveMode","breakpoint","About","showAbout","define","defineUse","use","required","fassetValidations","any","logic","appWillStart","curRootAppElm","injectDependency","ePkgs","updateCrcs","undoRedo","ePkgId","baseCrc","getUndoRedo","ePkgState","getEPkgState","ratify","closeTab","_tabManagerAct","pgmDirectives","next_activeTabId","previewTabId","next_previewTabId","tabs","newTabs","removeTabId","addNewTab","filter","tab","getPreviewTabId","getTabs","getTotalTabs","transform","next","reject","req_tabId","req_preview","cur_previewTabId","cur_targetTab","closeTabIndx","findIndex","nextTabIndx","nextTabId","setDispMode","TabManager","_tabManagerSel","handleTabChanged","Tabs","indicatorColor","textColor","scrollButtons","tabLabel","Tab","tabPreview","tabPermanent","Grid","justify","stopPropagation","TabCreator","getTabPanelComp","fontStyle","TabPanel","hidden","Box","CenterItems","alignItems","StartUpPage","marginTop","featureRoute","route","lastState","group","curState","groupEnd","location","hostname","match","sandbox","baseUI","tabManager","toolBar","initFirebase","navigator","serviceWorker","ready","then","registration","unregister","logActions","createReducerAspect","createLogicAspect","createRouteAspect","fallbackElm","launchApp","features","aspects","registerRootAppElm","rootAppElm","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.79ceb1f7.chunk.js","sourcesContent":["/**\r\n * Standardize the ability to handle ALL errors more generically, by\r\n * adding these value-added extensions to ALL Error objects (via this\r\n * Error class polyfill - a monkey patch).\r\n * \r\n * All Error instances (created anywhere) are extended to include the\r\n * following characteristics:\r\n * \r\n * - A new error.userMsg property is defined.\r\n * \r\n *   This message is intended to be seen by users, so it should be\r\n *   suitable for human consumption:\r\n *     - both in meaning, \r\n *     - and in sanitation (so as to not reveal any internal\r\n *       architecture)\r\n * \r\n *   By default, error.userMsg = 'Unexpected Condition'\r\n *   and can be changed by: \r\n *     + error.defineUserMsg(userMsg): error\r\n * \r\n * - There is a delineation of expected vs. unexpected conditions.  For\r\n *   example:\r\n * \r\n *     - An error communicating \"invalid password\" is an expected\r\n *       condition, because it is stimulated by user input.\r\n * \r\n *     - Contrast that with an error communicating \"DB is down\", which is\r\n *       an unexpected condition, because this is outside the user's\r\n *       control.\r\n * \r\n *   This distinction is controlled by whether an error.userMsg has\r\n *   been defined (expected) or not (unexpected).\r\n * \r\n *   In other words, all errors start out as unexpected, and can be\r\n *   changed to expected by simply invoking:\r\n *     + error.defineUserMsg(userMsg): error\r\n * \r\n *   This distinction may be programmatically delineated through one of\r\n *   the following methods:\r\n *     + error.isExpected(): boolean\r\n *     + error.isUnexpected(): boolean\r\n * \r\n * - A new error.attemptingToMsg property is defined.\r\n * \r\n *   This message is also intended to be seen by users, and provides\r\n *   additional detail of what was being attempted (over and above the\r\n *   error.userMsg).\r\n * \r\n *   By default, error.attemptingToMsg = ''\r\n *   and can be changed by: \r\n *     + error.defineAttemptingToMsg(attemptingToMsg): error\r\n * \r\n * - A new error.formatUserMsg() is provided that combines all\r\n *   user-specific messages (userMsg and attemptingToMsg).\r\n * \r\n *     + error.formatUserMsg(): string\r\n * \r\n * - The toString() method has been extended to suffix the base\r\n *   toString() with user-specific messages.\r\n * \r\n * - All of the new \"defining\" methods return the receiving error,\r\n *   so as to allow them to be conveniently chained.  For example:\r\n * \r\n *     throw new Error('catastrophic details here').defineAttemptingToMsg('sign in');\r\n * \r\n * **Usage Scenarios** are as follows:\r\n * \r\n * - Error Origination\r\n * \r\n *   In throwing a new Error, you can:\r\n *     throw new Error('internal technical error details')\r\n *                 .defineUserMsg('You did not bla')           // ONLY INVOKE if this is an expected condition - otherwise default to: 'Unexpected Condition'\r\n *                 .defineAttemptingToMsg('log into the app'); // optionally provide additional clarification in either case (expected/unexpected)\r\n * \r\n * - Error Pass Through\r\n * \r\n *   Within a mid-level service, you may capture an error from a lower\r\n *   point and supplement it as follows:\r\n * \r\n *     catch(err) {\r\n *       throw err.defineUserMsg('You did not bla')           // ONLY INVOKE if this is an expected condition - otherwise default to: 'Unexpected Condition'\r\n *                .defineAttemptingToMsg('log into the app'); // optionally provide additional clarification in either case (expected/unexpected)\r\n *     }\r\n * \r\n * - Error Consumption (by client)\r\n * \r\n *   Using these enhancements, the client can abstractly apply various\r\n *   heuristics, such as:\r\n *\r\n *     - if logging is necessary\r\n *       * if so, reveal complete context (internal details and user context)\r\n *     - if user notification necessary\r\n *       * if so supply info suitable for human consumption\r\n * \r\n *   For more usage scenarios, please refer to the discloseError.js utility.\r\n */\r\n\r\n/* eslint-disable no-extend-native */  // we are very careful NOT to break native behavior of the Error object\r\n\r\nif (!Error.prototype.defineUserMsg) { // key off of one of several extension points\r\n\r\n  /**\r\n   * Define a user-specific message, that is applicable for human\r\n   * consumption:\r\n   *  - both in meaning, \r\n   *  - and in sanitization (so as to not reveal any internal architecture).\r\n   *\r\n   * This method also delineates the error as an expected condition.\r\n   *\r\n   * @param {String} userMsg the user message to define\r\n   *\r\n   * @return {Error} self, supporting convenient Error method chaining.\r\n   */\r\n  Error.prototype.defineUserMsg = function(userMsg) {\r\n    this.userMsg  = userMsg;\r\n    this.expected = true;\r\n    return this;\r\n  };\r\n  Error.prototype.userMsg = \"Unexpected Condition\"; // prototype provides the default\r\n\r\n\r\n  /**\r\n   * Return an indicator as to whether this error was\r\n   * expected (say user input error),\r\n   * or not (say a catastrophic error).\r\n   *\r\n   * @return {boolean} error expected (true) or not (false).\r\n   */\r\n  Error.prototype.isExpected = function() {\r\n    return this.expected;\r\n  };\r\n  Error.prototype.expected = false; // prototype provides the default\r\n\r\n\r\n  /**\r\n   * Return an indicator as to whether this error was\r\n   * unexpected (say a catastrophic error),\r\n   * or not (say user input error).\r\n   *\r\n   * @return {boolean} error unexpected (true) or not (false).\r\n   */\r\n  Error.prototype.isUnexpected = function() {\r\n    return !this.expected;\r\n  };\r\n\r\n\r\n  /**\r\n   * Define a user-specific 'attempting to' message, that provides\r\n   * additional details of what was being attempted.\r\n   *\r\n   * Errors with this context are prefixed with ' ... attempting to: ',\r\n   * so word your phrasing appropriately.\r\n   * \r\n   * Multiple attempting-to phrases can be used, which will be\r\n   * combined with the ', -and- ' phrase.\r\n   *\r\n   * @param {String} attemptingToMsg the user-specific attempting\r\n   * to' message.\r\n   *\r\n   * @return {Error} self, supporting convenient Error method chaining.\r\n   */\r\n  Error.prototype.defineAttemptingToMsg = function(attemptingToMsg) {\r\n    if (this.attemptingToMsg) // append multiples\r\n      this.attemptingToMsg += `, -and- ${attemptingToMsg}`;\r\n    else                      // initial definition\r\n      this.attemptingToMsg += ` ... attempting to: ${attemptingToMsg}`;\r\n    return this;\r\n  };\r\n  Error.prototype.attemptingToMsg = ''; // prototype provides the default\r\n\r\n\r\n  /**\r\n   * Format a user-specific message, combining all user-specific contexts.\r\n   *\r\n   * @return {string} formatted user message.\r\n   */\r\n  Error.prototype.formatUserMsg = function() {\r\n    return this.userMsg + this.attemptingToMsg;\r\n  };\r\n\r\n\r\n  /**\r\n   * Extend the Error toString() to prefix user-specific context.\r\n   */\r\n  const prior_toString = Error.prototype.toString; // monkey patch\r\n  Error.prototype.toString = function() {\r\n    return prior_toString.call(this) + '\\n\\nUser Msg: ' + this.formatUserMsg();\r\n  };\r\n\r\n\r\n  // L8TR:\r\n  // /**\r\n  //  * Define an indicator as to the cause of this error ... used to apply\r\n  //  * various heuristics, such as whether logging is necessary.\r\n  //  *\r\n  //  * The following indicators are available:\r\n  //  *   Error.Cause {\r\n  //  *     UNEXPECTED_CONDITION        [default]\r\n  //  *     RECOGNIZED_USER_ERROR\r\n  //  *   }\r\n  //  *\r\n  //  * @param {String} cause one of Error.Cause.\r\n  //  *\r\n  //  * @return {Error} self, supporting convenient Error method chaining.\r\n  //  */\r\n  // Error.prototype.defineCause = function(cause) {\r\n  //   this.cause = cause;\r\n  //   return this;\r\n  // };\r\n  // \r\n  // Error.Cause = {\r\n  //   UNEXPECTED_CONDITION:    'UNEXPECTED_CONDITION',\r\n  //   RECOGNIZED_USER_ERROR: 'RECOGNIZED_USER_ERROR'\r\n  // };\r\n  // \r\n  // Error.prototype.cause = Error.Cause.UNEXPECTED_CONDITION; // prototype provides the default\r\n\r\n}\r\n","/**\r\n * A convenience assertion utility, typically used to validate\r\n * pre-conditions of a routine.\r\n *\r\n * **Advanced**: verify.prefix(msgPrefix) returns a higher-order\r\n *               verify() function where all messages are prefixed.\r\n *\r\n * @param {truthy} condition - a \"truthy\" condition which\r\n * must be satisfied.\r\n *\r\n * @param {string} msg - a message clarifying the condition being\r\n * checked.\r\n * \r\n * @throws {Error} an Error is thrown when the supplied condition is\r\n * NOT met.\r\n */\r\nexport default function verify(condition, msg) {\r\n  if (!condition) {\r\n    // TODO: don't think there is any benefit in logging this console.error \r\n    // console.error(`verify() constraint issue: ${msg}`); // supplement exception with error log (for react-native exposure)\r\n    throw new Error(msg);\r\n  }\r\n}\r\n\r\nverify.prefix = function(msgPrefix) {\r\n  return (condition, msg) => verify(condition, msgPrefix+msg);\r\n};\r\n","import isEqual        from 'lodash.isequal';\r\nimport isFunction     from 'lodash.isfunction';\r\nimport isObject       from 'lodash.isobject';\r\nimport isPlainObject  from 'lodash.isplainobject';\r\nimport isString       from 'lodash.isstring';\r\nimport {isValidElementType} from 'react-is';\r\n\r\n//***\r\n//*** various \"internal\" value-added isA functions\r\n//***\r\n\r\n// isClass(ref): alias to isFunction(ref) ... in JavaScript there is no real distinction between class/function\r\nconst isClass = isFunction;\r\n\r\n// isComponent(ref): is ref a react component?\r\nfunction isComponent(ref) {\r\n  // NOTE: our unit test checks all three forms of Component creation:\r\n  //       - Stateless Functional Component\r\n  //       - Class Component (extending from React.Component)\r\n  //       - Legacy React.createClass()\r\n  return isValidElementType(ref); \r\n}\r\n\r\n// isNumber(ref): is ref a number?\r\nfunction isNumber(ref) {\r\n  return typeof ref === 'number';\r\n}\r\n\r\n// isSmartObject(ref): is ref a SmartObject (a SmartModel derivation)\r\nfunction isSmartObject(ref) {\r\n  return ref && ref.isaSmartObject && ref.isaSmartObject();\r\n}\r\n\r\n// isPkg(ref): is ref a Pkg (SmartPkg)\r\nfunction isPkg(ref) {\r\n  return ref && ref.isaPkg && ref.isaPkg();\r\n}\r\n\r\n// isPkgEntry(ref): is ref a PkgEntry\r\nfunction isPkgEntry(ref) {\r\n  return ref && ref.isaPkgEntry && ref.isaPkgEntry();\r\n}\r\n\r\n// isEPkg(ref): is ref a EPkg\r\nfunction isEPkg(ref) {\r\n  return ref && ref.isaEPkg && ref.isaEPkg();\r\n}\r\n\r\n// isView(ref): is ref a View (SmartView)\r\nfunction isView(ref) {\r\n  return ref && ref.isaView && ref.isaView();\r\n}\r\n\r\n//***\r\n//*** promote our isA utilities\r\n//***\r\n\r\nexport {\r\n  isEqual,       // + isEqual(ref1, ref2):  boolean ... a deep comparison AI: doesn't really belong in typeCheck, but hey\r\n  isFunction,    // + isFunction(ref):      boolean\r\n  isNumber,      // + isNumber(ref):        boolean\r\n  isObject,      // + isObject(ref):        boolean\r\n  isPlainObject, // + isPlainObject(ref):   boolean\r\n  isString,      // + isString(ref):        boolean\r\n  isClass,       // + isClass(ref):         boolean\r\n  isComponent,   // + isComponent(ref):     boolean\r\n  isSmartObject, // + isSmartObject(ref):   boolean\r\n  isPkg,         // + isPkg(ref):           boolean\r\n  isPkgEntry,    // + isPkgEntry(ref):      boolean\r\n  isEPkg,        // + isEPkg(ref):          boolean\r\n  isView,        // + isView(ref):          boolean\r\n};\r\n","/**\r\n * A convenience assertion validation utility that performs checks\r\n * related to \"Unknown Arguments\" of functions accepting \"named\r\n * arguments\".  This logic is encapsulated here because it a\r\n * repetitive requirement by many functions :-)\r\n * \r\n * When any \"Unknown Arguments\" are detected, an exception is thrown\r\n * with a message containing context through the supplied `check`\r\n * parameter.\r\n * \r\n * USAGE: \r\n * ```js\r\n * myFunc({id, name, ...unknownNamedArgs}={}) {\r\n * \r\n *   // validate myFunc() parameters\r\n *   const check = verify.prefix(`myFunct({id:'${id}', name:'${name}'}) parameter violation: `);\r\n *   \r\n *   // ... id\r\n *   check(id,             'id is required');\r\n *   check(isString(id),   'id must be a string');\r\n *   \r\n *   // ... name\r\n *   check(name,           'name is required');\r\n *   check(isString(name), 'name must be a string');\r\n * \r\n *   // ... unknown arguments\r\n *   checkUnknownArgs(check, unknownNamedArgs, arguments);\r\n * }\r\n * ```\r\n *\r\n * @param {verifyFn} check - the verify assertion utility function,\r\n * typically prefixed with `verify.prefix()` to give proper context\r\n * to emitted exceptions.\r\n *\r\n * @param {string[]} unknownNamedArgs - an array of unknown named\r\n * argument named, typically supplied using ES6 \"rest parameters\".\r\n * \r\n * @param {argsObj} args - the implicit `arguments` object\r\n * (accessible within standard JavaScript functions).\r\n * \r\n * @throws {Error} an Error is thrown when any \"Unknown Arguments\" are\r\n * detected.\r\n */\r\nexport default function checkUnknownArgs(check, unknownNamedArgs, args) {\r\n\r\n  // check for any unrecognized named parameters\r\n  const unknownArgKeys = Object.keys(unknownNamedArgs);\r\n  check(unknownArgKeys.length === 0,  `unrecognized named parameter(s): ${unknownArgKeys}`);\r\n\r\n  // check for any unrecognized positional parameter\r\n  // NOTE: when defaulting entire struct, arguments.length is 0\r\n  check(args.length <= 1,  `unrecognized positional parameters (only named parameters can be specified) ... ${args.length} arguments were supplied`);\r\n}\r\n\r\n/*\r\n\r\n?? would be nice to add a check to determine if namedParams is a plain object\r\n\r\n   feature-u check-in comment: adjusted createAspect() namedParam validation to produce more intuitive \"positional param errors\"\r\n   ... see: c:/dev/feature-u/src/extend/createAspect.js\r\n\r\n   1. our utility would accept an additional `namedParams` parameter:\r\n\r\n        + checkUnknownArgs(check, args, namedParams, unknownNamedArgs): void ?? I reordered this too ?? AI rename checkUnknownArgs() TO: checkNamedParams()\r\n\r\n      AND provide this additional check:\r\n\r\n        check(isPlainObject(namedParams), `only named parameters may be supplied`);\r\n\r\n   2. client should accept a single `namedParams` parameter\r\n      and do the destructuring in an executable statement\r\n      RATHER than the function signature.\r\n\r\n      They would also move the checkUnknownArgs() up higher\r\n\r\n      CLIENT EX:\r\n\r\n      ```js\r\n      myFunc(namedParams={}) {\r\n      \r\n        const {id, name, ...unknownNamedArgs} = namedParams;\r\n      \r\n        // ... unknown arguments ?? move this up\r\n        // ... check named params ?? new name\r\n        checkNamedParams(check, arguments, namedParams, unknownNamedArgs); // ?? new signature\r\n      \r\n        // validate myFunc() parameters\r\n        const check = verify.prefix(`myFunct({id:'${id}', name:'${name}'}) parameter violation: `);\r\n        \r\n        // ... id\r\n        check(id,             'id is required');\r\n        check(isString(id),   'id must be a string');\r\n        \r\n        // ... name\r\n        check(name,           'name is required');\r\n        check(isString(name), 'name must be a string');\r\n      }\r\n      ```\r\n\r\n    9: INTERNAL NOTE:\r\n\r\n       I had originally tried to keep the destructuring in the function signature\r\n       AND use JavaScript `arguments[0]` as the namedParams\r\n       HOWEVER this has some BAD QUIRKS:\r\n\r\n       NOTE: arguments is a bit tricky\r\n             - it represents raw client-supplied args\r\n             - WITHOUT default semantics (in signature destructuring)\r\n                                                     arguments.length  arguments[0]  id (via signature destructuring)\r\n                                                     ================  ============  =========\r\n             - EX1: if client supplies NO params:           0            undefined   undefined\r\n             - EX2: if client supplies (123)                1            123         undefined (TRICKY)\r\n             - EX3: if client supplies (new Date())         1            Date        undefined (TRICKY)\r\n             - EX4: if client supplies (123, 456)           2            123         undefined (TRICKY)\r\n                    TRICKY: NOT SURE I fully understand this\r\n\r\n             - SO: placement order of the checks below is critical\r\n                   to get the desired message precedence to user\r\n                   i.e. our ONE required param check IS DONE FIRST\r\n\r\n*/\r\n","import verify      from 'util/verify';\r\nimport {isString,\r\n        isPkg}     from 'util/typeCheck';\r\n\r\n/*-------------------------------------------------------------------------------\r\n   \r\n  ***********************************\r\n  *** Resolve Circular Dependency ***\r\n  ***********************************\r\n\r\n  Do NOT IMPORT SmartPkg\r\n  import SmartPkg from './SmartPkg';\r\n  \r\n  Because SmartPkg extends SmartModel, and SmartModel uses pkgManager,\r\n  this module (pkgManager) cannot rely on SmartPkg!\r\n  \r\n  In other words we cannot import SmartPkg here!\r\n   - Prior to this, openPkg() was a method in PkgManager()\r\n     and we worked around it (a hack) by insuring SmartPkg was expanded FIRST\r\n     ... in src/index.js\r\n         import 'core/SmartPkg'; // \"Resolve Circular Dependency\" by expanding this first\r\n   - This is why we moved openPkg() into a separate module (pkgPersist.js) \r\n     With this refactor, this hack is no longer needed!\r\n\r\n-------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * PkgManager is the manager of ALL packages (SmartPkg)\r\n * loaded and maintained in the visualize-it system.\r\n *\r\n * Entries from one package can have dependencies on other external\r\n * packages (for example, a \"system\" package may contain component\r\n * instances from classes defined in a \"component\" package).\r\n * \r\n * Because the pkgManager service is aware of all packages, it\r\n * provides a clearing house to resolve classRefs, during persistence\r\n * hydration ... see: `SmartModel.fromSmartJSON()`\r\n */\r\nclass PkgManager {\r\n\r\n  /**\r\n   * Create a PkgManager.\r\n   */\r\n  constructor() {\r\n    // carve out our pkgCatalog\r\n    this.pkgCatalog = {\r\n      // [pkgId]: smartPkg,\r\n      // ...\r\n    };\r\n  }\r\n\r\n\r\n  /**\r\n   * Register the supplied package in self.\r\n   *\r\n   * This registration:\r\n   *\r\n   * - makes SmartPkg resources available to low-level processes (for\r\n   *   example, classRefs used in resolving resource-based hydration)\r\n   *   ... see: getClassRef() / getPkgEntry()\r\n   * \r\n   * - is independent of LeftNav visualization (this is accomplished\r\n   *   through `leftNavManager.addLeftNav(smartPkg)`)\r\n   *\r\n   * This registration  occurs automatically when using `openPkg()` (in pkgPersist.js)\r\n   * ... so it could be interpreted as a pseudo private method.\r\n   * \r\n   * - However, non-resource-based packages must register themselves\r\n   *   using this entry point ... for ex:\r\n   *    - code-only packages (as in core offerings)\r\n   *    - unit tests\r\n   *    - etc.\r\n   *   This registration can be accomplished VERY EARLY (e.g. during\r\n   *   code expansion of core classes).\r\n   *\r\n   * @param {SmartPkg} smartPkg - the package to register.\r\n   *\r\n   * @throws {Error} an Error is thrown when the package is already loaded\r\n   */\r\n  registerPkg(smartPkg) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.constructor.unmangledName}.registerPkg() parameter violation: `);\r\n\r\n    // ... smartPkg\r\n    check(smartPkg,         'smartPkg is required');\r\n    check(isPkg(smartPkg),  'smartPkg must be a SmartPkg object');\r\n\r\n    // maintain our package catalog\r\n    const pkgId = smartPkg.getPkgId();\r\n    // console.log(`xx PkgManager.registerPkg() registering smartPkg(${pkgId}): `, smartPkg);\r\n    if (this.pkgCatalog[pkgId]) { // verify smartPkg is not already loaded\r\n      throw new Error(`***ERROR*** ${this.constructor.unmangledName}.registerPkg() pkgId: ${pkgId} is already registered :-(`)\r\n        .defineUserMsg(`The visualize-it '${pkgId}' package is already loaded`); // AI: we may need to conditionally refresh existing packages (per user confirmation)\r\n    }\r\n    this.pkgCatalog[pkgId] = smartPkg;\r\n  }\r\n\r\n  /**\r\n   * Return the package (SmartPkg) registered to the supplied `pkgId`.\r\n   *\r\n   * @param {string} pkgId - the package ID to acquire (ex: 'com.astx.ACME');\r\n   *\r\n   * @returns {SmartPkg} the package (SmartPkg) registered to the supplied\r\n   * `pkgId` (undefined for NOT registered).\r\n   */\r\n  getPkg(pkgId) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix('PkgManager.getPkg() parameter violation: ');\r\n    // ... pkgId\r\n    check(pkgId,             'pkgId is required');\r\n    check(isString(pkgId),   'pkgId must be a string');\r\n\r\n    // return the package (if any)\r\n    return this.pkgCatalog[pkgId];\r\n  }\r\n\r\n  /**\r\n   * Resolve classRefs managed in self's packages.\r\n   *\r\n   * NOTE: This accessor is commonly used in the rehydration process\r\n   *       (SmartModel.fromSmartJSON()) to resolve classes at a low level.\r\n   *\r\n   * @param {string} pkgId - the package id that the class belongs to.\r\n   * @param {string} className - the class name of the classRef to return.\r\n   *\r\n   * @returns {SmartClassRef} the classRef matching the supplied `pkgId`/`className`\r\n   *\r\n   * @throws {Error} an Error is thrown when the class was not resolved.\r\n   */\r\n  getClassRef(pkgId, className) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix('PkgManager.getClassRef() parameter violation: ');\r\n    // ... pkgId\r\n    check(pkgId,             'pkgId is required');\r\n    check(isString(pkgId),   'pkgId must be a string');\r\n    // ... className\r\n    check(className,           'className is required');\r\n    check(isString(className), 'className must be a string');\r\n\r\n    // resolve the package containing the class\r\n    const smartPkg = this.pkgCatalog[pkgId];\r\n    if (!smartPkg) { // this is an expected condition (communicate to user via defineUserMsg())\r\n      throw new Error(`***ERROR*** PkgManager.getClassRef(pkgId:${pkgId}, className:${className}) package is NOT cataloged ... did you forget to load a dependent package?`)\r\n        .defineUserMsg(`The '${pkgId}/${className}' class has been referenced, but the '${pkgId}' package has NOT been loaded ... did you forget to load this dependent package?`);\r\n    }\r\n    \r\n    // resolve the classRef\r\n    const classRef = smartPkg.getClassRef(className);\r\n    if (!classRef) { // this is more of an unexpected condition\r\n      throw new Error(`***ERROR*** PkgManager.getClassRef(pkgId:${pkgId}, className:${className}) class NOT in package :-(`);\r\n    }\r\n    return classRef;\r\n  }\r\n\r\n  /**\r\n   * Resolve entries managed in self's packages.\r\n   *\r\n   * NOTE: This accessor was thought to be used by the tabManager to resolve\r\n   *       entries at a low level, however it is currently not needed.\r\n   *       ... as of 2/16/2020, this method NOT being used.\r\n   *\r\n   * @param {string} pkgId - the package ID that the entry belongs to.\r\n   * @param {string} entryId - the entry ID of the entry to return.\r\n   *\r\n   * @returns {PkgEntry} the entry matching the supplied params,\r\n   * `undefined` for not-found.\r\n   */\r\n  getPkgEntry(pkgId, entryId) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix('PkgManager.getPkgEntry() parameter violation: ');\r\n    // ... pkgId\r\n    check(pkgId,           'pkgId is required');\r\n    check(isString(pkgId), 'pkgId must be a string');\r\n    // ... entryId\r\n    check(entryId,           'entryId is required');\r\n    check(isString(entryId), 'entryId must be a string');\r\n\r\n    // resolve the package containing the entry\r\n    const smartPkg = this.pkgCatalog[pkgId];\r\n    if (!smartPkg) {\r\n      return;\r\n    }\r\n    \r\n    // resolve the entry, if any (when defined in package)\r\n    return smartPkg.getPkgEntry(entryId);\r\n  }\r\n\r\n}\r\nPkgManager.unmangledName = 'PkgManager';\r\n\r\n// expose our single pkgManager utility ... AI: singleton code smell\r\nconst pkgManager = new PkgManager();\r\nexport default pkgManager;\r\n","import verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\nimport {isString,\r\n        isClass}         from 'util/typeCheck';\r\n\r\n/**\r\n * PseudoClass maintains meta data that allows an object instance to\r\n * logically be considered a class (a pseudoClass).\r\n *\r\n * This is used for resource-based objects:\r\n *  - that can be dynamically edited (through the graphical editor)\r\n *  - and yet can be \"instantiated\" as items of other objects!\r\n * This last point is where the resource is taking on the roll of a\r\n * class ... i.e. there are instances of this class in other resources!\r\n *\r\n * Classes whose object instances can take on the roll of a\r\n * pseudoClass should instantiate a `pseudoClass` member of type\r\n * PseudoClass as follows:\r\n *\r\n * ```js\r\n * export default class MyClass extends SmartModel {\r\n *   constructor(...) {\r\n *     ...\r\n *     // make objects of this type pseudoClasses\r\n *     this.pseudoClass = new PseudoClass();\r\n *     ...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * All visualize-it utilities recognize this convention and support it.\r\n * As an example:\r\n *  - `SmartClassRef.createSmartObject(...)` will operate on either a\r\n *    real classes (SmartModel derivations) or pseudoClasses\r\n *\r\n * Objects instances that contain the pseudoClass member can be in one\r\n * of two states:\r\n * \r\n * 1. **MASTER DEFINITION** of the pseudoClass: There is only one\r\n *    object instance of this type, and is what can be dynamically\r\n *    edited.\r\n *\r\n *    **INTERNAL NOTE** In this state:\r\n *     - the `container.pseudoClass.id === 'TYPE'`\r\n *     - the `container.id` will represent the pseudoClass type\r\n *\r\n * 2. **INSTANCE** of the pseudoClass: There can be many instances of\r\n *    the pseudoClass type.\r\n *\r\n *    **INTERNAL NOTE** In this state:\r\n *     - the `container.pseudoClass.id` will reference the pseudoClass type name\r\n *     - the `container.pseudoClass.pseudoClassMaster` will reference the pseudoClassMaster\r\n *\r\n * Currently there are two scenarios where pseudoClasses are used:\r\n *\r\n *  - a `DynamicComp` represents a component that can be edited and\r\n *    maintained in the visualize-it graphical editor.  Many\r\n *    `DynamicComp` master definitions can be created (each with their\r\n *    own pseudoClass type), each which can be instantiated many times\r\n *    in a visualize-it model.\r\n *\r\n *  - a `Scene` represents a graphical perspective that visualizes a\r\n *    system, but each Scene definition can be referenced many times\r\n *    within various `Collages`.\r\n */\r\nexport default class PseudoClass {\r\n\r\n  /**\r\n   * Create a PseudoClass.\r\n   *\r\n   * **IMPORTANT NOTE**: The PseudoClass constructor parameters are\r\n   * strictly used internally!  All client usages should rely on the\r\n   * defaults for these parameters.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} [id='TYPE'] - the type reference for this pseudoClass.\r\n   */\r\n  constructor({id='TYPE', \r\n               name='the MASTER pseudoClass definition of type: ... see container.id',\r\n               ...unknownArgs}={}) {\r\n\r\n    // validate constructor parameters\r\n    const check = verify.prefix('PseudoClass() constructor parameter violation: ');\r\n\r\n    // ... id\r\n    check(id,            'id is required');\r\n    check(isString(id),  'id must be a string');\r\n\r\n    // ... name\r\n    check(name,           'name is required');\r\n    check(isString(name), 'name must be a string');\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // retain parameters in self\r\n    this.id   = id;\r\n    this.name = name || id;\r\n  }\r\n  \r\n  /**\r\n   * Return an indicator as to whether self represents a \"type\",\r\n   * verses an \"instance\" of a type ... the opposite of\r\n   * `isInstance()`.\r\n   * \r\n   * @returns {boolean} `true` if self is a \"type\", false otherwise.\r\n   */\r\n  isType() { return this.id==='TYPE'; }\r\n\r\n  /**\r\n   * Return an indicator as to whether self represents an \"instance\"\r\n   * of a type, verses a \"type\" ... the opposite of `isType()`.\r\n   * \r\n   * @returns {boolean} `true` if self is an \"instance\" of a type,\r\n   * false otherwise.\r\n   */\r\n  isInstance() { return !this.isType(); }\r\n\r\n  /**\r\n   * Return an indicator as to whether the supplied `ref` is a\r\n   * \"logical\" class (i.e. a pseudoClass MASTER) ... an object\r\n   * instance that is logically treated as a class.\r\n   *\r\n   * @param {any} ref - the item to interpret.\r\n   *\r\n   * @returns {boolean} true: `ref` is a \"logical\" class (a\r\n   * pseudoClass MASTER), false: `ref` is something else.\r\n   */\r\n  static isPseudoClassMaster(ref) {\r\n    return ref.pseudoClass && ref.pseudoClass.isType();\r\n  }\r\n\r\n  /**\r\n   * Return the class name of the supplied `clazz` (interpreting BOTH\r\n   * real classes and pseudoClass MASTERS).\r\n   *\r\n   * NOTE: This utility is used when the client is reasoning about a\r\n   *       raw `clazz`, NOT a classRef (SmartClassRef).\r\n   *\r\n   * @param {class | pseudoClassMASTER} clazz - the class to interpret\r\n   * (either a real class or a pseudoClass MASTER).\r\n   *\r\n   * @returns {string} the class name of the supplied `clazz`.\r\n   *\r\n   * @throws {Error} an Error is thrown when the supplied clazz is invalid.\r\n   */\r\n  static getClassName(clazz) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix('PseudoClass.getClassName() parameter violation: ');\r\n    // ... clazz\r\n    check(clazz, 'clazz is required');\r\n\r\n    // interpret a pseudo class MASTER (an object instance that is logically a class)\r\n    if (this.isPseudoClassMaster(clazz)) {\r\n      return clazz.id;\r\n    }\r\n\r\n    // interpret a real class name\r\n    if (isClass(clazz)) {\r\n      return clazz.unmangledName || clazz.name;\r\n    }\r\n    \r\n    // otherwise supplied param is invalid\r\n    else {\r\n      check(false, 'clazz must be a real class or a pseudoClass MASTER');\r\n    }\r\n  }\r\n\r\n}\r\nPseudoClass.unmangledName = 'PseudoClass';\r\n","import {Enumify} from 'enumify';\r\n\r\n/**\r\n * An enumeration designating the various **visualize-it** Display Modes.\r\n */\r\nexport default class DispMode extends Enumify {\r\n  static view     = new DispMode();\r\n  static edit     = new DispMode();\r\n  static animate  = new DispMode();\r\n  static _        = this.closeEnum();\r\n}\r\n","import verify            from 'util/verify';\r\nimport {isObject,\r\n        isPlainObject,\r\n        isSmartObject,\r\n        isFunction,\r\n        isClass}         from 'util/typeCheck';\r\n\r\n/**\r\n * Generate `handleRefFn` with knowledge of how to handle **ALL** data\r\n * types for a given app-specific context.  This is accomplished by\r\n * registering a series of handlers (one for each data type).\r\n *\r\n * This is typically used in a SmartModel traversal, walking through\r\n * all the reference values within a containment tree (with depth).\r\n *\r\n * The API of the generated `handleRefFn` -AND- all app-specific\r\n * `handleXyz` functions are the same:\r\n *\r\n * ```js\r\n * + handleRefFn(ref, accum): accum\r\n * + handleXyz(ref, accum): accum\r\n *     - params:\r\n *       * `ref`:    the reference value to handle/interpret\r\n *       * `accum`:  the current accumulation (when of interest to client)\r\n *     - return: accum - an accumulative amalgamation (when of interest to client)\r\n * ```\r\n *\r\n * The only difference between the two APIs is context of the `ref` parameter:\r\n * - For the generated `handleRefFn`, the `ref` param is of ANY type.  \r\n *   This is the purpose of this generated function - to map the\r\n *   request to application handlers that are type-specific.\r\n * - For the app specific `handleXyz` the `ref` param is guaranteed to\r\n *   be of type `Xyz`.\r\n *\r\n * **Please Note** this function uses named parameters.\r\n * \r\n * @param {function} handleNoRef - a handler of NO ref (null,\r\n * undefined)\r\n * \r\n * @param {function} handlePrimitive - a handler of primitives\r\n * (string, number, etc.).\r\n * \r\n * @param {function} handleArray - a handler of arrays\r\n * \r\n * @param {function} handlePlainObj - a handler of plain objects\r\n * (object literals)\r\n * \r\n * @param {function} handleSmartObj - a handler of SmartObjects\r\n * (class-based object derivations of SmartModel)\r\n * \r\n * @param {function} handleNonSmartObj - a handler of NON\r\n * SmartObjects (not plain and not smart)\r\n * \r\n * @param {function} handleClass - a handler of classes/functions\r\n * \r\n * @returns {function} generated `handleRefFn` (see API in description\r\n * above).\r\n */\r\nexport default function createTypeRefHandler(handlers={}) {\r\n\r\n  // setup/validate the handler object for this context\r\n  // ... registering handlers for ALL data types\r\n  handlers = setupHandlers(handlers);\r\n\r\n  // generate our handleRefFn() for this application context\r\n  function handleRefFn(ref, accum) {\r\n    // handle NO ref (null, undefined)\r\n    if (ref===undefined || ref===null) {\r\n      return handlers.handleNoRef(ref, accum);\r\n    }\r\n    // handle arrays\r\n    else if (Array.isArray(ref)) {\r\n      return handlers.handleArray(ref, accum);\r\n    }\r\n    // handle classes/functions\r\n    else if (isClass(ref)) {\r\n      return handlers.handleClass(ref, accum);\r\n    }\r\n    // handle objects ... various object types (see below)\r\n    else if (isObject(ref)) {\r\n      // handle SmartObjects (class-based object derivations of SmartModel)\r\n      if (isSmartObject(ref)) {\r\n        return handlers.handleSmartObj(ref, accum);\r\n      }\r\n      // handle plain objects\r\n      else if (isPlainObject(ref)) {\r\n        return handlers.handlePlainObj(ref, accum);\r\n      }\r\n      // handle other objects (not plain and not smart)\r\n      else {\r\n        return handlers.handleNonSmartObj(ref, accum);\r\n      }\r\n    }\r\n    // handle primitives (string, number, boolean, etc.)\r\n    else {\r\n      return handlers.handlePrimitive(ref, accum);\r\n    }\r\n  }\r\n\r\n  // expose our generated handleRefFn()\r\n  return handleRefFn;\r\n}\r\n\r\n\r\n//********************************************************************************************\r\n//* internal helper **************************************************************************\r\n//********************************************************************************************\r\n\r\n// setup/validate the handler object for this context\r\n// ... registering handlers for ALL data types\r\nfunction setupHandlers(handlers) {\r\n\r\n  // validate parameters\r\n  const check = verify.prefix('createTypeRefHandler() parameter violation: ');\r\n\r\n  // ... handlers\r\n  check(isPlainObject(handlers), 'only named parameters may be supplied');\r\n\r\n  // ... descturcture/validate the handlers sub-structure\r\n  const {handleNoRef,\r\n         handlePrimitive,\r\n         handleArray,\r\n         handlePlainObj,\r\n         handleSmartObj,\r\n         handleNonSmartObj,\r\n         handleClass,\r\n         ...unknownNamedArgs} = handlers;\r\n\r\n  // ... handleNoRef\r\n  check(handleNoRef,                   'handleNoRef is required');\r\n  check(isFunction(handleNoRef),       'handleNoRef must be a function');\r\n\r\n  // ... handlePrimitive\r\n  check(handlePrimitive,               'handlePrimitive is required');\r\n  check(isFunction(handlePrimitive),   'handlePrimitive must be a function');\r\n\r\n  // ... handleArray\r\n  check(handleArray,                   'handleArray is required');\r\n  check(isFunction(handleArray),       'handleArray must be a function');\r\n\r\n  // ... handlePlainObj\r\n  check(handlePlainObj,                'handlePlainObj is required');\r\n  check(isFunction(handlePlainObj),    'handlePlainObj must be a function');\r\n\r\n  // ... handleSmartObj\r\n  check(handleSmartObj,                'handleSmartObj is required');\r\n  check(isFunction(handleSmartObj),    'handleSmartObj must be a function');\r\n\r\n  // ... handleNonSmartObj\r\n  check(handleNonSmartObj,             'handleNonSmartObj is required');\r\n  check(isFunction(handleNonSmartObj), 'handleNonSmartObj must be a function');\r\n\r\n  // ... handleClass\r\n  check(handleClass,                   'handleClass is required');\r\n  check(isFunction(handleClass),       'handleClass must be a function');\r\n\r\n  // ... unrecognized named parameter\r\n  const unknownArgKeys = Object.keys(unknownNamedArgs);\r\n  check(unknownArgKeys.length === 0,  `unrecognized named parameter(s): ${unknownArgKeys}`);\r\n\r\n  // ... unrecognized positional parameter\r\n  //     NOTE: when defaulting entire struct, arguments.length is 0\r\n  check(arguments.length <= 1, `unrecognized positional parameters (only named parameters may be specified) ... ${arguments.length} positional parameters were found`);\r\n\r\n  // reconstitute/return our value-added handlers\r\n  return {\r\n    handleNoRef,\r\n    handlePrimitive,\r\n    handleArray,\r\n    handlePlainObj,\r\n    handleSmartObj,\r\n    handleNonSmartObj,\r\n    handleClass,\r\n  };\r\n\r\n}\r\n","import crcUtil from 'crc';       // usage: crcUtil.crc32(valStr, accumCrc) ... below\r\n//import crc32 from 'crc/crc32'; // usage: crc32(valStr, accumCrc)         ... below\r\n\r\n// NOTE: Would prefer 2nd import option (above)\r\n//       BECAUSE: It only imports the crc32 code (NOT bloating our bundle size)\r\n//       HOWEVER: It generates a \"SyntaxError: Unexpected token {\" in our jest test usage\r\n//       SUSPECT: This may be related to how my project config uses 'src/' as our import root\r\n//       FIX:     I punted for now.\r\n//                ONE \"last resort\" option would be to locally include code from crc pkg\r\n//                ... see journal.txt for details\r\n\r\n/**\r\n * Generate a crc value from the supplied parameters.\r\n *\r\n * @param {any} val - the value to include in the crc.  Supports:\r\n *  - any primitive type (string, number, boolean)\r\n *  - array of primitive types\r\n *  - any object with a toString() representative of the object state\r\n *  - undefined/null\r\n *  WARNING:\r\n *  - all other cases will generate a non-unique crc\r\n *\r\n * @param {number} [accumCrc] - an optional crc value, used when\r\n * accumulating additional items in your crc computation.\r\n *\r\n * @return {number} the generated crc value.\r\n */\r\nexport default function crc(val, accumCrc=0) {\r\n  // convert val to string\r\n  const valStr = '' + val;\r\n  // console.log(`xx val: ${val}, valStr: ${valStr}`);\r\n\r\n  return crcUtil.crc32(valStr, accumCrc);\r\n//return crc32(valStr, accumCrc);\r\n}\r\n","import React              from 'react';\r\nimport verify             from 'util/verify';\r\nimport checkUnknownArgs   from 'util/checkUnknownArgs';\r\nimport {SnackbarProvider,\r\n        withSnackbar}     from 'notistack';\r\nimport {makeStyles}       from '@material-ui/core/styles';\r\nimport Button             from \"@material-ui/core/Button\";\r\nimport {isString,\r\n        isFunction}       from 'util/typeCheck';\r\n\r\n/* eslint-disable react/jsx-pascal-case */  // for: <NotifyAPI_withSnackBar>\r\n\r\n/**\r\n * The Notify component provides user notifications through a visual\r\n * message dialog.\r\n *\r\n * User messages are initiated through a programmatic invocation,\r\n * using the functional notify() API.  Supplied directives support\r\n * a variety of scenarios, including:\r\n *   - action buttons (for acknowledgment, or confirmation, etc.)\r\n *   - timed closure of the message\r\n *   - msg levels of success, info, warn, error (impacting the dialog style/color)\r\n *   - modal and non-modal\r\n *\r\n * Notify is the fundamental component which is the basis of various\r\n * UI notifications (i.e. Toasts, Alerts, Confirmations, etc.).  It\r\n * can be used stand-alone, or indirectly through various wrappers\r\n * (promoted through named exports).  The following functions are\r\n * summarized as follows:\r\n *\r\n * ```\r\n *                                                                 auto-close         variant-color      screen           ??TODO client\r\n *                 params:                         msg             duration           level              position         modal  actions\r\n *                 ============================    ==============  =================  =================  ===============  =====  ==========================\r\n *   - notify .... ({msg,                          msg to display  1-20 seconds       'success': green   'top-left'       false  [ {txt, [action]}, ... ]\r\n *                   duration=5,                   ... supports    null: close        'info':    blue    'top-center'     true   - where action: () => void\r\n *                   level='success',                  cr/lf             via          'warn':    yellow  'top-right'             - actions ARE OPTIONAL\r\n *                   position='bottom-left',                             client       'error':   red     'bottom-left'           - ALL actions auto close\r\n *                   modal=false,                                        action                          'bottom-center'  \r\n *                   actions=[]})                                        DEFAULT: OK                     'bottom-right'\r\n *                   \r\n *   - toast ..... ({msg, duration=5, actions})                    ditto              via toast.xyz()    'bottom-left'    false  ditto\r\n *   - alert ..... ({msg, actions})                                null               via alert.xyz()    'top-center'     true   ditto\r\n *   - confirm ... ({msg, actions})                                null               via confirm.xyz()  'top-right'      true   requires client action(s)\r\n * ```\r\n *\r\n * **Setup**:\r\n *\r\n *   The Notify component is tightly controlled as a single instance\r\n *   within an entire app.  Therefore, one and only one Notify\r\n *   instance must be pre-instantiated (initially hidden) somewhere at\r\n *   the top-level of your app.\r\n *\r\n *     ```\r\n *       <React.Fragment>\r\n *         <Notify/>\r\n *         {app content}\r\n *       </React.Fragment>\r\n\r\n *       -or-\r\n *       <Notify>\r\n *         {app content}\r\n *       <Notify>\r\n *     ```\r\n * \r\n * **Usage**:\r\n * \r\n *   see docs below: `notify()`, `toast()`, `alert()`, `confirm()`\r\n * \r\n * **Module Note**:\r\n *\r\n *   This utility is housed in a lower-case `notify.js` module,\r\n *   because the general public API is a series of lower-case \"named\r\n *   exported\" functions: `notify()`, `toast()`, `alert()`,\r\n *   `confirm()`.\r\n * \r\n *   There is a \"default exported\" Notify component (which is somewhat\r\n *   unusual to find in a lower-case module), but is only used once at\r\n *   app startup, so is therefore justified (in this case).\r\n */\r\n\r\n//***\r\n//*** the top-level Notify component conveniently auto-injects the notistack <SnackbarProvider>\r\n//*** (required for our programmatic interface)\r\n//***\r\n\r\nexport default function Notify(props) {\r\n\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <SnackbarProvider maxSnack={3} dense={true} className={classes.variantSuccess}>\r\n      <NotifyAPI_withSnackBar>\r\n        {props.children}\r\n      </NotifyAPI_withSnackBar>\r\n    </SnackbarProvider>\r\n  );\r\n}\r\n\r\n// apply snackbar variant style changes in support cr/lf\r\n// ... via: whiteSpace of 'pre-line'\r\n// ... this honors cr/lf within our snackbar items\r\nconst useStyles = makeStyles( theme => ({\r\n  variantSuccess: {\r\n    whiteSpace: 'pre-line',\r\n  },\r\n  variantInfo: {\r\n    whiteSpace: 'pre-line',\r\n  },\r\n  variantWarning: {\r\n    whiteSpace: 'pre-line',\r\n  },\r\n  variantError: {\r\n    whiteSpace: 'pre-line',\r\n  },\r\n}) );\r\n\r\n\r\n//***\r\n//*** keep track of our one-and-only instance\r\n//***\r\n\r\nlet _singleton = null;\r\n\r\n\r\n//***\r\n//*** the NotifyAPI component provides our internal programmatic API\r\n//*** (see .display()), used by notify(), toast(), etc.\r\n//***\r\n\r\nclass NotifyAPI extends React.Component {\r\n\r\n  static propTypes = { // expected component props\r\n  }\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    // keep track of our one-and-only instance\r\n    verify(!_singleton, '<Notify> only ONE Notify instance should be instantiated in the app (at the top-level).');\r\n    _singleton = this;\r\n  }\r\n\r\n  // display() is the interface point to our programmatic API (notify(), toast(), etc.)\r\n  display({msg,\r\n           duration=5, // auto close duration in seconds ... DEFAULT: 5 ... use null - manual close (via actions [default to OK])\r\n           level='success',\r\n           position='bottom-left',\r\n           modal=false,\r\n           actions=[],\r\n           ...unknownArgs}={}) {\r\n\r\n    // validate the named parameters (i.e. the directive)\r\n    const check = verify.prefix('notify() parameter violation: '); // NOTE: we pretend we are: notify() (the public access point)\r\n\r\n    // ... msg\r\n    check(msg, 'directive.msg is required');\r\n    check(isString(msg),  'msg must be a string');\r\n\r\n    // ... duration\r\n    if (duration !== null) {\r\n      check(duration >= 1 && duration <= 20, `supplied duration (${duration}) must be a number between 1 and 20 (inclusive).`);\r\n    }\r\n\r\n    // ... level\r\n    check(levelVariant[level], `invalid level: '${level}', expecting one of ${Object.keys(levelVariant)}.`);\r\n\r\n    // ... position\r\n    check(anchorOrigin[position], `invalid position: '${position}', expecting one of ${Object.keys(anchorOrigin)}.`);\r\n\r\n    // ... modal\r\n    check(modal===true || modal===false, `supplied modal (${modal}) must be a boolean true/false.`);\r\n\r\n    // ... actions\r\n    check(actions,                'actions must be an Action[] array'); // defaulted to [] ... this is user error of like null or something\r\n    check(Array.isArray(actions), 'actions must be an Action[] array');\r\n    actions.forEach( (action, indx) => {\r\n      check(action.txt,           `action[${indx}].txt is required`);\r\n      check(isString(action.txt), `action[${indx}].txt be a string ... NOT: ${action.txt}`);\r\n      if (action.action) {\r\n        check(isFunction(action.action), `action[${indx}].action (when supplied) must be a function ... NOT: ${action.action}`);\r\n      }\r\n    });\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // maintain our display duration\r\n    const autoHideDuration = duration ? duration*1000 : null; // convert to seconds ... null indicates manual close (via actions [default to OK])\r\n\r\n    // interpret any client-supplied actions\r\n\r\n    // ... provide a default OK when NO duration and NO actions are defined\r\n    //     NOTE: When NO duration is supplied, only way to close notification is through an action!\r\n    //           If client has NO actions, we will supply one (a default OK)\r\n    if (!duration && actions.length===0) {\r\n      actions = [{txt: 'OK'}]; // do NOT mutate client-supplied actions\r\n    }\r\n\r\n    // ... maintain a actions callback map indexed by .txt (default to identityFn)\r\n    const actionsCbMap = actions.reduce( (map, action) => {\r\n      map[action.txt] = action.action || identityFn;\r\n      return map;\r\n    }, {} );\r\n    // ... define our actionButtons (supplied to enqueueSnackbar) ... empty array is ignored\r\n    const actionButtons = actions.map( (action, indx) => <Button key={indx} color=\"default\" size=\"small\">{action.txt}</Button> );\r\n\r\n\r\n    // KEY: display the notification ... using notistack's enqueueSnackbar(...)\r\n    const snackbarKey = this.props.enqueueSnackbar(msg, {\r\n      variant: levelVariant[level],\r\n      autoHideDuration,\r\n      anchorOrigin: anchorOrigin[position],\r\n      action: actionButtons,\r\n      onClick: (e) => {\r\n        // close this notification\r\n        this.props.closeSnackbar(snackbarKey);\r\n\r\n        // invoke client-supplied callback\r\n        // ... on delay to make any client-notification transitions more intuitive\r\n        const clientAction = actionsCbMap[e.target.textContent];\r\n        setTimeout( () => clientAction(), 400);\r\n      },\r\n    });\r\n\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        {this.props.children}\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\n// our level variant (indirectly defines color -and- provides level validation)\r\nconst levelVariant = { // color NOT used\r\n  success: 'success',\r\n  info:    'info',\r\n  warn:    'warning',\r\n  error:   'error',\r\n};\r\n\r\n// our anchorOrigin, indexed by position keyword\r\nconst anchorOrigin = {\r\n  'top-left':      { vertical: 'top',    horizontal: 'left'   },\r\n  'top-center':    { vertical: 'top',    horizontal: 'center' },\r\n  'top-right':     { vertical: 'top',    horizontal: 'right'  },\r\n  'bottom-left':   { vertical: 'bottom', horizontal: 'left'   },\r\n  'bottom-center': { vertical: 'bottom', horizontal: 'center' },\r\n  'bottom-right':  { vertical: 'bottom', horizontal: 'right'  },\r\n};\r\n\r\n// a convenient identity function\r\nconst identityFn = (p)=>p;\r\n\r\n\r\n//***\r\n//*** the withSnackbar() HOC provides access to the Snackbar run-time methods:\r\n//***   + props.enqueueSnackbar(...)\r\n//***   + props.closeSnackbar(...)\r\n//*** \r\n\r\nconst NotifyAPI_withSnackBar = withSnackbar(NotifyAPI);\r\nNotifyAPI_withSnackBar.displayName = 'NotifyAPI_withSnackBar'; // ... for react debugging (NOT accomplished in withSnackbar() ... grrrrr)\r\n\r\n\r\n\r\n/**\r\n * Display a user notification - the general purpose access point,\r\n * using named directives.\r\n *\r\n * @param {string} directive.msg the message to be displayed (cr/lf\r\n * are supported).\r\n *\r\n * @param {number} [directive.duration] the number of seconds to\r\n * display the msg before automatically closing the dialog.  If not\r\n * supplied, the dialog must be explicitly closed through a button\r\n * click.\r\n *\r\n * @param {string} [directive.level] the category level associated\r\n * with this notification (impacting background color).  One of:\r\n *  - 'success' ... the default\r\n *  - 'info'\r\n *  - 'warn'\r\n *  - 'error'\r\n *\r\n * @param {string} [directive.position] the position to display this\r\n * notification. One of:\r\n *  - 'top-left'\r\n *  - 'top-center'\r\n *  - 'top-right'\r\n *  - 'bottom-left' ... the default\r\n *  - 'bottom-center'\r\n *  - 'bottom-right'\r\n *\r\n * @param {boolean} [directive.modal] an indicator as to whether the\r\n * notification dialog is modal (true) or not (false) the default.\r\n *\r\n * @param {Action[]} [directive.actions] one or more actions -\r\n * button/action combinations.  The required Action.txt defines the\r\n * button label, and the Action.action is an option client-supplied\r\n * callback.  Each defined action will implicitly close the dialog,\r\n * in addition to invoking the optional client-supplied callback.\r\n *\r\n * NOTE: When NO duration and NO actions are defined, a default OK \r\n *       action is injected that will close the dialog when clicked.\r\n *\r\n * Example:\r\n * ```\r\n *   notify({\r\n *     msg:      'You have un-saved changes.\\nif you leave, your changes will NOT be saved!',\r\n *     duration: seconds,\r\n *     level:    'warn',\r\n *     position: 'bottom-right',\r\n *     modal:    true,\r\n *     actions: [\r\n *       { txt: 'Discard Changes', action: () => ...callback-logic-here... },\r\n *       { txt: 'Go Back' }\r\n *     ]\r\n *   });\r\n * ```\r\n */\r\nexport function notify(directive) {\r\n  // validate that an <Notify> has been instantiated\r\n  verify(_singleton, 'notify(): NO <Notify> instance has been established in the app root.');\r\n\r\n  // pass-through to our instance method\r\n  _singleton.display(directive);\r\n}\r\n\r\n\r\n/**\r\n * The toast() function is a convenience wrapper around notify() that\r\n * displays the supplied msg as a \"toast\" ... a non-modal dialog\r\n * located at the bottom-left of the screen, which is typically closed\r\n * after 5 seconds.\r\n *\r\n * Various levels can be accomplished via toast.success(),\r\n * toast.info(), toast.warn(), toast.error() ... all of which have the\r\n * same signature.  NOTE: toast() is the same as toast.success().\r\n *\r\n * @param {string} directive.msg the message to be displayed (cr/lf are\r\n * supported).\r\n *\r\n * @param {number} [directive.duration] the number of seconds before\r\n * automatically closing the dialog (default: 5).  A null defers to\r\n * supplied actions to close (which in turn defaults to an OK).\r\n *\r\n * @param {Action[]} [directive.actions] one or more actions -\r\n * button/action combinations.  The required Action.txt defines the\r\n * button label, and the Action.action is an option client-supplied\r\n * callback.  Each defined action will implicitly close the dialog,\r\n * in addition to invoking the optional client-supplied callback.\r\n *\r\n * NOTE: When NO duration and NO actions are defined, a default OK \r\n *       action is injected that will close the dialog when clicked.\r\n *\r\n * Example:\r\n * ```\r\n *\r\n *   toast({ msg:'Hello World' });    // will close in 6 secs\r\n *\r\n *   toast.error({ msg:     `An error occurred: ${err}`, \r\n *                 duration: null }); // OK button will close\r\n *\r\n *   toast.warn({                     // will close in 3 secs -OR- when \"undo\" is clicked\r\n *     msg: 'Your item was deleted', \r\n *     actions: [\r\n *       { txt: 'undo', action: () => ...callback-logic-here... },\r\n *     ]\r\n *    })\r\n * ```\r\n */\r\nfunction toastBase({msg, duration=5, actions, ...unknownArgs}, level) {\r\n\r\n  // validate toast-specific characteristics (other validation done by notify())\r\n  const funcQual = level ? `.${level}` : '';\r\n  const check    = verify.prefix(`toast${funcQual}() parameter violation: `);\r\n\r\n  // NOTE: as a general rule, validations are provided by the root notify()\r\n  // checking msg explicitly avoids unknownArgKeys weirdness (below) when msg is passed as a non-named param\r\n  check(msg, 'msg named parameter is required');\r\n\r\n  const unknownArgKeys = Object.keys(unknownArgs);\r\n  check(unknownArgKeys.length===0,  `unrecognized named parameter(s): ${unknownArgKeys}`);\r\n\r\n  // defer to our general-purpose notify() utility\r\n  notify({\r\n    msg,\r\n    duration,\r\n    level,    // NOTE: level is defaulted by the root notify()\r\n    position: 'bottom-left',\r\n    modal: false,\r\n    actions,\r\n  });\r\n}\r\nexport function  toast(directive) { toastBase(directive);          }\r\ntoast.success  = function(directive) { toastBase(directive, 'success'); }\r\ntoast.info     = function(directive) { toastBase(directive, 'info');    }\r\ntoast.warn     = function(directive) { toastBase(directive, 'warn');    }\r\ntoast.error    = function(directive) { toastBase(directive, 'error');   }\r\n\r\n\r\n/**\r\n * The alert() function is a convenience wrapper around notify() that\r\n * displays the supplied msg as a \"alert\" ... a modal dialog located\r\n * at the top-center of the screen, that must be acknowledged by the\r\n * user with either the default OK button, or a client-supplied\r\n * action.\r\n *\r\n * Various levels can be accomplished via alert.success(),\r\n * alert.info(), alert.warn(), alert.error() ... all of which have the\r\n * same signature.  NOTE: alert() is the same as alert.success().\r\n *\r\n * @param {string} directive.msg the message to be displayed (cr/lf\r\n * are supported).\r\n *\r\n * @param {Action[]} [directive.actions] one or more actions -\r\n * button/action combinations.  The required Action.txt defines the\r\n * button label, and the Action.action is an option client-supplied\r\n * callback.  Each defined action will implicitly close the dialog,\r\n * in addition to invoking the optional client-supplied callback.\r\n *\r\n * NOTE: When NO actions are defined, a default OK  action is injected\r\n *       that will close the dialog when clicked.\r\n *\r\n * Example:\r\n * ```\r\n *   alert({ msg:'Hello World' });\r\n *   alert.warn({\r\n *     msg:`Your limit (${limit}) has been reached!`\r\n *     actions: [\r\n *       { txt: 'increase', action: () => ...callback-logic-here... },\r\n *     ]\r\n *   });\r\n * ```\r\n */\r\nfunction alertBase({msg, actions, ...unknownArgs}, level) {\r\n\r\n  // validate alert-specific characteristics (other validation done by notify())\r\n  const funcQual = level ? `.${level}` : '';\r\n  const check    = verify.prefix(`alert${funcQual}() parameter violation: `);\r\n\r\n  // NOTE: as a general rule, validations are provided by the root notify()\r\n  // checking msg explicitly avoids unknownArgKeys weirdness (below) when msg is passed as a non-named param\r\n  check(msg, 'msg named parameter is required');\r\n\r\n  const unknownArgKeys = Object.keys(unknownArgs);\r\n  check(unknownArgKeys.length===0,  `unrecognized named parameter(s): ${unknownArgKeys}`);\r\n\r\n  // defer to our general-purpose notify() utility\r\n  notify({\r\n    msg,\r\n    duration: null, // force user acknowledgment\r\n    level,          // NOTE: level is defaulted by the root notify()\r\n    position: 'top-center',\r\n    modal: true,\r\n    actions,\r\n  });\r\n}\r\nexport function  alert(directive) { alertBase(directive);          }\r\nalert.success  = function(directive) { alertBase(directive, 'success'); }\r\nalert.info     = function(directive) { alertBase(directive, 'info');    }\r\nalert.warn     = function(directive) { alertBase(directive, 'warn');    }\r\nalert.error    = function(directive) { alertBase(directive, 'error');   }\r\n\r\n\r\n/**\r\n * The confirm() function is a convenience wrapper around notify()\r\n * that displays the supplied msg as a \"confirmation\" ... a modal\r\n * dialog located at the bottom-right of the screen, that must be\r\n * acknowledged through client-supplied action buttons.\r\n *\r\n * Various levels can be accomplished via confirm.success(),\r\n * confirm.info(), confirm.warn(), confirm.error() ... all of which\r\n * have the same signature.  NOTE: confirm() is the same as\r\n * confirm.success().\r\n *\r\n * @param {string} directive.msg the message to be displayed (cr/lf\r\n * are supported).\r\n *\r\n * @param {Action[]} directive.actions one or more actions - button/action\r\n * combinations.  The required Action.txt defines the button label,\r\n * and the Action.action is an option client-supplied callback.  Each\r\n * defined action will implicitly close the dialog, in addition to\r\n * invoking the optional client-supplied callback.\r\n *\r\n * Example:\r\n * ```\r\n *   confirm.warn({ \r\n *     msg: 'This is an confirm warning.\\nYou must explicitly acknowledge it.', \r\n *     actions: [\r\n *       { txt: 'Discard Changes', action: () => console.log('xx Discarding Changes') },\r\n *       { txt: 'Go Back' }\r\n *     ]\r\n *   });\r\n * ```\r\n */\r\nfunction confirmBase({msg, actions, ...unknownArgs}, level) {\r\n\r\n  // validate confirm-specific characteristics (other validation done by notify())\r\n  const funcQual = level ? `.${level}` : '';\r\n  const check    = verify.prefix(`confirm${funcQual}() parameter violation: `);\r\n\r\n  // NOTE: as a general rule, validations are provided by the root notify()\r\n  // checking msg explicitly avoids unknownArgKeys weirdness (below) when msg is passed as a non-named param\r\n  check(msg, 'msg named parameter is required');\r\n\r\n  // confirm() requires client-supplied actions\r\n  check(actions && actions.length>0, 'client-specific actions are required.');\r\n\r\n  const unknownArgKeys = Object.keys(unknownArgs);\r\n  check(unknownArgKeys.length===0,  `unrecognized named parameter(s): ${unknownArgKeys}`);\r\n\r\n  // defer to our general-purpose notify() utility\r\n  notify({\r\n    msg,\r\n    duration: null, // force user acknowledgment\r\n    level,          // NOTE: level is defaulted by the root notify()\r\n    position: 'top-right',\r\n    modal: true,\r\n    actions,\r\n  });\r\n}\r\nexport function  confirm(directive) { confirmBase(directive);          }\r\nconfirm.success  = function(directive) { confirmBase(directive, 'success'); }\r\nconfirm.info     = function(directive) { confirmBase(directive, 'info');    }\r\nconfirm.warn     = function(directive) { confirmBase(directive, 'warn');    }\r\nconfirm.error    = function(directive) { confirmBase(directive, 'error');   }\r\n","import {generateActions}  from 'action-u';\r\nimport _changeManager     from './featureName';\r\n\r\nexport default generateActions.root({\r\n  [_changeManager]: { // prefix all actions with our feature name, guaranteeing they unique app-wide!\r\n\r\n    registerEPkg: { // actions.registerEPkg(ePkgId, crc, baseCrc): Action\r\n                    // > registers the supplied ePkg to our state management\r\n                    actionMeta: {\r\n                      traits: ['ePkgId', 'crc', 'baseCrc'],\r\n                    },\r\n    },\r\n\r\n    ePkgChanged:  { // actions.ePkgChanged(ePkgId, crc, baseCrc): Action\r\n                    // > the supplied ePkg has changed\r\n                    actionMeta: {\r\n                      traits: ['ePkgId', 'crc', 'baseCrc'],\r\n                    },\r\n    },\r\n\r\n    undoRedoChanged:  { // actions.undoRedoChanged(pkgEntryId, undoAvail, redoAvail): Action\r\n                        // > the supplied PkgEntry's undo/redu availability has changed\r\n                        actionMeta: {\r\n                          traits: ['pkgEntryId', 'undoAvail', 'redoAvail'],\r\n                        },\r\n    },\r\n\r\n  },\r\n\r\n});\r\n","/**\r\n * Expose our featureName through a mini-meta module that is\r\n * \"importable\" in all use-cases (a single-source-of-truth).\r\n */\r\nexport default 'changeManager';\r\n","import _changeManagerAct  from './actions';\r\nimport verify             from 'util/verify';\r\nimport checkUnknownArgs   from 'util/checkUnknownArgs';\r\nimport {isString,\r\n        isFunction,\r\n        isSmartObject,\r\n        isEPkg,\r\n        isEqual}          from 'util/typeCheck';\r\n\r\n/**\r\n * ChangeManager is a service that manages change throughout the system.\r\n */\r\nclass ChangeManager {\r\n\r\n  /**\r\n   * Create a ChangeManager.\r\n   */\r\n  constructor() {\r\n    // carve out our state\r\n    // ... injected by: changeManager feature.appInit()\r\n    this.dispatch = null;\r\n    this.requestCache = []; // actions\r\n    this.undoRedoHash = {}; // hash of ... [pkgEntryId]: UndoRedoMgr\r\n  }\r\n\r\n  /**\r\n   * Internal method that injects operational dependencies into self.\r\n   *\r\n   * This is invoked early in the startup process by changeManager\r\n   * feature.appInit().\r\n   *\r\n   * @private\r\n   */\r\n  injectDependency(dispatch) {\r\n    // retain operational dependencies\r\n    this.dispatch = dispatch;\r\n\r\n    // process any cached entries\r\n    this.requestCache.forEach( (action) => this.dispatchAction(action) );\r\n    this.requestCache = []; // clear the cache\r\n  }\r\n\r\n  /**\r\n   * Internal method that will dispatch (or cache) the supplied action.\r\n   *\r\n   * NOTE: A cache is maintained, that holds actions to be processed,\r\n   *       when this service is not yet operational (see:\r\n   *       injectDependency()).  This minimizes order dependencies.\r\n   *\r\n   * @private\r\n   */\r\n  dispatchAction(action) {\r\n    // cache request (when self it not yet operational)\r\n    if (!this.dispatch) {\r\n      this.requestCache.push(action);\r\n    }\r\n    // process request (when self is operational)\r\n    else {\r\n      this.dispatch(action);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register the supplied `ePkg` to our changeManager.\r\n   *\r\n   * @param {EPkg} ePkg - the EPkg smartObject to register.\r\n   */\r\n  registerEPkg(ePkg) {\r\n    // validate parameters\r\n    const check = verify.prefix('changeManager.registerEPkg() parameter violation: ');\r\n    // ... ePkg\r\n    check(ePkg,          'ePkg is required');\r\n    check(isEPkg(ePkg),  'ePkg must be an EPkg smartObject');\r\n\r\n    // process request\r\n    // ... dispatch action that will maintain this new state\r\n    this.dispatchAction( _changeManagerAct.registerEPkg(ePkg.getEPkgId(), ePkg.getCrc(), ePkg.getBaseCrc()) );\r\n  }\r\n\r\n  /**\r\n   * The supplied ePkg has changed.\r\n   *\r\n   * @param {EPkg} ePkg - the EPkg smartObject that has changed.\r\n   */\r\n  ePkgChanged(ePkg) {\r\n    // validate parameters\r\n    const check = verify.prefix('changeManager.ePkgChanged() parameter violation: ');\r\n    // ... ePkg\r\n    check(ePkg,          'ePkg is required');\r\n    check(isEPkg(ePkg),  'ePkg must be an EPkg smartObject');\r\n\r\n    // process request\r\n    // ... dispatch action that will maintain this changed state\r\n    this.dispatchAction( _changeManagerAct.ePkgChanged(ePkg.getEPkgId(), ePkg.getCrc(), ePkg.getBaseCrc()) );\r\n  }\r\n\r\n  /**\r\n   * Apply the supplied change to our system -AND- register the change\r\n   * to our undo/redo operation stack (associated to a given PkgEntry).\r\n   * \r\n   * - Changes are registered to a given PkgEntry (identified through the\r\n   *   return of changeFn/ undoFn).\r\n   *\r\n   * - Changes are modeled as functions to be executed.  The API of\r\n   *   `changeFn()` / `undoFn()` is as follows:\r\n   *   \r\n   *   ```js\r\n   *   + changeFn(redo: <boolean>): targetObj\r\n   *   + undoFn(): targetObj\r\n   *   ```\r\n   * \r\n   * - The `redo` param is an indicator as to whether the invocation\r\n   *   is a **redo** operation, verses the initial execution.\r\n   *   Typically a redo requires more work (for example syncing\r\n   *   **both** the SmartObject and Konva realms).\r\n   * \r\n   * - Both functions return the targetObj of the operation.  This is\r\n   *   used to seed the synchronization of other parts of the model\r\n   *   ... via the `SmartModel.trickleUpChange()` method.\r\n   * \r\n   * - These change functions should be implemented in a way that DOES NOT\r\n   *   reference stale objects!\r\n   *   - when using undo/redo (over the course of time) objects may be\r\n   *     \"swapped out\" via the synchronization process\r\n   *   - the solution to this dilemma is to resolve all object references\r\n   *     from their \"id\" AT RUN-TIME ... insuring you have the most current\r\n   *     active object.\r\n   *\r\n   * - Also, these change functions should only be concerned with the\r\n   *   modification of a given low-level object.  The `changeManager`\r\n   *   service will orchestrate additional detail to insure conformity.\r\n   *   For example, the service will issue the\r\n   *   `targetObj.trickleUpChange()` which syncs the change to it parentage\r\n   *   (synchronizing size and crc, etc.).\r\n   *\r\n   * **Please Note** this service uses named parameters.\r\n   * \r\n   * @param {function} changeFn - the function that applies the\r\n   * low-level change.\r\n   * \r\n   * @param {function} undoFn - the function that \"undoes\" the low-level\r\n   * change.  A guarantee is made that the object state will be as it was\r\n   * immediately after the `changeFn()` execution.\r\n   */\r\n  applyChange({changeFn, undoFn, ...unknownArgs}={}) {\r\n    // validate parameters\r\n    const check = verify.prefix('changeManager.applyChange() parameter violation: ');\r\n    // ... changeFn\r\n    check(changeFn,             'changeFn is required');\r\n    check(isFunction(changeFn), 'changeFn must be a function');\r\n    // ... undoFn\r\n    check(undoFn,             'undoFn is required');\r\n    check(isFunction(undoFn), 'undoFn must be a function');\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // apply the initial change\r\n    const targetObj = applyChange(check, changeFn, false/*NOT redo (rather our initial change)*/);\r\n\r\n    // register our undo operation - associated to the target's PkgEntry\r\n    const pkgEntryId = targetObj.getPkgEntry().getEPkgId(); // ex: 'com.astx.ACME/scene1'\r\n    // console.log(`xx changeManager ... pkgEntryId: '${pkgEntryId}'`);\r\n    this.registerUndoRedoOp(pkgEntryId, undoFn, changeFn);\r\n  }\r\n\r\n  /**\r\n   * An internal method that registers the supplied undo/redo operation.\r\n   *\r\n   * @param {string} pkgEntryId - the PkgEntryId for which this\r\n   * operation applies (ex: 'com.astx.ACME/scene1').\r\n   * \r\n   * @param {function} undoFn - the function that \"undoes\" the low-level\r\n   * change.\r\n   * \r\n   * @param {function} redoFn - the function that applies the\r\n   * low-level change.\r\n   *\r\n   * @private\r\n   */\r\n  registerUndoRedoOp(pkgEntryId, undoFn, redoFn) {\r\n    // NOTE: No validate params (internal routine)\r\n\r\n    // locate our UndoRedoMgr (create on first usage)\r\n    let undoRedoMgr = this.undoRedoHash[pkgEntryId];\r\n    if (!undoRedoMgr) {\r\n      undoRedoMgr = this.undoRedoHash[pkgEntryId] = new UndoRedoMgr(pkgEntryId);\r\n    }\r\n\r\n    // register the supplied undo/redo operation\r\n    const oldState = {undoAvail: undoRedoMgr.isUndoAvail(), redoAvail: undoRedoMgr.isRedoAvail()};\r\n    undoRedoMgr.registerOp(undoFn, redoFn);\r\n    const newState = {undoAvail: undoRedoMgr.isUndoAvail(), redoAvail: undoRedoMgr.isRedoAvail()};\r\n\r\n    // maintain our redux state (when changed)\r\n    if (!isEqual(oldState, newState)) {\r\n      this.dispatchAction( _changeManagerAct.undoRedoChanged(pkgEntryId, newState.undoAvail, newState.redoAvail) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply an \"undo\" operation to the supplied PkgEntry.\r\n   *\r\n   * @param {string} pkgEntryId - identifies the PkgEntry for which\r\n   * this operation applies (ex: 'com.astx.ACME/scene1').\r\n   */\r\n  applyUndo(pkgEntryId) {\r\n    // validate parameters\r\n    const check = verify.prefix('*** ERROR *** changeManager.applyUndo(): ');\r\n    // ... pkgEntryId\r\n    check(pkgEntryId,           'parameter violation: pkgEntryId is required');\r\n    check(isString(pkgEntryId), 'parameter violation: pkgEntryId must be a function');\r\n\r\n    // locate our undoRedoMgr\r\n    const undoRedoMgr = this.undoRedoHash[pkgEntryId];\r\n    check(undoRedoMgr, `pkgEntryId: '${pkgEntryId}' has NO \"change management\" applied to it (cannot apply an undo operation)`);\r\n\r\n    // apply the undo operation\r\n    const oldState = {undoAvail: undoRedoMgr.isUndoAvail(), redoAvail: undoRedoMgr.isRedoAvail()};\r\n    undoRedoMgr.applyUndo(check);\r\n    const newState = {undoAvail: undoRedoMgr.isUndoAvail(), redoAvail: undoRedoMgr.isRedoAvail()};\r\n\r\n    // maintain our redux state (when changed)\r\n    if (!isEqual(oldState, newState)) {\r\n      this.dispatchAction( _changeManagerAct.undoRedoChanged(pkgEntryId, newState.undoAvail, newState.redoAvail) );\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Apply an \"redo\" operation to the supplied PkgEntry.\r\n   *\r\n   * @param {string} pkgEntryId - identifies the PkgEntry for which\r\n   * this operation applies (ex: 'com.astx.ACME/scene1').\r\n   */\r\n  applyRedo(pkgEntryId) {\r\n    // validate parameters\r\n    const check = verify.prefix('*** ERROR *** changeManager.applyRedo(): ');\r\n    // ... pkgEntryId\r\n    check(pkgEntryId,           'parameter violation: pkgEntryId is required');\r\n    check(isString(pkgEntryId), 'parameter violation: pkgEntryId must be a function');\r\n\r\n    // locate our undoRedoMgr\r\n    const undoRedoMgr = this.undoRedoHash[pkgEntryId];\r\n    check(undoRedoMgr, `pkgEntryId: '${pkgEntryId}' has NO \"change management\" applied to it (cannot apply an redo operation)`);\r\n\r\n    // apply the redo operation\r\n    const oldState = {undoAvail: undoRedoMgr.isUndoAvail(), redoAvail: undoRedoMgr.isRedoAvail()};\r\n    undoRedoMgr.applyRedo(check);\r\n    const newState = {undoAvail: undoRedoMgr.isUndoAvail(), redoAvail: undoRedoMgr.isRedoAvail()};\r\n\r\n    // maintain our redux state (when changed)\r\n    if (!isEqual(oldState, newState)) {\r\n      this.dispatchAction( _changeManagerAct.undoRedoChanged(pkgEntryId, newState.undoAvail, newState.redoAvail) );\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// expose our single changeManager utility ... AI: singleton code smell\r\nconst changeManager = new ChangeManager();\r\nexport default changeManager;\r\n\r\n\r\n/**\r\n * UndoRedo is an internal class that manages undo/redo operations for\r\n * a given PkgEntry.\r\n *\r\n * @param {string} pkgEntryId - the PkgEntryId for which self's undo/redo\r\n * operations apply (ex: 'com.astx.ACME/scene1').\r\n *\r\n * @private\r\n */\r\nclass UndoRedoMgr {\r\n\r\n  /**\r\n   * Create an UndoRedo instance.\r\n   */\r\n  constructor(pkgEntryId) {\r\n    // carve out our state\r\n    this.pkgEntryId = pkgEntryId;\r\n    this.stack = []; // [ [undoFn, redoFn], ... ]\r\n    this.cur = -1;   // points to the actual current stack entry (-1 for NO entries)\r\n  }\r\n\r\n  /**\r\n   * Register the supplied undo/redo operation to self's PkgEntry.\r\n   * \r\n   * @param {function} undoFn - the function that \"undoes\" the low-level\r\n   * change.\r\n   * \r\n   * @param {function} redoFn - the function that applies the\r\n   * low-level change.\r\n   */\r\n  registerOp(undoFn, redoFn) {\r\n    // prune any \"active\" redos\r\n    // ... when \"undos\" have been applied, there are active \"redos\" that are no longer possible\r\n    //     BECAUSE of this new user-supplied operation\r\n    while (this.isRedoAvail()) {\r\n      this.stack.pop();\r\n    }\r\n\r\n    // register our new entry\r\n    this.stack.push([undoFn, redoFn]);\r\n    this.cur = this.stack.length - 1;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self's PkgEntry has \"undos\" available.\r\n   * \r\n   * @returns {boolean} `true`: \"undos\" are available, `false` otherwise.\r\n   */\r\n  isUndoAvail() {\r\n    // undo is available whenever we have active entries\r\n    // ... NOTE: we use index NOT this.stack.length BECAUSE \r\n    //           the stack (array) is preserved during active undo (for redo activation)\r\n    return this.cur >= 0;\r\n  }\r\n\r\n  /**\r\n   * Apply an \"undo\" operation to self's PkgEntry.\r\n   *\r\n   * @param {function} check the check function on who's behalf we are\r\n   * operating.\r\n   */\r\n  applyUndo(check) {\r\n    check(this.isUndoAvail(), `pkgEntryId: '${this.pkgEntryId}' DOES NOT currently have an \"undo\" operation available`);\r\n\r\n    // locate undoFn\r\n    const [undoFn/*, redoFn*/] = this.stack[this.cur];\r\n    this.cur--;\r\n\r\n    // apply the undoFn\r\n    applyChange(check, undoFn, undefined/*redo: N/A for undo*/);\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self's PkgEntry has \"redos\" available.\r\n   * \r\n   * @returns {boolean} `true`: \"redos\" are available, `false` otherwise.\r\n   */\r\n  isRedoAvail() {\r\n    // redo is available when an \"active\" undo has been applied\r\n    // ... i.e. an undo executed -AND- no other changes have been executed\r\n    return this.cur < this.stack.length-1;\r\n  }\r\n\r\n  /**\r\n   * Apply an \"redo\" operation to self's PkgEntry.\r\n   *\r\n   * @param {function} check the check function on who's behalf we are\r\n   * operating.\r\n   */\r\n  applyRedo(check) {\r\n    check(this.isRedoAvail(), `pkgEntryId: '${this.pkgEntryId}' DOES NOT currently have a \"redo\" operation available`);\r\n\r\n    // locate the redoFn\r\n    this.cur++;\r\n    const [/*undoFn*/, redoFn] = this.stack[this.cur];\r\n\r\n    // apply the redoFn\r\n    applyChange(check, redoFn, true/*redo: this is truly a redo!!*/);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Utility function that manages the details of any change (initial,\r\n * undo, or redo).\r\n *\r\n * @param {function} check the check function on who's behalf we are\r\n * operating.\r\n * \r\n * @param {function} changeFn - the function that will apply the\r\n * change (this can be the initial/redo or undo function).\r\n * \r\n * @param {boolean} redo - an indicator as to whether this is a redo\r\n * operation.\r\n */\r\nfunction applyChange(check, changeFn, redo=false) {\r\n  // apply the change by invoking the app-level change function\r\n  // ... the redo param is only applicable for redoFn()\r\n  //     however it doesn't hurt to pass an additional param on undoFn() :-)\r\n  const targetObj = changeFn(redo);\r\n  check(isSmartObject(targetObj), 'the execution of app-level change functions (registered to changeManager) MUST return a targetObj that is a SmartObject (type: SmartModel)');\r\n\r\n  // trickle up this low-level change, syncing our parentage \r\n  targetObj.trickleUpChange();\r\n\r\n  // that's all folks\r\n  return targetObj;\r\n}\r\n\r\n\r\n","/* eslint-disable react/no-is-mounted */ // isMount() usage is NOT react-based\r\nimport verify               from 'util/verify';\r\nimport {isString,\r\n        isPlainObject,\r\n        isFunction}         from 'util/typeCheck';\r\nimport checkUnknownArgs     from 'util/checkUnknownArgs';\r\nimport pkgManager           from './pkgManager';\r\nimport PseudoClass          from './PseudoClass';\r\nimport DispMode             from './DispMode';\r\nimport createTypeRefHandler from './createTypeRefHandler';\r\n\r\nimport crc                  from 'util/crc';\r\nimport {toast}              from 'util/notify';\r\nimport changeManager        from 'features/common/changeManager/changeManager'; // AI: pull from horses mouth (rather than 'features/xtra') to avoid circular import in core/Scene.js ... ReferenceError: Cannot access 'SmartPallet' before initialization\r\n\r\n/**\r\n * SmartModel is the abstract top-level base class of the visualize-it\r\n * object model. \r\n *\r\n * SmartModel derivations are referred to as \"smartObjects\".  They\r\n * have the following characteristics:\r\n *\r\n * - The class constructor employs namedProps.  This is KEY aspect to\r\n *   make persistence work, because it supports data-driven injection\r\n *   from smartJSON.\r\n *\r\n * The SmartModel base class provides a consistency in:\r\n *\r\n *  - identification (id/name):\r\n *    + constructor({id, name})\r\n *\r\n *  - persistance:\r\n *    + toSmartJSON():smartJSON ................. transforms self (with depth) into smartJSON\r\n *<S> + fromSmartJSON(smartJSON): smartObject ... reconstitutes class-based objects (with depth) from smartJSON\r\n *    + smartClone(): smartObject ............... creates a deep copy of self (used in pseudo constructor - SmartClassRef.createSmartObject(namedParams)))\r\n *    + getEncodingProps(): string[] ............ polymorphically expose properties required to encode self\r\n *\r\n *  - meta info (more found in PseudoClass and SmartClassRef):\r\n *    + getClassRef(): SmartClassRef ... promotes the classRef from which self was created (unifying both real classes and pseudo classes)\r\n *    + diagClassName(): string ........ resolves real class name (unmangled) used in diagnostics (use getClassRef().getClassName() when pseudoClass needs to be interpreted)\r\n */\r\nexport default class SmartModel {\r\n\r\n  /**\r\n   * Create a SmartModel.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this object.\r\n   * @param {string} [name=id] - the human interpretable name of this\r\n   * object (DEFAULT to id).\r\n   */\r\n  constructor({id, name, ...unknownArgs}={}) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}(id:'${id}', name:'${name}') constructor parameter violation: `);\r\n\r\n    // ... id\r\n    check(id,            'id is required');\r\n    check(isString(id),  'id must be a string');\r\n\r\n    // ... name\r\n    if (name) {\r\n      check(isString(name), 'name (when supplied) must be a string');\r\n    }\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // retain parameters in self\r\n    this.id       = id;\r\n    this.name     = name || id;\r\n    this.dispMode = DispMode.view; // ... our dispMode starts out \"viewing\" content\r\n  }\r\n\r\n  /**\r\n   * Return self's object id.\r\n   */\r\n  getId() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Return self's object name.\r\n   */\r\n  getName() {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is a SmartObject (a\r\n   * SmartModel derivation).\r\n   *\r\n   * NOTE: These isaXyz() methods provide a way to perform instanceof\r\n   *       checks without requiring core class imports, which is more\r\n   *       vulnerable to circular dependencies (especially when used\r\n   *       in core)!\r\n   *\r\n   *       As a convenience, this method is fronted by `isSmartObject(ref)`\r\n   *       (found in `util/typeCheck.js`) which accommodates all data\r\n   *       type conditions (undefined, primitives, any object, etc.).\r\n   *\r\n   * @returns {boolean} `true`: self is a SmartObject (a SmartModel\r\n   * derivation), `false` otherwise.\r\n   */\r\n  isaSmartObject() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Polymorphically reveal self's properties that should be used to\r\n   * reconstitute an equivalent object.\r\n   * \r\n   * The polymorphic knowledge provided by this method allows the\r\n   * many  methods to be fully implemented in the SmartModel\r\n   * base class, including:\r\n   * \r\n   *  - toSmartJSON()\r\n   *  - smartClone()\r\n   *  - getCrc()\r\n   *  - resetBaseCrc()\r\n   *  - areClassesOutOfSync()\r\n   *  - syncClassInstances()\r\n   *  - etc.\r\n   *\r\n   * In the simplest form, this method merely returns a `string[]` of\r\n   * the property names to encode.\r\n   *\r\n   *   ```js\r\n   *   class MyClass extends SmartModel {\r\n   *     getEncodingProps(): {\r\n   *       return ['prop1', 'prop2'];\r\n   *     }\r\n   *     ...\r\n   *   }\r\n   *   ```\r\n   * \r\n   * Sub-classes may accumulate their properties to their parent\r\n   * class, as follows:\r\n   *\r\n   *   ```js\r\n   *   class MyClass extends SmartModel {\r\n   *     getEncodingProps(): {\r\n   *       return [...super.getEncodingProps(), ...['my', 'props', 'too']];\r\n   *     }\r\n   *     ...\r\n   *   }\r\n   *   ```\r\n   * \r\n   * Each element in the returned array may either be:\r\n   *  - a propName: string\r\n   *  - or an ordered pair: `[propName, defaultValue]`\r\n   *    ... defaultValues are an optimization.  Persistence related tasks\r\n   *        will omit values matching defaultValues, because they are\r\n   *        expected to be reconstituted (by default) at\r\n   *        instantiation.  As a result, these defaultValues should\r\n   *        match the constructor default value semantics.\r\n   *\r\n   * As an example of this, let's say that in the sample above, the\r\n   * `too` prop will default to `1` (in the constructor).  With this\r\n   * knowledge, the encoding can be specified as follows:\r\n   *\r\n   *   ```js\r\n   *   class MyClass extends SmartModel {\r\n   *     constructor({my, props, too=1}): {\r\n   *       ...\r\n   *     }\r\n   *     getEncodingProps(): {\r\n   *       return [...super.getEncodingProps(), ...['my', 'props', ['too',1]]];\r\n   *     }\r\n   *     ...\r\n   *   }\r\n   *   ```\r\n   * \r\n   * **Details**:\r\n   *\r\n   * NOT ALL object properties should be encoded.  There are cases\r\n   * where the object state is reconstituted from logic (in the\r\n   * constructor or elsewhere) rather from the content driven by this\r\n   * method.  As an example, temporal working state (such as mounted\r\n   * visuals) should be omitted.\r\n   *\r\n   * Remember this encoding is used to reconstitute an equivalent\r\n   * object.\r\n   *\r\n   * **pseudoClass Details**:\r\n   * \r\n   * pseudoClass implementations have additional considerations in\r\n   * their `getEncodingProps()` implementation.\r\n   * \r\n   * - General Rule: \r\n   * \r\n   *   * pseudoClass INSTANCEs should omit the props that will be\r\n   *     reconstituted by the pseudoClass constructor (i.e. the\r\n   *     pseudoClass MASTER).  This is similar to how a real class\r\n   *     instantiation reconstitutes its internal state.\r\n   * \r\n   *   * pseudoClass MASTERs should include ALL props.\r\n   *\r\n   *   Here is a pseudoClass example taken from `Scene`:\r\n   *   \r\n   *     ```js\r\n   *     getEncodingProps() {\r\n   *     \r\n   *       // define our \"baseline\"\r\n   *       const encodingProps = [['x',0], ['y',0]];\r\n   *     \r\n   *       // for pseudoClass MASTERs, include non-temporal props\r\n   *       // ... see JavaDoc for: SmartModel.getEncodingProps()\r\n   *       if (this.pseudoClass.isType()) {\r\n   *         encodingProps.push('comps');\r\n   *       }\r\n   *     \r\n   *       return [...super.getEncodingProps(), ...encodingProps];\r\n   *     }      \r\n   *     ```\r\n   *\r\n   * @returns {[propName, [propName, defaultValue], ...]} self's\r\n   * property names (string) to be encoded in our smartJSON\r\n   * representation (omitting values that match the optional\r\n   * defaultValue).\r\n   */\r\n  getEncodingProps() {\r\n    return ['id', 'name'];\r\n  }\r\n\r\n  /**\r\n   * Iterate over all self's encoding properties, executing the\r\n   * supplied `cbFn` for each property.\r\n   *\r\n   * As a convenience, the entire encoding structure is deciphered,\r\n   * including:\r\n   *  - propName\r\n   *  - propValue\r\n   *  - defaultValue (optional - when not defined, an obscure\r\n   *    `'DeFaUlT NoT dEfInEd'` value is used)\r\n   *\r\n   * @param {function} cbFn - the callback function to execute for each\r\n   * encoding property.  API:\r\n   *   ```js\r\n   *   + cbFn(propName, propValue, defaultValue): void\r\n   *   ```\r\n   */\r\n  encodingPropsForEach(cbFn) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}.encodingPropsForEach() parameter violation: `);\r\n    // ... cbFn\r\n    check(cbFn,             'cbFn is required');\r\n    check(isFunction(cbFn), 'cbFn must be a function');\r\n\r\n    // iteration loop\r\n    // ... driven by self's smartObj encoding properties\r\n    const encodingProps = this.getEncodingProps();\r\n    encodingProps.forEach( (prop) => {\r\n      // decipher propName/propValue\r\n      const [propName, defaultValue] = Array.isArray(prop) ? prop : [prop, 'DeFaUlT NoT dEfInEd'];\r\n      const propValue = this[propName];\r\n      \r\n      // callback into invoker realm\r\n      cbFn(propName, propValue, defaultValue);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Provide a reducer, by iterating over all self's encoding\r\n   * properties, executing the supplied `cbFn` (a reducer) for each\r\n   * property, resulting in a single output value.\r\n   *\r\n   * As a convenience, the entire encoding structure is deciphered,\r\n   * including:\r\n   *  - propName\r\n   *  - propValue\r\n   *  - defaultValue (optional - when not defined, an obscure\r\n   *    `'DeFaUlT NoT dEfInEd'` value is used)\r\n   *\r\n   * @param {function} cbFn - the callback reducer function to execute\r\n   * for each encoding property.  API:\r\n   *   ```js\r\n   *   + cbFn(accum, propName, propValue, defaultValue): accumAmalgamation\r\n   *   ```\r\n   *\r\n   * @param {any} initialAccum - the initial accumulation value.  This\r\n   * seeds the `accum` parameter (of the `cbFn()`) for the first\r\n   * iteration.\r\n   *\r\n   * @returns {any} the single output value resulting from the\r\n   * reduction.\r\n   */\r\n  encodingPropsReduce(cbFn, initialAccum) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}.encodingPropsReduce() parameter violation: `);\r\n    // ... cbFn\r\n    check(cbFn,             'cbFn is required');\r\n    check(isFunction(cbFn), 'cbFn must be a function');\r\n    // ... initialAccum\r\n    check(initialAccum!==undefined, 'initialAccum is required');\r\n\r\n    // iteration loop\r\n    // ... driven by self's smartObj encoding properties\r\n    const encodingProps = this.getEncodingProps();\r\n    const accum = encodingProps.reduce( (accum, prop) => {\r\n      // decipher propName/propValue\r\n      const [propName, defaultValue] = Array.isArray(prop) ? prop : [prop, 'DeFaUlT NoT dEfInEd'];\r\n      const propValue = this[propName];\r\n      \r\n      // callback into invoker realm\r\n      return cbFn(accum, propName, propValue, defaultValue);\r\n    }, initialAccum);\r\n\r\n    // promote the overall accumulation\r\n    return accum;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return the crc hash for this object, uniquely identifying self.\r\n   * \r\n   * This hash is generated as needed, utilizing an optimized cache.\r\n   * \r\n   * NOTE: This algorithm is fully implemented within the SmartModel\r\n   *       base class.  With the polymorphic knowledge of which\r\n   *       properties to process (see getEncodingProps()) it rarely\r\n   *       needs to be overwritten.\r\n   *\r\n   * @returns {number} self's crc hash that uniquely identifies self\r\n   */\r\n  getCrc() {\r\n\r\n    // our type specific handler\r\n    // ... definition is close to usage, but cached for optimization (can be re-used by ANY instance)\r\n    const getCrcRefHandler = handlerCache.getCrcRefHandler = handlerCache.getCrcRefHandler || createTypeRefHandler({\r\n      // fold in null/undefined (just for good measure)\r\n      handleNoRef: (noRef, accumCrc) => crc(noRef, accumCrc),\r\n      // fold in primitive's crc\r\n      handlePrimitive: (primitiveRef, accumCrc) => crc(primitiveRef, accumCrc),\r\n      // fold in array items\r\n      handleArray: (arrRef, accumCrc) => arrRef.reduce( (accum, item) => getCrcRefHandler(item, accum), accumCrc ),\r\n      // fold in the crc of each object property\r\n      handlePlainObj: (plainObjRef, accumCrc) => (\r\n        Object.entries(plainObjRef).reduce( (accum, [subPropName, subPropValue]) => {\r\n          accum = crc(subPropName, accum); // accum the prop name  (string) ... for good measure (shouldn't hurt)\r\n          accum = getCrcRefHandler(subPropValue, accum); // accum the prop value (any type)\r\n          return accum;\r\n        }, accumCrc)\r\n      ),\r\n      // fold in SmartObj.getCrc()\r\n      // ... should be OK to use a crc as the value of another crc calc\r\n      handleSmartObj: (smartObjRef, accumCrc) => crc(smartObjRef.getCrc(), accumCrc),\r\n      // UNSUPPORTED: NON SmartObjects (not plain and not smart)\r\n      handleNonSmartObj(otherObjRef, accum) {\r\n        throw new Error(`***ERROR*** SmartObject.getCrc() traversal encountered an object reference of unsupported type: ${otherObjRef.constructor.name} :-(`);\r\n      },\r\n      // fold in class name (unsure if this is needed)\r\n      handleClass: (classRef, accumCrc) => crc(classRef.name, accumCrc),\r\n    });\r\n\r\n    // calculate/retain our crc as needed\r\n    if (!this._crc) { // ... either first time, or cache is being regenerated\r\n\r\n      // our crc is driven by self's instance properties\r\n      this._crc = this.encodingPropsReduce( (accumCrc, propName, propValue, defaultValue) => {\r\n        // recursively accumulate the crc of each instance props\r\n        // ... interpreting arrays, primitives, and SmartModel\r\n        accumCrc = crc(propName, accumCrc);               // accum the prop name  (string) ... for good measure (shouldn't hurt)\r\n        accumCrc = getCrcRefHandler(propValue, accumCrc); // accum the prop value (any type)\r\n\r\n        return accumCrc;\r\n      }, 0/*initialAccum*/);\r\n\r\n      // console.log(`xx ${this.diagClassName()}.getCrc() CALCULATING CRC from props: ${encodingProps} ... CRC: ${this._crc}`);\r\n    }\r\n    else {\r\n      // console.log(`xx ${this.diagClassName()}.getCrc() using CACHE ... CRC: ${this._crc}`);\r\n    }\r\n\r\n    // that's all folks\r\n    return this._crc;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is \"in sync\" with it's\r\n   * base version (i.e. the version saved on disk).\r\n   *\r\n   * An \"out of sync\" state indicates that modifications have occurred,\r\n   * and that a \"save\" operation is needed.\r\n   *\r\n   * @returns {boolean} self's \"in sync\" status with it's base version\r\n   * (true: in-sync, false: out-of-sync).\r\n   */\r\n  isInSync() {\r\n    return this.getBaseCrc() === this.getCrc();\r\n  }\r\n\r\n  /**\r\n   * Return the baseline crc hash for this object.\r\n   *\r\n   * This represents the crc from an initial version (typically a\r\n   * saved resource), and is used to determine when an item is \"out of\r\n   * sync\" (i.e. needs to be saved).\r\n   *\r\n   * @returns {number} self's baseline crc\r\n   */\r\n  getBaseCrc() {\r\n    // NOTE: when NOT defined, we still do NOT want to dynamically save this._baseCrc\r\n    //       - EX:   this._baseCrc = this.getCrc();\r\n    //       - BAD:  it is really too late for this\r\n    //               ... we have no idea if this time represents our baseline\r\n    //       - GOOD: just depend on resetBaseCrc() being invoked at the appropriate times\r\n    return this._baseCrc;\r\n  }\r\n\r\n  /**\r\n   * Reset the baseline crc throughout our containment tree.\r\n   *\r\n   * This represents the crc from an initial version (typically a\r\n   * saved resource), and is used to determine when an item is \"out of\r\n   * sync\" (i.e. needs to be saved).\r\n   * \r\n   * This method is invoked:\r\n   *  - at SmartPkg constructor (covering code-based packages)\r\n   *  - and at persistance time (load/save)\r\n   *  - NO: dynamically on getBaseCrc() ... see NOTE in getBaseCrc()\r\n   * \r\n   * NOTE: This algorithm is fully implemented within the SmartModel\r\n   *       base class.  With the polymorphic knowledge of which\r\n   *       properties to process (see getEncodingProps()) it rarely\r\n   *       needs to be overwritten.\r\n   */\r\n  resetBaseCrc() {\r\n\r\n    // our type specific handler\r\n    // ... definition is close to usage, but cached for optimization (can be re-used by ANY instance)\r\n    const resetBaseCrcRefHandler = handlerCache.resetBaseCrcRefHandler = handlerCache.resetBaseCrcRefHandler || createTypeRefHandler({\r\n      // no-op null/undefined ... resetBaseCrc does NOTHING for NoRef\r\n      handleNoRef: (noRef) => {},\r\n      // no-op primitives ... resetBaseCrc does NOTHING for primitives\r\n      handlePrimitive: (primitiveRef) => {},\r\n      // propagate into our subordinate array items\r\n      handleArray: (arrRef) => arrRef.forEach( (item) => resetBaseCrcRefHandler(item) ),\r\n      // propagate into our subordinate plain objects\r\n      handlePlainObj: (plainObjRef) => Object.values(plainObjRef).forEach( (item) => resetBaseCrcRefHandler(item) ),\r\n      // propagate into our subordinate smartObjs\r\n      handleSmartObj: (smartObjRef) => smartObjRef.resetBaseCrc(),\r\n      // UNSUPPORTED: NON SmartObjects (not plain and not smart)\r\n      handleNonSmartObj(otherObjRef) {\r\n        throw new Error(`***ERROR*** SmartObject.resetBaseCrc() traversal encountered an object reference of unsupported type: ${otherObjRef.constructor.name} :-(`);\r\n      },\r\n      // no-op classes ... currently there is NO crc recorded in raw classes\r\n      handleClass: (classRef) => {},\r\n    });\r\n\r\n    // retain self's prior baseline crc\r\n    const old_baseCrc = this._baseCrc;\r\n\r\n    // trickle this request down through our containment tree, driven by self's instance properties\r\n    this.encodingPropsForEach( (propName, propValue, defaultValue) => resetBaseCrcRefHandler(propValue) );\r\n\r\n    // reset self's new baseline crc\r\n    // ... this is done AFTER our lower-level subordinate objects\r\n    //     - probably NOT necessary, because normally these CRCs are adjusted from the \"ground up\"\r\n    //     - HOWEVER, it doesn't hurt (more of a defensive measure)\r\n    const new_baseCrc = this._baseCrc = this.getCrc();\r\n\r\n    // retain baseCrc state changes for ePkgs (when baseCrc changes)\r\n    const baseCrcChanged = old_baseCrc !== new_baseCrc;\r\n    if (this.isaEPkg() && baseCrcChanged) {\r\n      changeManager.ePkgChanged(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mount the visuals of this node, binding the Konva graphics.\r\n   *\r\n   * Prior to `mount()` execution, the visualize-it object\r\n   * representation is very lightweight.\r\n   *\r\n   * @param {Konva.any} containingKonvaContext - The container of\r\n   * this node (varies - typically a Konva reference).\r\n   */\r\n  mount(containingKonvaContext) {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.mount() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is mounted (i.e. bound to the Konva graphics).\r\n   *\r\n   * @returns {boolean} `true`: self is mounted, `false` otherwise\r\n   */\r\n  isMounted() {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.isMounted() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Unmount the visuals of this node, unbinding the Konva graphics.\r\n   *\r\n   * @param {boolean} [konvaPreDestroyed=false] - an internal\r\n   * parameter that indicates if konva nodes have already been\r\n   * destroyed (when a parent Konva.Node has already issued the\r\n   * konvaNode.destroy()).\r\n   */\r\n  unmount(konvaPreDestroyed=false) {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.unmount() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Replace self's child reference, defined by the specified params.\r\n   *\r\n   * @param {any} oldRef - the existing child to be replaced with\r\n   * `newRef`.\r\n   *\r\n   * @param {any} newRef - the new child to replace `oldRef`.\r\n   */\r\n  childRefChanged(oldRef, newRef) {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.childRefChanged() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether the class self was created from\r\n   * is out-of-sync with the latest class definition.\r\n   *\r\n   * Class versioning can become out-of-sync when interactive edits\r\n   * occur to the class master.\r\n   *\r\n   * Currently, this is only operational for pseudo classes.  Real\r\n   * code-based class versioning is not currently tracked, and will\r\n   * always indicate they are in-sync.\r\n   *\r\n   * @returns {boolean} `true`: self's class is out-of-sync with the\r\n   * latest class version, `false` otherwise.\r\n   */\r\n  isClassOutOfSync() {\r\n    // obtain the classRef self was created from\r\n    // ... NOTE: This is the same instance as if we pulled it directly from pkgManager!\r\n    //           e.g. pkgManager.getClassRef(selfsClassRef.getClassPkgId(), selfsClassRef.getClassName());\r\n    const selfsClassRef  = this.getClassRef();\r\n\r\n    // handle pseudo classes\r\n    if (selfsClassRef.isPseudoClass()) {\r\n      // compare the class version self was created from\r\n      // ... NOTE: versionCrcUsedInCreation is maintained by SmartClassRef.createSmartObject()\r\n      // console.log(`xx ${this.diagClassName()}.isClassOutOfSync() ... a pseudoClassInstance from version: : ${this.pseudoClass.versionCrcUsedInCreation} ... selfsClassRef:\\n`, selfsClassRef);\r\n      return selfsClassRef.getClassVersionCrc() !== this.pseudoClass.versionCrcUsedInCreation;\r\n    }\r\n\r\n    // handle real classes\r\n    // ... currently not tracked - consider them in-sync\r\n    return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return an indicator as to whether any of the classes that make up\r\n   * self (and it's containment tree) is out-of-sync with the latest\r\n   * class definitions.\r\n   *\r\n   * Class versioning can become out-of-sync when interactive edits\r\n   * occur to the class master.\r\n   *\r\n   * Currently, this is only operational for pseudo classes.  Real\r\n   * code-based class versioning is not currently tracked, and will\r\n   * always indicate they are in-sync.\r\n   *\r\n   * NOTE: This algorithm will short-circuit on the first out-of-sync\r\n   *       class it finds.  This is accomplished using OR logic.\r\n   *\r\n   * @returns {boolean} `true`: some of self's containment classes is\r\n   * out-of-sync with the latest class versions, `false` otherwise.\r\n   */\r\n  areClassesOutOfSync() {\r\n\r\n    // our type specific handler\r\n    // ... definition is close to usage, but cached for optimization (can be re-used by ANY instance)\r\n    const outOfSyncHandler = handlerCache.outOfSyncHandler = handlerCache.outOfSyncHandler || createTypeRefHandler({\r\n      // null/undefined can't be out-of-sync\r\n      handleNoRef: (noRef, accumOutOfSync) => accumOutOfSync || false,\r\n      // primitive's can't be out-of-sync\r\n      handlePrimitive: (primitiveRef, accumOutOfSync) => accumOutOfSync || false,\r\n      // analyze array items\r\n      handleArray: (arrRef, accumOutOfSync) => arrRef.reduce( (accum, item) => accum || outOfSyncHandler(item, accum), accumOutOfSync ),\r\n      // analyze plain object\r\n      handlePlainObj: (plainObjRef, accumOutOfSync) => Object.values(plainObjRef).reduce( (accum, item) => accum || outOfSyncHandler(item, accum), accumOutOfSync ),\r\n      // analyze SmartObj by recursing on our `areClassesOutOfSync()` method\r\n      handleSmartObj: (smartObjRef, accumOutOfSync) => accumOutOfSync || smartObjRef.areClassesOutOfSync(),\r\n      // UNSUPPORTED: NON SmartObjects (not plain and not smart)\r\n      handleNonSmartObj(otherObjRef, accumOutOfSync) {\r\n        throw new Error(`***ERROR*** SmartObject.areClassesOutOfSync() traversal encountered an object reference of unsupported type: ${otherObjRef.constructor.name} :-(`);\r\n      },\r\n      // classes can't be out-of-sync\r\n      handleClass: (classRef, accumOutOfSync) => accumOutOfSync || false,\r\n    });\r\n\r\n    // short-circuit process when we find our first out-of-date\r\n    if (this.isClassOutOfSync()) {\r\n      return true;\r\n    }\r\n\r\n    // trickle this request down through our containment tree, driven by self's instance properties\r\n    return this.encodingPropsReduce( (accumOutOfSync, propName, propValue, defaultValue) => {\r\n      return accumOutOfSync || outOfSyncHandler(propValue, accumOutOfSync); // short-circuit via OR (||)\r\n    }, false/*initialAccum*/);\r\n  }\r\n\r\n  /**\r\n   * Synchronize any out-of-date objects (within self and it's\r\n   * containment tree), bringing them up-to-date with the latest class\r\n   * definitions.\r\n   *\r\n   * Class versioning can become out-of-sync when interactive edits\r\n   * occur to the class master.\r\n   *\r\n   * Currently, this is only operational for pseudo classes.  Real\r\n   * code-based class versioning is not currently tracked, and will\r\n   * always indicate they are in-sync.\r\n   *\r\n   * PREREQUISITE: When invoking this method, the management of the\r\n   * Konva visuals must be addressed by surrounding the invocation\r\n   * with:\r\n   *   1. \"unmounting\" prior to invocation, and\r\n   *   2. \"remounting\" after the invocation\r\n   * Currently this is accomplished by our single invoking agent:\r\n   * `syncOutOfDateClasses()`\r\n   * ... the tabManager logic module that is activated whenever a tab is changed\r\n   *     (src/features/common/tabManager/logic.js).\r\n   */\r\n  syncClassInstances() {\r\n\r\n    // our type specific handler\r\n    // ... definition is close to usage, but cached for optimization (can be re-used by ANY instance)\r\n    const syncClassHandler = handlerCache.syncClassHandler = handlerCache.syncClassHandler || createTypeRefHandler({\r\n      // null/undefined can't be out-of-sync\r\n      handleNoRef: (noRef, accum) => {},\r\n      // primitive's can't be out-of-sync\r\n      handlePrimitive: (primitiveRef, accum) => {},\r\n      // drill into array items\r\n      handleArray: (arrRef, accum) => arrRef.forEach( (item) => syncClassHandler(item) ),\r\n      // drill into plain object\r\n      handlePlainObj: (plainObjRef, accum) => Object.values(plainObjRef).forEach( (item) => syncClassHandler(item) ),\r\n      // analyze SmartObj by recursing on our `syncClassInstances()` method\r\n      handleSmartObj: (smartObjRef, accum) => smartObjRef.syncClassInstances(),\r\n      // UNSUPPORTED: NON SmartObjects (not plain and not smart)\r\n      handleNonSmartObj(otherObjRef, accum) {\r\n        throw new Error(`***ERROR*** SmartObject.syncClassInstances() traversal encountered an object reference of unsupported type: ${otherObjRef.constructor.name} :-(`);\r\n      },\r\n      // classes can't be out-of-sync\r\n      handleClass: (classRef, accum) => {},\r\n    });\r\n\r\n    // when self is out-of-date, resync it!\r\n    if (this.isClassOutOfSync()) {\r\n\r\n      // verify that our Konva visuals have been unmounted\r\n      // ... see PREREQUISITE note (above)\r\n      verify(!this.isMounted(), `${this.diagClassName()}.syncClassInstances() ... invoker must first issue unmount() on self.`);\r\n\r\n      // re-create self by cloning it\r\n      // ... because smartClone() re-instantiates class instances from\r\n      //     the most current class definition, our new instance will be\r\n      //     in-sync!\r\n      // ... NOTE: We must directly issue smartClone() to get the\r\n      //           correct result (picking up the correct instance\r\n      //           state and class state)\r\n      //           NOT: this.getClassRef().createSmartObject()\r\n      //                ... see: \"two-phase\" NOTE in smartClone()\r\n//    const newSelf = this.getClassRef().createSmartObject(); // NO\r\n      const newSelf = this.smartClone();                      // YES\r\n      // console.log(`xx ${this.diagClassName()}.syncClassInstances() self is out-of-date:\\n`, {oldRef: this, newRef: newSelf});\r\n\r\n      // patch in our re-synced newSelf within our containment tree (replacing self)\r\n      // ... both to the \"primary\" containment tree\r\n      const parent = this.parent;\r\n      if (parent) {\r\n        newSelf.parent = parent;               // ... back-reference\r\n        parent.childRefChanged(this, newSelf); // ... forward-reference\r\n      }\r\n      // ... and the \"view\" containment tree\r\n      const viewParent = this.viewParent;\r\n      if (viewParent) {\r\n        newSelf.viewParent = viewParent;           // ... back-reference\r\n        viewParent.childRefChanged(this, newSelf); // ... forward-reference\r\n      }\r\n\r\n      // short-circuit our process\r\n      // ... there is no need to go any further IN THIS path\r\n      //     BECAUSE this entire containment tree path is now in-sync!\r\n      return;\r\n    }\r\n\r\n    // trickle this request down through our containment tree, driven by self's instance properties\r\n    this.encodingPropsForEach( (propName, propValue, defaultValue) => syncClassHandler(propValue) );\r\n  }\r\n\r\n\r\n  /**\r\n   * Return an indicator as to whether self is a pkg (SmartPkg).\r\n   *\r\n   * NOTE: These isaXyz() methods provide a way to perform instanceof\r\n   *       checks without requiring core class imports, which is more\r\n   *       vulnerable to circular dependencies (especially when used\r\n   *       in core)!\r\n   *\r\n   *       As a convenience, this method is fronted by `isPkg(ref)`\r\n   *       (found in `util/typeCheck.js`) which accommodates all data\r\n   *       type conditions (undefined, primitives, any object, etc.).\r\n   *\r\n   * @returns {boolean} `true`: self is a package (SmartPkg), `false` otherwise.\r\n   */\r\n  isaPkg() {\r\n    return false; // ... NOTE: overridden in SmartPkg\r\n  }\r\n\r\n  /**\r\n   * Return the pkg (SmartPkg) self belongs to (or self when it is a\r\n   * SmartPkg).\r\n   * \r\n   * NOTE: This is the SmartPkg that self belongs to (e.g. 'com.astx.ACME'),\r\n   *       NOT the package self was created from: (e.g. 'core').\r\n   *\r\n   * @returns {SmartPkg} the pkg (SmartPkg) self belongs to (or self\r\n   * when it is a SmartPkg), `undefined` when outside our supported\r\n   * \"primary\" containment tree.\r\n   */\r\n  getPkg() {\r\n    // when self is a SmartPkg, we have found it!\r\n    if (this.isaPkg()) {\r\n      return this;\r\n    }\r\n    // follow our parent chain, till we find the SmartPkg\r\n    const  parent = this.getParent();\r\n    return parent ? parent.getPkg() : undefined;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is a PkgEntry or not.\r\n   *\r\n   * PkgEntries are top-level entries registered to a package (SmartPkg).\r\n   * - They are visible in the LeftNav.\r\n   * - They are displayed in a tab (ex: Scene, Collage, Comp).\r\n   * - They are visually critical in monitoring whether they are in-sync\r\n   *   with their file resources.\r\n   *\r\n   * PkgEntries are managed by SmartPkg, simply marking them using the\r\n   * `markAsPkgEntry()` method.\r\n   *\r\n   * NOTE: As a convenience, this method is fronted by `isPkgEntry(ref)`\r\n   *       (found in `util/typeCheck.js`) which accommodates all data\r\n   *       type conditions (undefined, primitives, any object, etc.).\r\n   *\r\n   * @returns {boolean} `true`: self is a PkgEntry, `false` otherwise.\r\n   */\r\n  isaPkgEntry() {\r\n    return this._pkgEntry ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Return the PkgEntry self belongs to (or self when it is a\r\n   * PkgEntry).\r\n   *\r\n   * @returns {PkgEntry} the PkgEntry self belongs to (or self when it\r\n   * is a PkgEntry), `undefined` when outside our supported \"primary\"\r\n   * containment tree.\r\n   */\r\n  getPkgEntry() {\r\n    // when self is a PkgEntry, we have found it!\r\n    if (this.isaPkgEntry()) {\r\n      return this;\r\n    }\r\n    // follow our parent chain, till we find the PkgEntry\r\n    const  parent = this.getParent();\r\n    return parent ? parent.getPkgEntry() : undefined;\r\n  }\r\n\r\n  /**\r\n   * Mark self as a PkgEntry (see notes in `isaPkgEntry()`).\r\n   */\r\n  markAsPkgEntry() {\r\n    // mark self as a PkgEntry\r\n    this._pkgEntry = true;\r\n\r\n    // ALSO: maintain changeManager state\r\n    changeManager.registerEPkg(this);\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is an EPkg:\r\n   * - either a pkg (SmartPkg)\r\n   * - or a pkgEntry (top-level entries registered to a SmartPkg)\r\n   *\r\n   * These two objects are consolidated in the EPkg nomenclature, to\r\n   * accommodate the `changeManager` feature state, where EPkgs are\r\n   * tracked.\r\n   *\r\n   * NOTE: As a convenience, this method is fronted by `isEPkg(ref)`\r\n   *       (found in `util/typeCheck.js`) which accommodates all data\r\n   *       type conditions (undefined, primitives, any object, etc.).\r\n   *\r\n   * EPkgAI: EPkg may be obsolete with Svelte usage (it is an anomaly\r\n   *         of changeManager redux state management)\r\n   *\r\n   * @returns {boolean} `true`: self is an EPkg, `false` otherwise.\r\n   */\r\n  isaEPkg() {\r\n    return this.isaPkg() || this.isaPkgEntry();\r\n  }\r\n\r\n  /**\r\n   * Return the EPkg ID (see notes in isaEPkg).\r\n   *\r\n   * Examples:\r\n   * - 'com.astx.ACME' .......... for pkg (SmartPkg)\r\n   * - 'com.astx.ACME/scene1' ... for pkgEntry\r\n   *\r\n   * EPkgAI: EPkg may be obsolete with Svelte usage (it is an anomaly\r\n   *         of changeManager redux state management)\r\n   *\r\n   * @returns {string} self's EPkg ID.\r\n   *\r\n   * @throws {Error} when self is NOT an EPkg.\r\n   */\r\n  getEPkgId() {\r\n    if (this.isaPkg()) {\r\n      return this.getPkgId();\r\n    }\r\n    else if (this.isaPkgEntry()) {\r\n      return `${this.getPkg().getPkgId()}/${this.getId()}`;\r\n    }\r\n    else {\r\n      throw new Error(`***ERROR*** ${this.diagClassName()}.getEPkgId() [id:${this.id}]: self is NOT an EPkg!`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return self's parent object, with respect to the \"primary\"\r\n   * containment tree (i.e. NOT view related).\r\n   *\r\n   * @returns {SmartObject} the parent object of self, `undefined` for\r\n   * top-level (e.g. SmartPkg).\r\n   */\r\n  getParent() {\r\n    return this.parent;\r\n  }\r\n\r\n  /**\r\n   * Set self's parent object, with respect to the \"primary\"\r\n   * containment tree (i.e. NOT view related).\r\n   *\r\n   * @param {SmartObject} parent - the parent object of self.\r\n   */\r\n  setParent(parent) {\r\n    this.parent = parent;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is a view (SmartView).\r\n   *\r\n   * NOTE: These isaXyz() methods provide a way to perform instanceof\r\n   *       checks without requiring core class imports, which is more\r\n   *       vulnerable to circular dependencies (especially when used\r\n   *       in core)!\r\n   *\r\n   *       As a convenience, this method is fronted by `isView(ref)`\r\n   *       (found in `util/typeCheck.js`) which accommodates all data\r\n   *       type conditions (undefined, primitives, any object, etc.).\r\n   *\r\n   * @returns {boolean} `true`: self is a view (SmartView), `false` otherwise.\r\n   */\r\n  isaView() {\r\n    return false; // ... NOTE: overridden in SmartView\r\n  }\r\n\r\n  /**\r\n   * Return the SmartView self belongs to (or self when it is a\r\n   * SmartView)\r\n   *\r\n   * @returns {SmartView} the SmartView self belongs to (or self when\r\n   * it is a SmartView), `undefined` when outside our supported \"view\"\r\n   * containment tree.\r\n   */\r\n  getView() {\r\n    // when self is a SmartView, we have found it!\r\n    if (this.isaView()) {\r\n      return this;\r\n    }\r\n\r\n    // follow our \"view\" containment tree, till we find the SmartView\r\n    const  viewParent = this.getViewParent();\r\n    return viewParent ? viewParent.getView() : undefined;\r\n  }\r\n  \r\n  /**\r\n   * Return self's parent object, with respect to the \"view\"\r\n   * containment tree (i.e. NOT \"primary\" related).\r\n   *\r\n   * @returns {SmartObject} the \"view\" parent object of self,\r\n   * `undefined` when at top (e.g. SmartView).\r\n   */\r\n  getViewParent() {\r\n    // `this.viewParent` takes precedence, otherwise `this.parent` is a \"shared chain\"\r\n    return this.viewParent ? this.viewParent : this.parent;\r\n  }\r\n  \r\n  /**\r\n   * Set self's parent object, with respect to the \"view\" containment\r\n   * tree (i.e. NOT \"primary\" related).\r\n   *\r\n   * @param {SmartObject} parent - the \"view\" parent object of self.\r\n   */\r\n  setViewParent(viewParent) {\r\n    this.viewParent = viewParent;\r\n  }\r\n\r\n  /**\r\n   * Trickle up low-level changes to our parentage (both the \"primary\"\r\n   * and \"view\" containment tree.\r\n   *\r\n   * This propagates changes to various aspects, such as:\r\n   *  - size\r\n   *  - crc\r\n   *\r\n   * The `trickleUpChange()` when any change occurs\r\n   *  - centrally by `changeManger.applyChange()`\r\n   *  - also during an initial mount (replacing \"approximation\" size\r\n   *    with \"exact\" size) ... see: `SmartView.mount()`\r\n   *\r\n   * @param {boolean} [sizeChanged=true] - an internal indicator as to\r\n   * whether size has changed.  This should NOT be set by any public\r\n   * invocation - only by our internal recursion.  It is an\r\n   * optimization, that no-ops size re-calculation when the size has\r\n   * NOT changed.  The entry-level default assumes size may have\r\n   * changed (so it will always check for size changes)\r\n   */\r\n  trickleUpChange(sizeChanged=true) {\r\n\r\n    //***\r\n    //*** manage size (many things can impact container size)\r\n    //***\r\n\r\n    // when self promotes size, and size has changed (in our lower-containment tree)\r\n    // ... regen self's size, keeping track of whether sizeChanged (for optimization)\r\n    if (this.getSize && sizeChanged) {\r\n\r\n      // retain our oldSize\r\n      // ... via our cache (this exists when getSize() previously invoked)\r\n      const oldSize = this.sizeCache ? this.sizeCache : {width:-1, height:-1};\r\n\r\n      // clear our sizeCache allowing getSize() to regenerate\r\n      this.sizeCache = undefined;\r\n\r\n      // regen our size (i.e. our newSize)\r\n      // ... internally, this retains our cache once more :-)\r\n      const newSize = this.getSize();\r\n      \r\n      // perform any static binding of new size\r\n      // ... only when size has changed\r\n      sizeChanged = !(oldSize.width===newSize.width && oldSize.height===newSize.height);\r\n      if (sizeChanged) {\r\n        this.bindSizeChanges(oldSize, newSize);\r\n      }\r\n    }\r\n\r\n    //***\r\n    //*** manage crc changes\r\n    //***\r\n\r\n    // re-calculate self's crc\r\n    const oldCrc = this._crc;\r\n    this._crc    = undefined;     // clear the cached _crc\r\n    const newCrc = this.getCrc(); // ... allowing getCrc() to recalculate it\r\n\r\n    // retain crc state changes for ePkgs (when crc changes)\r\n    const crcChanged = oldCrc !== newCrc;\r\n    // console.log(`xx trickleUpChange on obj: ${this.diagClassName()} for CRC old: ${oldCrc} / new: ${newCrc} ... isaEPkg(): ${this.isaEPkg()} / crcChanged: ${crcChanged}`);\r\n    if (this.isaEPkg() && crcChanged) {\r\n      // console.log(`xx YES YES YES self is an EPkg who's CRC CHANGED ... issuing changeManager.ePkgChanged()`);\r\n      changeManager.ePkgChanged(this);\r\n    }\r\n\r\n    //***\r\n    //*** trickle up change to higher level\r\n    //***\r\n\r\n    // both to the \"primary\" containment tree\r\n    const parent = this.parent;\r\n    if (parent) {\r\n      parent.trickleUpChange(sizeChanged);\r\n    }\r\n\r\n    // and the \"view\" containment tree\r\n    const viewParent = this.viewParent;\r\n    if (viewParent) {\r\n      viewParent.trickleUpChange(sizeChanged);\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * Return self's dispMode (maintained in top-level PkgEntry objects - visible in LeftNav and Tabs).\r\n   * @returns {DispMode} the dispMode of self.\r\n   */\r\n  getDispMode() {\r\n    return this.dispMode;\r\n  }\r\n\r\n  /**\r\n   * Set self's dispMode (maintained in top-level PkgEntry objects - visible in LeftNav and Tabs).\r\n   *\r\n   * @param {DispMode} dispMode - the display mode to set.\r\n   *\r\n   * @throws {Error} an Error is thrown if the supplied dispMode is NOT supported.\r\n   */\r\n  setDispMode(dispMode) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}.setDispMode() parameter violation: `);\r\n    // ... dispMode\r\n    check(dispMode,                     'dispMode is required');\r\n    check(dispMode instanceof DispMode, 'dispMode must be a DispMode type');\r\n\r\n    // ... insure self supports this setting\r\n    check(this.canHandleDispMode(dispMode), `does NOT support ${dispMode} :-(`);\r\n\r\n    // perform the set operation\r\n    this.dispMode = dispMode;\r\n\r\n    // fully enable this DispMode in the object model\r\n    if (dispMode === DispMode.view) {\r\n      this.enableViewMode();\r\n    }\r\n    else if (dispMode === DispMode.edit) {\r\n      // perform a pre-check to prevent edit mode when containing package cannot be persisted\r\n      // ... ex: when the package contains code\r\n      const pkg = this.getPkg();\r\n      if (!pkg.canPersist()) {\r\n        toast.warn({msg: `The \"${this.getName()}\" resource cannot be edited ` + \r\n                         `... normally it can, however it belongs to the \"${pkg.getPkgName()}\" package which ` +\r\n                         `contains code (therefore you would not be able to save your changes).`});\r\n        return;\r\n      }\r\n\r\n      // go forward with our normal edit enablement\r\n      this.enableViewMode(); // a neutral reset\r\n      this.enableEditMode();\r\n    }\r\n    else if (dispMode === DispMode.animate) {\r\n      this.enableViewMode(); // a neutral reset\r\n      this.enableAnimateMode();\r\n    }\r\n    else {\r\n      throw new Error(`***ERROR*** ${this.diagClassName()}.setDispMode() [id:${this.id}]: unrecognized dispMode: ${dispMode}!`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self supports the supplied `dispMode`.\r\n   *\r\n   * @param {DispMode} dispMode - the display mode to evaluate.\r\n   *\r\n   * @throws {boolean} true: can handle, false: not supported.\r\n   */\r\n  canHandleDispMode(dispMode) {\r\n    return true;  // by default, base class assumes all DispModes are supported\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"view\" DispMode (maintained in top-level PkgEntry objects - visible in LeftNav and Tabs).\r\n   *\r\n   * NOTE: this is also invoked prior to other display modes, as a neutral reset :-)\r\n   */\r\n  enableViewMode() {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.enableViewMode() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"edit\" DispMode (maintained in top-level PkgEntry objects - visible in LeftNav and Tabs).\r\n   */\r\n  enableEditMode() {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.enableEditMode() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"animate\" DispMode (maintained in top-level PkgEntry objects - visible in LeftNav and Tabs).\r\n   */\r\n  enableAnimateMode() {\r\n    throw new Error(`***ERROR*** SmartModel pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.enableAnimateMode() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n\r\n  /**\r\n   * An instance method that transforms self (with depth) into\r\n   * smartJSON.\r\n   * \r\n   * NOTE: This algorithm is fully implemented within the SmartModel\r\n   *       base class.  With the polymorphic knowledge of which\r\n   *       properties to encode (see getEncodingProps()) it rarely\r\n   *       needs to be overwritten.\r\n   *\r\n   * REMEMBER: `this` is an object instance of SmartModel (because we are an\r\n   *           instance method).  In other words, this method only handles\r\n   *           SmartModel types (NOT primitives, or other objects, etc.)\r\n   *           As a result, the resulting JSON follows this pattern:\r\n   *\r\n   *           - the master definition of the BoilerScene pseudoClass (a type: Scene)\r\n   *             ```js\r\n   *               {\r\n   *                 smartType: 'Scene',\r\n   *                 smartPkg:  'core',\r\n   *                 id:        'BoilerScene',\r\n   *                 name:      'A Scene focused on the boiler components of our system',\r\n   *                 comps: [\r\n   *                   {...smartObj...},\r\n   *                   {...smartObj...},\r\n   *                 ],\r\n   *               }\r\n   *             ```\r\n   *\r\n   *           - an instance of the BoilerScene pseudoClass (a type: BoilerScene)\r\n   *             ```js\r\n   *               {\r\n   *                 smartType: 'BoilerScene',\r\n   *                 smartPkg:  'ACME',\r\n   *                 id:        'BoilerScene',\r\n   *                 name:      'A Scene focused on the boiler components of our system',\r\n   *                 .... NOTE: all other members are re-constituted from the master definition\r\n   *                            ... i.e. the pseudoClass\r\n   *               }\r\n   *             ```\r\n   *\r\n   * @returns {smartJSON} the smartJSON representation of self.\r\n   */\r\n  toSmartJSON() {\r\n\r\n    // our type specific handler\r\n    // ... definition is close to usage, but cached for optimization (can be re-used by ANY instance)\r\n    const toSmartJSONRefHandler = handlerCache.toSmartJSONRefHandler = handlerCache.toSmartJSONRefHandler || createTypeRefHandler({\r\n      // pass through null/undefined references\r\n      handleNoRef: (noRef, accumJSON) => noRef,\r\n      // pass through primitives\r\n      handlePrimitive: (primitiveRef, accumJSON) => primitiveRef,\r\n      // encode all array items\r\n      handleArray: (arrRef, accumJSON) => arrRef.map( item => toSmartJSONRefHandler(item) ),\r\n      // encode plain object\r\n      handlePlainObj: (plainObjRef, accumJSON) => (\r\n        Object.entries(plainObjRef).reduce( (accum, [subRefName, subRef]) => {\r\n          accum[subRefName] = toSmartJSONRefHandler(subRef);\r\n          return accum;\r\n        }, {} )\r\n      ),\r\n      // encode SmartObjs toSmartJSON()\r\n      handleSmartObj: (smartObjRef, accumJSON) => smartObjRef.toSmartJSON(),\r\n      // UNSUPPORTED: NON SmartObjects (not plain and not smart)\r\n      handleNonSmartObj(otherObjRef, accumJSON) {\r\n        throw new Error(`***ERROR*** SmartObject.toSmartJSON() traversal encountered an object reference of unsupported type: ${otherObjRef.constructor.name} :-(`);\r\n      },\r\n      // UNSUPPORTED: class reference\r\n      handleClass(classRef, accumJSON) {\r\n        throw new Error(`***ERROR*** SmartObject.toSmartJSON() traversal encountered reference of unsupported type - class or function: ${classRef.name} :-(`);\r\n      },\r\n    });\r\n\r\n    // prime our JSON by encoding our smart type information\r\n    // ... using SmartClassRef, this structure considers BOTH real types/classes AND pseudoClasses\r\n    const classRef = this.getClassRef();\r\n    const myJSON = {\r\n      smartType: classRef.getClassName(),\r\n      smartPkg:  classRef.getClassPkgId(),\r\n    };\r\n\r\n    // demark the pseudoClass MASTERs in our JSON, so they can be hydrated early\r\n    // ... see SmartPkg.fromSmartJSON()\r\n    if (PseudoClass.isPseudoClassMaster(this)) {\r\n      myJSON.isPseudoClassMaster = true;\r\n    }\r\n\r\n    // encode self's instance properties\r\n    this.encodingPropsForEach( (propName, propValue, defaultValue) => {\r\n      // conditionally accumulate the running JSON structure ONLY WHEN it is NOT the default\r\n      if (propValue !== defaultValue) {\r\n        myJSON[propName] = toSmartJSONRefHandler(propValue);\r\n      }\r\n    });\r\n\r\n    // beam me up Scotty :-)\r\n    return myJSON;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return the classRef from which self was created.\r\n   *\r\n   * This is a meta object that accommodates type/class information\r\n   * for ALL smartObjects, unifying both real classes and pseudo\r\n   * classes!\r\n   *\r\n   * @returns {SmartClassRef} the classRef from which self was\r\n   * created.\r\n   */\r\n  getClassRef() {\r\n\r\n    // validation checks\r\n    // ... we use plain `this.constructor.name`, even though it may be mangled in production build\r\n    //     to avoid reliance on the value-added classRef we are accessing \"in this method\" :-)\r\n    const check = verify.prefix(`${this.constructor.name}.getClassRef() id:'${this.id}', name:'${this.name}') ... `);\r\n\r\n    // interpret pseudoClass instances\r\n    // ... once again, we interpret this structure directly\r\n    //     to avoid reliance on the value-added classRef we are accessing \"in this method\" :-)\r\n    if (this.pseudoClass && this.pseudoClass.isInstance() ) {\r\n\r\n      // the pseudoClass master (it's type) is maintained by the pseudo constructor\r\n      // ... see: SmartClassRef.createSmartObject(namedParams)\r\n      const pseudoClass = this.pseudoClass.pseudoClassMaster;\r\n      check(pseudoClass, 'this pseudoClass instance has NO pseudoClassMaster reference ... you must create it with SmartClassRef.createSmartObject()');\r\n\r\n      // the smartClassRef is maintained by the SmartPkg package manager\r\n      const pseudoClassRef = pseudoClass.smartClassRef;\r\n      check(pseudoClassRef, 'this pseudoClass instance has NO smartClassRef reference ... it must be managed by a SmartPkg');\r\n\r\n      return pseudoClassRef;\r\n    }\r\n\r\n    // interpret a real class instances (the only other case)\r\n    // ... NOTE: even pseudoClass Masters revert to their real class :-)\r\n\r\n    // the real class is defined by standard JavaScript constructs\r\n    const realClass = this.constructor;\r\n\r\n    // the smartClassRef is maintained by the SmartPkg package manager\r\n    const realClassRef = realClass.smartClassRef;\r\n    check(realClassRef, 'this real class instance has NO smartClassRef reference ... it must be managed by a SmartPkg');\r\n\r\n    return realClassRef;\r\n  }\r\n\r\n  /**\r\n   * Return self's \"real\" class name, used for diagnostic purposes\r\n   * (such as logs and errors).  The name is unmangled (even in\r\n   * production builds).\r\n   *\r\n   * NOTE: Any usage that requires interpretation of pseudo classes,\r\n   *       should use:\r\n   *         this.getClassRef().getClassName()\r\n   *       This is only available once package containers have been\r\n   *       registered (e.g. pkgManager.registerPkg(smartPkg)!\r\n   *\r\n   * @returns {string} self's \"real\" class name.\r\n   */\r\n  diagClassName() {\r\n    return this.constructor.unmangledName || this.constructor.name;\r\n  }\r\n\r\n  /**\r\n   * A static method that reconstitutes class-based objects (with\r\n   * depth) from smartJSON.  By class-based objects we mean it will have\r\n   * all the behavior (i.e. methods and state) of the original object.\r\n   *\r\n   * @param {JSON} smartJSON - the smartJSON structure representing\r\n   * the object(s) to create.\r\n   *\r\n   * @param {function} [extraClassResolver] - an optional\r\n   * function to supplement the standard class resolver, used in\r\n   * hydrating self-referencing pseudoClasses found in SmartPkg (ex:\r\n   * collage referencing scene instances).\r\n   *\r\n   * @returns {smartObject} a newly instantiated class-based object\r\n   * from the supplied smartJSON.\r\n   *\r\n   * @throws {Error} an Error is thrown when the process could not\r\n   * successfully complete.\r\n   */\r\n  static fromSmartJSON(smartJSON, extraClassResolver) {\r\n\r\n    // NOTE: We do NOT validate any characteristic of our supplied smartJSON,\r\n    //       because the way in which this algorithm is invoked (recursively),\r\n    //       it can truly be ANY type of data!\r\n    //       As an example, a sub elm of JSON could be a number or a string.\r\n\r\n    // handle NO smartJSON\r\n    // ... simply pass it through (null, undefined, etc. ... even false is OK :-)\r\n    if (!smartJSON) {\r\n      return smartJSON;\r\n    }\r\n\r\n    // handle arrays ... simply recursively decode all array items\r\n    else if (Array.isArray(smartJSON)) {\r\n      return smartJSON.map( item => SmartModel.fromSmartJSON(item, extraClassResolver) );\r\n    }\r\n\r\n    // handle JSON objects\r\n    // ... two types (see below)\r\n    else if (isPlainObject(smartJSON)) {\r\n\r\n      // handle smartObjs (class-based object derivations of SmartModel)\r\n      if (smartJSON.smartType) {\r\n\r\n        // define our namedProps to feed into our constructor (from smartJSON),\r\n        // recursively resolving each ref into real class-based objects (as needed)\r\n        const namedProps = {};\r\n        for (const key in smartJSON) {\r\n          const val = smartJSON[key];\r\n\r\n          // bypass selected keywords that are NOT part of the constructor namedProps\r\n          if (key === 'smartType' || key === 'smartPkg' || key === 'isPseudoClassMaster') { // type info is for decoding only\r\n            continue;\r\n          }\r\n\r\n          // recursively resolve each val into a real class-based object\r\n          namedProps[key] = SmartModel.fromSmartJSON(val, extraClassResolver);\r\n        }\r\n\r\n        // determine the classRef (could be a real class or a pseudoClass)\r\n        const classRef = getClassRefFromSmartJSON(smartJSON, extraClassResolver);\r\n\r\n        // instantiate a real class-based object using our value-added constructor\r\n        // that handles BOTH real classes and pseudoClasses\r\n        return classRef.createSmartObject(namedProps);\r\n      }\r\n\r\n      // handle plain NON class-based objects\r\n      // ... simply decode each item recursively\r\n      else {\r\n        const plainObj = Object.entries(smartJSON).reduce( (accum, [subName, subRef]) => {\r\n          accum[subName] = SmartModel.fromSmartJSON(subRef, extraClassResolver) ;\r\n          return accum;\r\n        }, {} );\r\n        return plainObj;\r\n      }\r\n    }\r\n    \r\n    // all other types are assumed to be immutable primitives, and simply passed through :-)\r\n    // ... string, number, etc.\r\n    // ... ALSO passes through class-based objects that are pre-hydrated\r\n    //     USED in SmartPkg.fromSmartJSON(smartJSON) with it's 2-phase hydration\r\n    return smartJSON;\r\n  }\r\n\r\n\r\n  /**\r\n   * Create a deep copy of self that is up-to-date with the latest\r\n   * class versioning.\r\n   * \r\n   * Within this cloning process, object creation is still based on\r\n   * class instantiation.\r\n   * \r\n   * The hallmark of smartClone() is it is designed to generate deep\r\n   * copies of self that are up-to-date with the latest class\r\n   * versioning.\r\n   *\r\n   * - Class versioning can become out-of-sync when interactive edits\r\n   *   occur to the class master.\r\n   *   \r\n   * - Currently, this is only operational for pseudo classes.  Real\r\n   *   code-based class versioning is not currently tracked, and will\r\n   *   always indicate they are in-sync.\r\n   *\r\n   * INTERNAL NOTE: \"two-phase\" process\r\n   *\r\n   *   There is a very subtle (and powerful) characteristic of\r\n   *   smartClone() that can be confusing.  When cloning pseudoClass\r\n   *   INSTANCES, we need to pull in characteristics from BOTH\r\n   *   instance state and pseudo-class state.  This is accomplished\r\n   *   through a \"two-phase\" process, where smartClone() is invoked\r\n   *   twice.\r\n   *\r\n   *   To make sense of this, let's look a Scene object (a\r\n   *   pseudoClass).  A scene INSTANCE can reside in a collage, and if\r\n   *   the scene MASTER is updated, the collage reference to that\r\n   *   scene INSTANCE must be updated.\r\n   *\r\n   *   PHASE 1:\r\n   *    - scene.smartClone() is invoked\r\n   *    - the \"instance\" properties are accumulated [x,y]\r\n   *      ... these are the translation characteristics of where the\r\n   *          scene instance is placed in the collage\r\n   *      ... this is accomplished based on the dynamics of\r\n   *          this.getEncodingProps()\r\n   *    - the clonedCopy is requested via:\r\n   *      classRef.createSmartObject(namedProps) ... passing {x,y} as namedProps\r\n   *\r\n   *   PHASE 2:\r\n   *    - scene.smartClone({x,y}) is invoked a second time\r\n   *      * because createSmartObject() is processing a pseudoClass, \r\n   *        it issues another smartClone() request\r\n   *      * IMPORTANT: however, this time self is the pseudoClass MASTER\r\n   *                   NOT the pseudoClass INSTANCE (from Phase 1).\r\n   *      * IMPORTANT: and the overridingNamedProps param includes the\r\n   *                   {x,y} from Phase 1.\r\n   *    - the \"class\" properties are now accumulated [comps]\r\n   *      ... these are what makes the pseudoClass a class: \r\n   *          i.e. the components are part of the \"Scene\" pseudoClass!\r\n   *      ... this is accomplished based on the dynamics of\r\n   *          this.getEncodingProps()\r\n   *    - the clonedCopy is requested via:\r\n   *      classRef.createSmartObject(namedProps) ... passing {x,y,comps} as namedProps\r\n   *      * because the classRef is the \"real\" Scene class it is instantiate\r\n   *        using `new Scene(...)` semantics\r\n   *      * KOOL: we have accumulated BOTH the appropriate \"instance\" and \"class\" properties!!!\r\n   *\r\n   *\r\n   * NOTE: This algorithm is fully implemented within the SmartModel\r\n   *       base class.  With the polymorphic knowledge of which\r\n   *       properties to encode (see getEncodingProps()) it rarely\r\n   *       needs to be overwritten.\r\n   *\r\n   * @param {ObjectLiteral} [overridingNamedProps] - The optional\r\n   * named properties that when supplied will override the members of\r\n   * self that are to be deeply cloned.\r\n   *\r\n   * @returns {smartObject} a deep copy of self that is up-to-date\r\n   * with the latest class versioning.\r\n   */\r\n  smartClone(overridingNamedProps={}) {\r\n\r\n    // our type specific handler\r\n    // ... definition is close to usage, but cached for optimization (can be re-used by ANY instance)\r\n    const smartCloneRefHandler = handlerCache.smartCloneRefHandler = handlerCache.smartCloneRefHandler || createTypeRefHandler({\r\n      // pass through null/undefined references\r\n      handleNoRef: (noRef, accumClone) => noRef,\r\n      // pass through primitives ... clone is N/A because they are immutable\r\n      handlePrimitive: (primitiveRef, accumClone) => primitiveRef,\r\n      // encode all array items\r\n      handleArray: (arrRef, accumClone) => arrRef.map( item => smartCloneRefHandler(item) ),\r\n      // encode plain object\r\n      handlePlainObj: (plainObjRef, accumClone) => (\r\n        Object.entries(plainObjRef).reduce( (accum, [subRefName, subRef]) => {\r\n          accum[subRefName] = smartCloneRefHandler(subRef);\r\n          return accum;\r\n        }, {} )\r\n      ),\r\n      // encode SmartObjs smartClone()\r\n      handleSmartObj: (smartObjRef, accumClone) => smartObjRef.smartClone(),\r\n      // UNSUPPORTED: NON SmartObjects (not plain and not smart)\r\n      handleNonSmartObj(otherObjRef, accumClone) {\r\n        throw new Error(`***ERROR*** SmartObject.smartClone() traversal encountered an object reference of unsupported type: ${otherObjRef.constructor.name} :-(`);\r\n      },\r\n      // pass-through classes as-is (i.e. clone is N/A because they are immutable)\r\n      handleClass: (classRef, accumClone) => classRef,\r\n    });\r\n\r\n    // clone self's properties by recursively drilling through entire tree with depth\r\n    // ... recursion is handled by our internal smartCloneRefHandler() function\r\n    const clonedProps = this.encodingPropsReduce( (accumProps, propName, propValue, defaultValue) => {\r\n\r\n      // clone each prop ONLY if it is not specified in our overridingNamedProps param\r\n      if ( !overridingNamedProps.hasOwnProperty(propName) ) {\r\n        const clonedValue    = smartCloneRefHandler(propValue); // clone our propValue\r\n        accumProps[propName] = clonedValue;                     // accumulate our running clonedProps\r\n      }\r\n      return accumProps;\r\n\r\n    }, {}/*initialAccum*/);\r\n\r\n    // accumulate all namedProps for our constructor\r\n    // ... overridingNamedProps param take precedence\r\n    //     -and- supports overrides that are NOT part of our instance members\r\n    const namedProps = {...clonedProps, ...overridingNamedProps};\r\n    // console.log(`xx ${this.diagClassName()}.smartClone() instantiating new object with following params:\\n`, {clonedProps, overridingNamedProps, namedProps});\r\n\r\n    // instantiate a new copy of self (our cloned copy)\r\n    // NOTE: Our entire cloning and persistance architecture is based on\r\n    //       SmartModel constructors using named parameters!\r\n    // NOTE: We must use classRef.createSmartObject() to get the\r\n    //       correct result (picking up the correct instance\r\n    //       state and class state)\r\n    //       NOT: new this.constructor(namedProps)\r\n    //            ... see: \"two-phase\" NOTE (in self's JavaDoc)\r\n//  const clonedCopy = new this.constructor(namedProps);                 // NO\r\n    const clonedCopy = this.getClassRef().createSmartObject(namedProps); // YES\r\n\r\n    // that's all folks :-)\r\n    return clonedCopy;\r\n  } // end of ... smartClone() method\r\n\r\n} // end of ... SmartModel class\r\nSmartModel.unmangledName = 'SmartModel';\r\n\r\n\r\n//******************************************************************************\r\n//*** Specifications\r\n//******************************************************************************\r\n\r\n/**\r\n * @typedef {Object} smartObject\r\n *\r\n * smartObject is an object instance that is a SmartModel derivation.  It\r\n * has the following characteristics:\r\n *\r\n * - The class constructor employs namedProps.  This is KEY aspect to\r\n *   make persistence work, because it supports data-driven injection\r\n *   from smartJSON.\r\n */\r\n\r\n\r\n/**\r\n * @typedef {JSON} smartJSON\r\n * \r\n * smartJSON is a self-contained JSON structure that can be\r\n * re-constituted back into a class-based object representation.\r\n * \r\n * - it supports object containment (i.e. objects with depth),\r\n *   allowing an entire object tree to be  JSONized\r\n * \r\n * - it is used for BOTH persistence and functional state management\r\n *   (in redux).\r\n * \r\n * - it is created by:\r\n *   ```\r\n *   SmartModel.prototype.toSmartJSON()\r\n *   ```\r\n * \r\n * - it is used to reconstitute class-based objects, via:\r\n *   ```\r\n *   SmartModel.fromSmartJSON(smartJSON)\r\n *   ```\r\n */\r\n\r\n\r\n/**\r\n * @typedef {{width, height}} Size\r\n * \r\n * A `size` consisting of {width, height}.\r\n */\r\n\r\n\r\n/**\r\n * @typedef {ref} ObjectLiteral\r\n * \r\n * A plain object, such as an object literal ...  `{a: 1, b: 2}` used\r\n * in JSON structures, namedProps, etc.\r\n */\r\n\r\n\r\n\r\n//******************************************************************************\r\n//*** Internal Helper Functions\r\n//******************************************************************************\r\n\r\n/**\r\n * Return the classRef of the supplied smartJSON.\r\n *\r\n * @param {JSON} smartJSON - the smartJSON to interpret.\r\n *\r\n * @param {function} [extraClassResolver] - an optional\r\n * function to supplement the standard class resolver, used in\r\n * hydrating self-referencing pseudoClasses found in SmartPkg (ex:\r\n * collage referencing scene instances).\r\n *\r\n * @returns {SmartClassRef} the classRef of the supplied smartJSON\r\n *\r\n * @throws {Error} an Error is thrown when the class was not resolved.\r\n */\r\nfunction getClassRefFromSmartJSON(smartJSON, extraClassResolver) {\r\n\r\n  // glean our pkgId and className\r\n  const pkgId     = smartJSON.smartPkg;\r\n  const className = smartJSON.smartType;\r\n\r\n  // resolve our classRef\r\n  let classRef = null;\r\n\r\n  // ... use extraClassResolver (when supplied)\r\n  if (extraClassResolver) {\r\n    classRef = extraClassResolver(pkgId, className);\r\n    if (classRef) {\r\n      return classRef;\r\n    }\r\n  }\r\n\r\n  // ... use standard pkgManager class resolver\r\n  try {\r\n    classRef = pkgManager.getClassRef(pkgId, className);\r\n  }\r\n  catch (err) {\r\n    console.log(`***ERROR*** SmartModel.fromSmartJSON() could not resolve pkgId: ${pkgId} / className: ${className} \r\n... smartJSON: ${JSON.stringify(smartJSON, null, 2)}`);\r\n    throw err.defineAttemptingToMsg('hydrate smartObj (see logs for smartJson)');\r\n  }\r\n  return classRef;\r\n}\r\n\r\n/**\r\n * A static cache of all `createTypeRefHandler()` functions.  These\r\n * functions can be re-used for ANY SmartObject instance.  This cache\r\n * is used to support the preference of creating the functions in-line\r\n * (so as to live close to the usage code).\r\n */\r\nconst handlerCache = {\r\n  // [functName]: function,\r\n  // ...\r\n};\r\n","import SmartModel        from './SmartModel';\r\nimport verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\n\r\n/**\r\n * SmartPallet is an abstract base class representing the graphical\r\n * perspective that visualizes a system (either in part or whole).\r\n */\r\nexport default class SmartPallet extends SmartModel {\r\n\r\n  /**\r\n   * Create a SmartPallet.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this pallet.\r\n   * @param {string} [name=id] - the human interpretable name of this\r\n   * pallet (DEFAULT to id).\r\n   */\r\n  constructor({id, name, ...unknownArgs}={}) {\r\n    super({id, name});\r\n\r\n    // validate SmartPallet() constructor parameters\r\n    const check = verify.prefix('SmartPallet() constructor parameter violation: ');\r\n    // ... id/name validated by base class\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n  }\r\n\r\n  /**\r\n   * Get self's current size (dynamically calculated).\r\n   *\r\n   * @returns {Size} self's current size ... {width, height}.\r\n   */\r\n  getSize() {\r\n    throw new Error(`***ERROR*** SmartPallet pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.getSize() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n  /**\r\n   * Perform any static binding of self's size change (such as HTML or\r\n   * Konva bindings).\r\n   *\r\n   * @param {Size} oldSize - the previous size ... {width, height}.\r\n   * @param {Size} newSize - the new size ... {width, height}.\r\n   */\r\n  bindSizeChanges(oldSize, newSize) {\r\n    throw new Error(`***ERROR*** SmartPallet pseudo-interface-violation [id:${this.id}]: ${this.diagClassName()}.bindSizeChanges() is an abstract method that MUST BE implemented!`);\r\n  }\r\n\r\n}\r\nSmartPallet.unmangledName = 'SmartPallet';\r\n","//***\r\n//*** Various Konva utils\r\n//***\r\n\r\n/**\r\n * Return the supplied node's ancestor that is in the top-level Layer.\r\n */\r\nexport function ancestorOfLayer(node) {\r\n  const parentNode = node.getParent();\r\n  return parentNode.getClassName() === 'Layer' ? node : ancestorOfLayer(parentNode);\r\n}\r\n\r\n\r\n//***\r\n//*** Useful Defined Constants\r\n//***\r\n\r\nexport const containerSizeFudge = 10; // container size fudge factor increase (for good measure)\r\n","import verify     from './verify';\r\nimport {isString} from 'util/typeCheck';\r\n\r\n/*--------------------------------------------------------------------------------\r\n   Simple logging utility with the following features:\r\n   - can be enabled/disabled at run-time\r\n   - all logging probes are prefixed\r\n   - a simple layer on top of console.log()\r\n\r\n   USAGE:\r\n     import {createLogger} from 'util/logger';\r\n     ...\r\n     const log = createLogger('*** My Prefix *** ').enable();\r\n\r\n     ... log('now is the time', myData); // emits: *** My Prefix *** now is the time\r\n\r\n   API:\r\n     log(msg [,obj]): void       ... conditionally log probe when enabled\r\n     log.force(msg [,obj]): void ... unconditionally log probe\r\n     log.isEnabled(): true/false ... is logging enabled or disabled\r\n     log.enable():  log          ... enable logging\r\n     log.disable(): log          ... disable logging\r\n   --------------------------------------------------------------------------------*/\r\n\r\nexport function createLogger(prefix) {\r\n\r\n  // validate parameters\r\n  const check = verify.prefix('createLogger() parameter violation: ');\r\n  check(prefix,           'prefix is required');\r\n  check(isString(prefix), 'prefix must be a string');\r\n\r\n  // our logger is disabled by default\r\n  let _enabled = false;\r\n\r\n  // create our new logger\r\n  const logger = function(msg, obj) { // our primary logging function\r\n    if (_enabled) {\r\n      logger.force(msg, obj);\r\n    }\r\n  };\r\n\r\n  // inject additional API\r\n\r\n  logger.force = (msg, obj) => {\r\n    msg = prefix + msg;\r\n    if (obj) {\r\n      console.log(msg, obj);\r\n    }\r\n    else {\r\n      console.log(msg);\r\n    }\r\n  };\r\n\r\n  logger.isEnabled = () => _enabled;\r\n\r\n  logger.enable = () => {\r\n    _enabled = true;\r\n    logger('enabling logging');\r\n    return logger;\r\n  };\r\n\r\n  logger.disable = () => {\r\n    logger('disabling logging');\r\n    _enabled = false;\r\n    return logger;\r\n  };\r\n\r\n  // thats all folks\r\n  return logger;\r\n}\r\n","import verify          from 'util/verify';\r\nimport {isClass,\r\n        isString}      from 'util/typeCheck';\r\nimport {createLogger}  from 'util/logger';\r\n\r\n// our internal diagnostic logger (normally disabled)\r\nconst log = createLogger('***DIAG*** SmartClassRef:').disable();\r\n\r\n/**\r\n * SmartClassRef is a meta object that accommodates type/class\r\n * information for ALL smartObjects, unifying both real classes and\r\n * pseudo classes!\r\n *\r\n * SmartClassRef meta objects can represent either:\r\n *\r\n *  - a real class ... of type SmartModel whose constructor supports\r\n *    namedProps,\r\n * \r\n *  - or a pseudoClass ... an object instance that logically\r\n *    represents a class.  These are resource-based objects that can\r\n *    be dynamically edited (through the graphical editor), and yet\r\n *    can be \"instantiated\" as items of other objects!  Please refer\r\n *    to PseudoClass.\r\n *\r\n * A `smartClassRef` property is dynamically attached to all classes\r\n * (both real and pseudoClass) by the SmartPkg package manager.\r\n *\r\n * IMPORTANT: This class verifies the existence of class.unmangledName!\r\n * - class name is crucial for our persistence (hydration invokes\r\n *   constructor matching registered classes)\r\n * - the standard class.name is mangled in our production build (ex:\r\n *   yielding 't' for 'SmartComp')\r\n * - this is a central spot that will highlight issues very early\r\n */\r\nexport default class SmartClassRef {\r\n\r\n  /**\r\n   * Create a SmartClassRef.\r\n   *\r\n   * @param {classRef} classRef - the class on which behalf we operate\r\n   * (either a real class or a pseudoClass).\r\n   *\r\n   * @param {string} pkgId - the package ID this class belongs to.\r\n   */\r\n  constructor(classRef, pkgId) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix('SmartClassRef() constructor parameter violation: ');\r\n\r\n    // ... classRef (more validation below)\r\n    check(classRef,          'classRef is required');\r\n\r\n    // ... pkgId\r\n    check(pkgId,           'pkgId is required');\r\n    check(isString(pkgId), 'pkgId must be a string');\r\n\r\n\r\n    // retain information about the supplied classRef\r\n    // ... a realClass\r\n    if (isClass(classRef)) {\r\n      this.realClass = classRef;\r\n\r\n      // verify there is an unmangledName property (see IMPORTANT above)\r\n      // NOTE: MUST USE hasOwnProperty() because static class references\r\n      //       will walk the hierarchy chain (as of ES6 classes)\r\n      //       We MUST insure this concrete class has defined it's own\r\n      //       unique unmangledName!!\r\n      check(classRef.hasOwnProperty('unmangledName'), `real class ${classRef.name} MUST have an \"unmangledName\" property (supporting persistence in obfuscated production build)`);\r\n\r\n    }\r\n    // ... a pseudoClass MASTER (i.e. a logical type)\r\n    else if (classRef.pseudoClass && classRef.pseudoClass.isType()) {\r\n      this.pseudoClassContainer = classRef;\r\n    }\r\n    else {\r\n      check(false, 'classRef must be a real class -or- pseudoClass');\r\n    }\r\n\r\n    // retain the supplied pkgId\r\n    this.pkgId = pkgId;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return an indicator as to whether self is a real class\r\n   *\r\n   * NOTE: This method should have minimal use (the whole idea of self's\r\n   * class is to remove conditional logic)!\r\n   *\r\n   * @returns {boolean} true: a realClass, false: a pseudoClass\r\n   */\r\n  isClass() {\r\n    return this.realClass ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is a pseudo class\r\n   *\r\n   * NOTE: This method should have minimal use (the whole idea of self's\r\n   * class is to remove conditional logic)!\r\n   *\r\n   * @returns {boolean} true: a pseudoClass, false: a realClass\r\n   */\r\n  isPseudoClass() {\r\n    return this.pseudoClassContainer ? true : false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return the class name of self.\r\n   * \r\n   * The class name is interpreted for BOTH real classes and\r\n   * pseudoClasses.\r\n   *\r\n   * For real classes, the name is never mangled, from an\r\n   * obfuscated production build.\r\n   *\r\n   * @returns {string} the class name.\r\n   */\r\n  getClassName() {\r\n    // interpret a pseudoClass type\r\n    // ... self is a pseudoClass MASTER (i.e. a logical type)\r\n    if (this.pseudoClassContainer) {\r\n      return this.pseudoClassContainer.id;\r\n    }\r\n\r\n    // interpret our real class name\r\n    return this.realClass.unmangledName || this.realClass.name;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return the package ID (SmartPkg) from which this classRef is\r\n   * managed/distributed.\r\n   *\r\n   * @returns {string} the class package ID.\r\n   */\r\n  getClassPkgId() {\r\n    return this.pkgId;\r\n  }\r\n\r\n\r\n  /**\r\n   * Return the fully qualified class name of self, including the\r\n   * package ID and class name ... 'com.acme/Pump1'.\r\n   *\r\n   * @returns {string} self's fully qualified 'pkgId/className'\r\n   */\r\n  getFullClassName() {\r\n    return `${this.getClassPkgId()}/${this.getClassName()}`;\r\n  }\r\n\r\n  /**\r\n   * Return the current crc hash for self's class, considered a class\r\n   * version, used in detecting out-of-sync classes (see\r\n   * SmartModel.isClassOutOfSync()).\r\n   *\r\n   * Currently, this is only operational for pseudo classes.  Real\r\n   * code-based class versioning is not currently tracked, and will\r\n   * always return a zero (0), indicating they are in-sync.\r\n   *\r\n   * @returns {number} self's class versioning crc hash.\r\n   */\r\n  getClassVersionCrc() {\r\n    // interpret a pseudoClass type\r\n    // ... self is a pseudoClass MASTER (i.e. a logical type)\r\n    if (this.pseudoClassContainer) {\r\n      return this.pseudoClassContainer.getCrc();\r\n    }\r\n\r\n    // interpret our real class name\r\n    // ... we don't currently track versioning of real classes (every class version is zero)\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * A value-added constructor that creates smartObjects of this type.\r\n   *\r\n   * These newly instantiated objects represent SmartModel\r\n   * derivations, whose constructors supports namedParams.\r\n   *\r\n   * @param {ObjectLiteral} namedParams - The named properties used to\r\n   * passed into self's constructor.\r\n   *\r\n   * @returns {smartObject} a newly instantiated class-based object of\r\n   * this type, initialized with `namedParams`.\r\n   */\r\n  createSmartObject(namedParams) {\r\n\r\n    let newObj = null;\r\n    let msgQualifier = '';\r\n\r\n    //***\r\n    //*** handle real classes\r\n    //***\r\n\r\n    if (this.realClass) {\r\n      msgQualifier = 'real';\r\n      newObj = new this.realClass(namedParams);\r\n    }\r\n\r\n    //***\r\n    //*** handle pseudo classes\r\n    //***\r\n\r\n    else {\r\n      msgQualifier = 'pseudo';\r\n\r\n      const pseudoClassContainer = this.pseudoClassContainer;\r\n\r\n      // clone the pseudoClass (with depth), overriding supplied namedParams\r\n      newObj = pseudoClassContainer.smartClone(namedParams);\r\n\r\n      // AI: some of the following demarcations may have some \"logical\" duplication in it ... analyze this when the dust settles\r\n\r\n      // mark the cloned object as an instance (NOT a type)\r\n      newObj.pseudoClass.id   = pseudoClassContainer.id;\r\n      newObj.pseudoClass.name = `a pseudoClass instance of type: '${pseudoClassContainer.id}'`; // for good measure\r\n\r\n      // retain the pseudoClassMaster\r\n      // ... used to locate the pseudoClass from which an object was created :-)\r\n      // ... see: SmartModel.getClassRef()\r\n      newObj.pseudoClass.pseudoClassMaster = pseudoClassContainer;\r\n\r\n      // retain the version crc hash of the pseudoClassMaster used in our construction\r\n      // ... used to detect out-of-sync class when dynamic classes change during interactive edit session\r\n      // ... see: SM.isClassOutOfSync()\r\n      newObj.pseudoClass.versionCrcUsedInCreation = pseudoClassContainer.getCrc();\r\n    }\r\n\r\n    log(`createSmartObject() created new object from ${msgQualifier} class: '${this.getFullClassName()}' ... using namedParams: `, {namedParams, newObj});\r\n    return newObj;\r\n  }\r\n\r\n}\r\n","import SmartPallet          from './SmartPallet';\r\nimport Scene                from './Scene';\r\nimport SmartClassRef        from './SmartClassRef';\r\nimport {containerSizeFudge} from './konvaUtil';\r\n\r\nimport verify               from 'util/verify';\r\nimport checkUnknownArgs     from 'util/checkUnknownArgs';\r\n\r\n\r\n/**\r\n * CompRef (a SmartPallet derivation) is a component classRef\r\n * container that can be packaged (in SmartPkg) and\r\n * displayed/visualized.  It wraps either a real class [a SmartComp\r\n * derivation], or a resource-based pseudoClass [a DynamicComp].\r\n */\r\nexport default class CompRef extends SmartPallet {\r\n\r\n  /**\r\n   * Create a CompRef.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this compRef.\r\n   * @param {string} [name=id] - The name of this compRef (DEFAULT to id).\r\n   * @param {SmartClassRef} compClassRef - the compClassRef visualized by this\r\n   * compRef.\r\n   */\r\n  constructor({id, name, compClassRef, ...unknownArgs}={}) {\r\n    super({id, name});\r\n\r\n    // validate CompRef() constructor parameters\r\n    const check = verify.prefix(`${this.diagClassName()}(id:'${id}', name:'${name}') constructor parameter violation: `);\r\n\r\n    // ... id/name validated by base class\r\n\r\n    // ... compClassRef\r\n    check(compClassRef,                          'compClassRef is required');\r\n    check(compClassRef instanceof SmartClassRef, 'compClassRef must be a SmartClassRef type');\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // retain derivation-specific parameters in self\r\n    // this.compClassRef = compClassRef; // ... currently no need for this\r\n\r\n\r\n    //***\r\n    //*** establish the structure that gives visibility to our component\r\n    //*** ... a scene with a single component in it\r\n    //***\r\n\r\n    // instantiate a single component from self's class\r\n    // ... this is what we will visualize :-)\r\n    const compName = compClassRef.getClassName(compClassRef);\r\n    this.comp      = compClassRef.createSmartObject({id: `comp-${compName}`, // I think we are OK ... hopefully no other param context is needed\r\n                                                     x:  containerSizeFudge,\r\n                                                     y:  containerSizeFudge});\r\n\r\n    // wrap our single component in a scene (see NOTE above)\r\n    this.scene = new Scene({\r\n      id: `view-${compName}`,\r\n      comps: [this.comp],\r\n    });\r\n\r\n    // maintain our parentage\r\n    // ... our comp parentage is maintained by the Scene constructor (above)\r\n    this.scene.setParent(this);\r\n  }\r\n\r\n  /**\r\n   * Return the component instance being visualized.  This API is\r\n   * specific to CompRef.  It is promoted as the target of our\r\n   * visualized tab (see: TabControllerCompRef).\r\n   *\r\n   * @returns {SmartComp} the component instance being visualized via\r\n   * this CompRef.\r\n   */\r\n  getCompInstance() {\r\n    return this.comp;\r\n  }\r\n\r\n  // support persistance by encoding needed props of self\r\n  getEncodingProps() { \r\n    // AI: currently class-based CompRef are NOT persisted\r\n    //     ... hard-coded assumption (as of now) found in SmartComp.canHandleDispMode(dispMode)\r\n    //     ... we will have to deal with persistence once we introduce resource-based DynamicComp pseudoClass\r\n    return [...super.getEncodingProps(), ...['compClassRef']];\r\n  }\r\n\r\n  \r\n  /**\r\n   * Mount the visuals of this compRef, binding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * Prior to `mount()` execution, the visualize-it object\r\n   * representation is very lightweight.\r\n   *\r\n   * @param {Konva.Stage} containingKonvaStage - The container of\r\n   * this compRef (a Konva.Stage).\r\n   */\r\n  mount(containingKonvaStage) {\r\n    // retain containingKonvaStage for event handling\r\n    this.containingKonvaStage = containingKonvaStage;\r\n\r\n    // propagate this request to our contained scene\r\n    this.scene.mount(containingKonvaStage);\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is mounted (i.e. bound to the Konva graphics).\r\n   *\r\n   * @returns {boolean} `true`: self is mounted, `false` otherwise\r\n   */\r\n  isMounted() {\r\n    return this.containingKonvaStage ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Unmount the visuals of this compRef, unbinding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * @param {boolean} [konvaPreDestroyed=false] - an internal\r\n   * parameter that indicates if konva nodes have already been\r\n   * destroyed (when a parent Konva.Node has already issued the\r\n   * konvaNode.destroy()).\r\n   */\r\n  unmount(konvaPreDestroyed=false) {\r\n    // clear our konva state (established in our mount())\r\n    this.containingKonvaStage = null;\r\n    \r\n    // propagate request into our children\r\n    this.scene.unmount(konvaPreDestroyed);\r\n  }\r\n\r\n\r\n  /**\r\n   * Get self's current size (dynamically calculated).\r\n   *\r\n   * @returns {Size} self's current size ... {width, height}.\r\n   */\r\n  getSize() {\r\n    // cached size takes precedence\r\n    // ... this sizeCache will be re-set whenever size has the potential of changing:\r\n    //     - both in our initial mount (replacing \"approximation\" with \"exact\" size)\r\n    //     - and during interactive edit changes (reflecting an updated size)\r\n    // ... see: SmartModel.trickleUpChange()\r\n    if (this.sizeCache) {\r\n      return this.sizeCache;\r\n    }\r\n\r\n    // recalculate our size\r\n    // KEY: we force the scene to recalculate it's size\r\n    //      ... by clearing it's sizeCache\r\n    //      BECAUSE our sizeCache has NOT been established (see above)\r\n    //      ... either first time, or something has changed\r\n    this.scene.sizeCache = undefined;\r\n    this.sizeCache = this.scene.getSize(); // propagate this request to our contained scene\r\n    return this.sizeCache;\r\n  }\r\n\r\n  /**\r\n   * Perform any static binding of self's size change (such as HTML or\r\n   * Konva bindings).\r\n   *\r\n   * @param {Size} oldSize - the previous size ... {width, height}.\r\n   * @param {Size} newSize - the new size ... {width, height}.\r\n   */\r\n  bindSizeChanges(oldSize, newSize) {\r\n    // propagate this request to our contained scene\r\n    this.scene.bindSizeChanges(oldSize, newSize);\r\n  }\r\n\r\n}\r\nCompRef.unmangledName = 'CompRef';\r\n","import React                    from 'react';\r\nimport PropTypes                from 'prop-types';\r\n\r\nimport {useDispatch}            from 'react-redux';\r\nimport {useFassets}             from 'feature-u';\r\nimport {useSelector,\r\n        shallowEqual}           from 'react-redux';\r\n\r\nimport {tabRegistry,\r\n        TabControllerScene,\r\n        TabControllerCollage,\r\n        TabControllerCompRef}   from 'features/xtra';\r\n\r\nimport genDualClickHandler      from 'util/genDualClickHandler';\r\nimport {createLogger}           from 'util/logger';\r\nimport {isPlainObject,\r\n        isSmartObject,\r\n        isClass}                from 'util/typeCheck';\r\n\r\nimport Scene                    from 'core/Scene';\r\nimport Collage                  from 'core/Collage';\r\nimport CompRef                  from 'core/CompRef';\r\nimport SmartClassRef            from 'core/SmartClassRef';\r\n\r\nimport {LeftNavCollapsibleItem} from 'features/xtra';\r\nimport ExpandLessIcon           from '@material-ui/icons/ExpandMore';   // in effect WHEN EXPANDED  ... i.e. clicking will collapse\r\nimport ExpandMoreIcon           from '@material-ui/icons/ChevronRight'; // in effect WHEN COLLAPSED ... i.e. clicking will expand\r\nimport TreeItem                 from '@material-ui/lab/TreeItem';\r\nimport TreeView                 from '@material-ui/lab/TreeView';\r\nimport {makeStyles}             from '@material-ui/core/styles';\r\n\r\n\r\n// our internal diagnostic logger (normally disabled)\r\nconst log = createLogger('***DIAG*** <LeftNavMenuPallet> ... ').disable();\r\n\r\n\r\n/**\r\n * The top-level left-nav menu pallet visualizing the supplied SmartPkg.\r\n */\r\nfunction LeftNavMenuPallet({smartPkg}) {\r\n\r\n  const classes     = useStyles();\r\n  const dispatch    = useDispatch();\r\n  const activateTab = useFassets('actions.activateTab');\r\n\r\n  // PERF: consider useCallback()\r\n  //       HOWEVER not really needed (I THINK)\r\n  //       ... due to the top-level memoization of LeftNavMenuPallet\r\n  // NOTE: technically 2nd param (tabName) is NOT needed, but kept for diagnostic logging\r\n  const handleActivateTab = (tabId, tabName, preview) => {\r\n    log(`handleActivateTab( tabId:'${tabId}', tabName:'${tabName}', preview=${preview} )`);\r\n    dispatch( activateTab(tabId, preview) );\r\n  };\r\n\r\n  const dualHandleActivateTab = genDualClickHandler(\r\n    (tabId, tabName) => handleActivateTab(tabId, tabName, true), // singleClick: preview   tab ... preview is true\r\n    (tabId, tabName) => handleActivateTab(tabId, tabName, false) // doubleClick: permanent tab ... preview is false\r\n  );\r\n\r\n  const fassets = useFassets();\r\n  const inSync  = useSelector((appState) => fassets.sel.isEPkgInSync(appState, smartPkg.getEPkgId()), shallowEqual); // AI: see note on shallowEqual (below)\r\n  const name    = smartPkg.getPkgName() + (inSync ? '' : ' **'); // AI: consider color too\r\n\r\n  // render our TreeView/TreeItem generation process driven by smartPkg content!\r\n  log(`rendering top-level content for smartPkg.id: ${smartPkg.id} ... expecting ONE TIME (for this entry)`);\r\n  // console.log(`xx rendering top-level <LeftNavMenuPallet> content for smartPkg.id: ${smartPkg.id} ... expecting ONE TIME (for this entry)`);\r\n  return (\r\n    <LeftNavCollapsibleItem name={name}>\r\n      <TreeView className={classes.root}\r\n                defaultCollapseIcon={<ExpandLessIcon/>}\r\n                defaultExpandIcon={<ExpandMoreIcon/>}>\r\n        { genTreeItems(smartPkg, dualHandleActivateTab) }\r\n      </TreeView>\r\n    </LeftNavCollapsibleItem>\r\n  );\r\n\r\n}\r\n\r\n// props validation\r\nLeftNavMenuPallet.propTypes = {\r\n  smartPkg: PropTypes.object.isRequired, // a SmartPkg object\r\n};\r\n\r\n// PERF: memo is critical (re-render is frequent and we do a lot of processing to generate our render)\r\n//       - bypasses renderer if props are the same (can override shallow comparison with a second fn param to memo()\r\n//       - also still allows re-render on hooks direction\r\nexport default React.memo(LeftNavMenuPallet);\r\n\r\n// styling\r\nconst useStyles = makeStyles( theme => ({\r\n  root: {\r\n    // height: 216, // WowZee: Omitting height FIXED the tree, allowing it's height to grow dynamically\r\n    flexGrow: 1,\r\n    maxWidth: 400,\r\n  },\r\n}) );\r\n\r\n\r\n// generate TreeItem structure (with depth) driven from the supplied smartPkg\r\nfunction genTreeItems(smartPkg, handleActivateTab) {\r\n\r\n  // recursive accumulation of all TreeItems (returns DOM Array)\r\n  function accumTreeItems(entry, accumulativeId=smartPkg.getPkgId()) {\r\n\r\n    // for plain objects, each member is a directory node\r\n    if (isPlainObject(entry)) {\r\n\r\n      const directoryAccum = [];\r\n\r\n      // pass through through all directory nodes (object members),\r\n      // ... generated a TreeItem directory node\r\n      // ... and recurse into each\r\n      for (const dirName in entry) {\r\n        const dirContent = entry[dirName];\r\n\r\n        const id = `${accumulativeId}-${dirName}`;\r\n\r\n        log(`genTreeItems(): TreeItem directory node: ${dirName}`);\r\n        directoryAccum.push((\r\n          <TreeItem key={id}\r\n                    nodeId={id}\r\n                    label={dirName}>\r\n            {accumTreeItems(dirContent, id)}\r\n          </TreeItem>\r\n        ));\r\n      }\r\n\r\n      return directoryAccum;\r\n    }\r\n\r\n    // for array entries\r\n    else if (Array.isArray(entry)) {\r\n\r\n      const entryAccum = entry.map( (arrItem) => {\r\n\r\n        // normally this is a smartObj ... generate entry to be displayed in our tabManager\r\n        if (isSmartObject(arrItem)) {\r\n\r\n          const smartObj = arrItem;\r\n          const nodeId   = `${accumulativeId}-${smartObj.id}`;\r\n\r\n          // register this entry to our tabManager (allowing it to be visualized)\r\n          let tabController = null;\r\n          if (smartObj instanceof Scene) {\r\n            tabController = new TabControllerScene(nodeId, smartObj.name, smartObj);\r\n          }\r\n          else if (smartObj instanceof Collage) {\r\n            tabController = new TabControllerCollage(nodeId, smartObj.name, smartObj);\r\n          }\r\n          else {\r\n            const errMsg = `***ERROR*** <LeftNavMenuPallet> found UNSUPPORTED smartObj entry (under accumulativeId: ${nodeId})  ... must be a Scene or Collage ... see logs for entry`\r\n            console.error(errMsg, {smartObj});\r\n            throw new Error(errMsg);\r\n          }\r\n          tabRegistry.registerTab(tabController);\r\n\r\n          log(`genTreeItems(): TreeItem tabManager node ... nodeId: ${nodeId}`);\r\n          return (\r\n            <SmartTreeItem key={nodeId}\r\n                           nodeId={nodeId}\r\n                           ePkg={smartObj}\r\n                           onClick={() => handleActivateTab(nodeId, smartObj.name)}/>\r\n          );\r\n        }\r\n\r\n        // can be a real class reference\r\n        else if (isClass(arrItem)) {\r\n          const compClass = arrItem;\r\n\r\n          // create our CompRef HERE, PRETENDING it was already in the smartPkg :-)\r\n          // ... ?? ultimately this will be accomplished at the time we are creating our SmartPkg entries\r\n          const compClassRef = new SmartClassRef(compClass, smartPkg.getPkgId());\r\n          const compName     = compClassRef.getClassName();\r\n          const nodeId       = `${accumulativeId}-${compName}`;\r\n          const compRef      = new CompRef({id:compName, name:compName, compClassRef});\r\n          compRef.setParent(smartPkg);\r\n          // AI: bit of hackery follows:\r\n          compRef.markAsPkgEntry(); // HACK: fixes error when expanding LeftNav Comp (rendering <SmartTreeItem> BELOW) ... Error: An error occurred while selecting the store state: ***ERROR*** CompRef.getEPkgId() [id:Valve2]: self is NOT an EPkg!\r\n          compRef.getCompInstance().markAsPkgEntry(); // HACK: fixes error on initial display of Comp in Tab (rendering <UndoRedoTool> in <VitToolBar> ... Error: ***ERROR*** Valve1.getEPkgId() [id:comp-Valve1]: self is NOT an EPkg!\r\n          compRef.resetBaseCrc(); // HACK: fixes Comp starting out as out-of-sync (LeftNav and Tab)\r\n          compRef.getCompInstance().resetBaseCrc(); // HACK: fixes Comp starting out as out-of-sync (Tab)\r\n\r\n          // register this entry to our tabManager (allowing it to be visualized)\r\n          tabRegistry.registerTab( new TabControllerCompRef(nodeId, compName, compRef) );\r\n          \r\n          log(`genTreeItems(): TreeItem tabManager node ... nodeId: ${nodeId}`);\r\n          return (\r\n            <SmartTreeItem key={nodeId}\r\n                           nodeId={nodeId}\r\n                           ePkg={compRef}\r\n                           onClick={() => handleActivateTab(nodeId, compName)}/>\r\n          );\r\n\r\n        }\r\n\r\n        // can be a nested sub-directory (mixed in with our tab activation entries)\r\n        else if (isPlainObject(arrItem)) {\r\n          return accumTreeItems(arrItem, accumulativeId);\r\n        }\r\n\r\n        // other array items are NOT supported (should not happen - defensive only)\r\n        else {\r\n          const errMsg = `***ERROR*** <LeftNavMenuPallet> found UNSUPPORTED array entry (under accumulativeId: ${accumulativeId})  ... must be a smartObj or plain nested directory object ... see logs for entry`\r\n          console.error(errMsg, {arrItem});\r\n          throw new Error(errMsg);\r\n        }\r\n      });\r\n\r\n      return entryAccum;\r\n    }\r\n\r\n    // other entries are NOT supported (should not happen - defensive only)\r\n    else {\r\n      const errMsg = `***ERROR*** <LeftNavMenuPallet> found UNSUPPORTED SmartPkg entry (under accumulativeId: ${accumulativeId})  ... must be a plain directory object or an array of smartObjs ... see logs for entry`\r\n      console.error(errMsg, {entry});\r\n      throw new Error(errMsg);\r\n    }\r\n\r\n  }\r\n\r\n  // invoke our recursive routine\r\n  return accumTreeItems(smartPkg.entries);\r\n}\r\n\r\n\r\n/**\r\n * <SmartTreeItem> is an `<TreeItem>` wrapper that employs redux state\r\n * for various artifacts which triggers appropriate refreshes\r\n * dynamically.\r\n *\r\n * NOTE: This component re-renders on parent re-expansion ... however\r\n *       I think this is due to the architecture of the MUI TreeItem!\r\n */\r\nfunction SmartTreeItem({nodeId, ePkg, onClick}) {\r\n  const fassets   = useFassets();\r\n  // AI: Don't understand: Why by just adding this selector, it renders 100% of the time?\r\n  //    ... should only re-render when inSync value changes\r\n  //        ANSWER: - has to do with useSelector === semantics HOWEVER I would expect true/false to ALWAYS be ===\r\n  //                  ... https://thoughtbot.com/blog/using-redux-with-react-hooks\r\n  //                  ... https://react-redux.js.org/next/api/hooks#equality-comparisons-and-updates\r\n  //                - for now, I used the shallowEqual\r\n  //                - BUT I REALLY DON'T UNDERSTAND THIS\r\n//const inSync = useSelector((appState) => fassets.sel.isEPkgInSync(appState, ePkg.getEPkgId()), [fassets]);    // AI: works but way to many unneeded renders\r\n  const inSync = useSelector((appState) => fassets.sel.isEPkgInSync(appState, ePkg.getEPkgId()), shallowEqual); // AI: shallowEqual\r\n\r\n  const label = ePkg.getName() + (inSync ? '' : ' **'); // AI: consider color too\r\n  // console.log(`xx rendering child <SmartTreeItem label=\"${label}\"> ... inSync: ${inSync} ... hopefully we can trigger re-renders on this`);\r\n  return (\r\n    <TreeItem {...{nodeId, label, onClick}}/>\r\n  )\r\n}\r\n\r\n// props validation\r\nSmartTreeItem.propTypes = {\r\n  nodeId:   PropTypes.string.isRequired,\r\n  ePkg:     PropTypes.object.isRequired,\r\n  onClick:  PropTypes.func.isRequired,\r\n};\r\n","/**\r\n * genDualClickHandler is a generator function that supports BOTH the\r\n * registration of single/double click handlers.\r\n *\r\n * This is a work-around hack for the LACK of support from React for\r\n * dual single/double click handler!!\r\n * \r\n * React currently support both `onClick` and `onDoubleClick` event\r\n * handlers.  However when BOTH are needed (i.e. registered) on the\r\n * same element, BOTH are fired (`onClick` multiple times, and\r\n * `onDoubleClick` for the double click).\r\n *\r\n * React has really dropped the ball on this, as many threads state\r\n * they are doing the right thing, because `onClick` is **NOT** an\r\n * `onSingleClick`, and that clients should do the kind of HACK found\r\n * here!\r\n\r\n * While it is true that `onClick` is NOT an `onSingleClick`, **THE\r\n * OBVIOUS ANSWER** is for them to **SUPPORT** an `onSingleClick`\r\n * handler, and simplify everyone's life, rather than expecting\r\n * clients to propagated hacks like this!!! _enough ranting_.\r\n *\r\n * @param {function} onSingleClick the callback hook to invoke when a\r\n * **single click** occurs.\r\n *\r\n * @param {function} onDoubleClick the callback hook to invoke when a\r\n * **double click** occurs.\r\n *\r\n * @param {int} [delay=250] the optional delay (in mills) to wait for\r\n * the second click ... DEFAULT: 250.\r\n *\r\n * @returns {function} the generated handler to register to React's\r\n * `onClick` event handler.\r\n */\r\n\r\nexport default function genDualClickHandler(onSingleClick, onDoubleClick, delay=250) {\r\n\r\n  let timeoutID = null;\r\n\r\n  return function (...rest) { // onClick will pass event, but use ...rest to support any signature\r\n    if (!timeoutID) { // FIRST CLICK: create timeout (waiting for potential second click)\r\n      timeoutID = setTimeout(function () {\r\n        onSingleClick(...rest); // invoke onSingleClick() - timeout has passed (with no additional clicks)\r\n        timeoutID = null;       // reset our timeout indicator\r\n      }, delay);\r\n    }\r\n    else { // SECOND CLICK (within timeout period)\r\n      clearTimeout(timeoutID); // clear our timeout\r\n      timeoutID = null;        // reset our timeout indicator\r\n      onDoubleClick(...rest);  // invoke onDoubleClick(event)\r\n    }\r\n  };\r\n\r\n}\r\n","import SmartModel        from './SmartModel';\r\nimport SmartClassRef     from './SmartClassRef';\r\nimport PseudoClass       from './PseudoClass';\r\nimport {isPlainObject,\r\n        isSmartObject,\r\n        isClass}         from 'util/typeCheck';\r\nimport verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\nimport {changeManager}   from 'features/xtra';\r\n\r\n/**\r\n * SmartPkg models visualize-it packages.\r\n *\r\n * SmartPkgs:\r\n *   - are cataloged by pkgManager\r\n *     ... the basis resolving classRefs in our persistence model\r\n *   - and optionally viewed in the LeftNav\r\n *     ... the basis of the builder app management (viewing/editing\r\n *         entries, including entries in other entries, etc.)\r\n *     ... LeftNav exposure is optional because some packages are NOT visual\r\n *         (such as \"core\") ... just needed for pkgManager promotion\r\n *\r\n * SmartPkg is a concrete class that can model ANY visualize-it package:\r\n *   - a component package (holding component definitions)\r\n *   - a system package (holding scenes and collages)\r\n *   - even a hybrid package (combining both component and system resources)\r\n *\r\n * A SmartPkg can represent EITHER:\r\n *   - code-based packages (containing class references)\r\n *     * NOT editable (unless we decide to dynamically manage and persist code)\r\n *     * NOT persistable ... save/retrieve (ditto)\r\n *   - resource-based packages (with NO class references)\r\n *     * editable\r\n *     * persistable ... save/retrieve\r\n *\r\n * Entries from one package can have dependencies on other external\r\n * packages (for example, a \"system\" package may contain component\r\n * instances from classes defined in a \"component\" package).\r\n *\r\n * All SmartPkgs have an ID (pkgId):\r\n *   - the ID qualifies the package through which classRefs are distributed\r\n *     * so the pkgId belongs to classRefs ONLY, NOT entries\r\n *       ... because entries are NOT shared across packages\r\n *     * SmartPkg will auto-inject it's package ID in all classRefs\r\n *       it contains!\r\n *       - this allows our persistence process to record BOTH the\r\n *         pkgId and className from which each object is\r\n *         instantiated\r\n *         ... allowing it to be re-hydrated (because we can locate the\r\n *             class - via pkgManager)\r\n *   - object instances contained in a package can be based on classes\r\n *     from external packages (i.e. dependent packages)\r\n *     ... this point is more related to persistence characteristic\r\n *         (not so much dealing with SmartPkg itself)\r\n *     * typically top-level objects are from the core package, which\r\n *       is globally available (however that is a minor point)\r\n *     * in addition, objects can be instances of classes defined\r\n *       within the same package (as you would expect)\r\n *   - SO IN SUMMARY: the distinction between \"classRef\" and \"object instance\":\r\n *     * \"instances\" ALWAYS belong to the \"self-contained\" package\r\n *     * \"instances\" can be created from types that belong to either self's package or \"other\" packages\r\n *\r\n * SmartPkg entries are defined in an object structure (with depth)\r\n * that represents the visual hierarchy by which they are promoted.\r\n *   - entries utilize an object structure (with depth)\r\n *   - any client-defined structure is supported (i.e. a collection of\r\n *     whatever with arbitrary nesting of named nodes)\r\n *   - named nodes (contained in plain objects) represent a logical directory\r\n *     * where the name is a displayed human readable node\r\n *     * and can be nested (supporting sub-structure depth)\r\n *   - arrays represent resource items (or nested named nodes)\r\n *     * entries can be:\r\n *       1. smartObject to view/use\r\n *          ```\r\n *          can be:\r\n *          - Classes ... SingleValve, TwoWayValve, etc. (NOT SUPPORTED BY RESOURCE-BASED PKG)\r\n *          - SmartModel instance obj ... Collage\r\n *          - SmartModel pseudoClass\r\n *            * pseudoClass Master ...... DynamicComp, Scene, \r\n *            * pseudoClass INSTANCE .... comp instances IN Scene -or- scene instances in Collage\r\n *          ```\r\n *       2. plain object representing nested sub-entries mixed into the\r\n *          entries array\r\n *\r\n * Here is a sample `entries`:\r\n * ```js\r\n * entries: {\r\n *   components: {\r\n *     valves: [\r\n *       // ... example of class (i.e. a class function) ... NOT supported by a resource-based pkg\r\n *       SingleValve,\r\n *       TwoWayValve,\r\n *\r\n *       // ... example of Pseudo Class MASTER (a DynamicComp(), dynamically editable)\r\n *       DynamicComp({withPseudoClassName, andOthers}),\r\n *     ],\r\n *     pumps: [\r\n *       PowerPump,\r\n *       { // ... nested sub-entries mixed into the entries array\r\n *         \"Pumps Cat 2\": [\r\n *           SubPump1,\r\n *           SubPump2,\r\n *         ],\r\n *       },\r\n *       SumpPump,\r\n *     ],\r\n *   },\r\n *   scenes: [\r\n *     // ... a pseudoClass MASTER (can be edited: the comps add/remove/position/transform)\r\n *     Scene(...comps),\r\n *     Scene(...comps),\r\n *     ...\r\n *   ],\r\n *   collages: [\r\n *     // ... collage instance that holds scene instances (pseudoClass INSTANCEs)\r\n *     //      - VERY TRUE: scene instances will hold their unique x/y offsets\r\n *     //      - Collage MUST validate that scene instances are used\r\n *     //        ?? TODO: make this so (even though it is tightly controlled, wouldn't hurt to validate it)\r\n *     //      - IMPORTANT: to resolve this, MUST FIRST resolve Scene pseudoClass MASTER\r\n *     //        ... because it is referenced in the same pkg!\r\n *     Collage(...scenes)\r\n *     Collage(...scenes)\r\n *     ...\r\n *   ],\r\n * }\r\n * ```\r\n *\r\n * SmartPkg entries are promoted through two internal catalogs,\r\n * providing easy access independent of the visual hierarchy (i.e. the\r\n * visual structure with depth).  The two catalogs are:\r\n * \r\n * ```\r\n *  + getClassRef(className): SmartClassRef ... used by pkgManager\r\n *  + getPkgEntry(entryId):   entry         ... used by ?? suspect needed for pseudoClass modification sync in other PkgEntries\r\n * ```\r\n */\r\nexport default class SmartPkg extends SmartModel {\r\n\r\n  /**\r\n   * Create a SmartPkg.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this SmartPkg\r\n   * (i.e. the package ID).  Because this must be fully unique\r\n   * across all other in-memory packages, it is recommended to use a\r\n   * \"java like\" package name (ex: com.astx.acme).\r\n   * @param {string} [name=id] - The SmartPkg name.\r\n   * @param {Object} [entries] - the optional entries held in self (see class notes).\r\n   */\r\n  constructor({id, name, entries={}, ...unknownArgs}={}) {\r\n    super({id, name});\r\n\r\n    // validate SmartPkg() constructor parameters\r\n    const check = verify.prefix(`${this.diagClassName()}(id:'${id}', name:'${name}') constructor parameter violation: `);\r\n\r\n    // ... id/name validated by base class\r\n\r\n    // ... entries\r\n    check(entries,                 'entries is required');\r\n    check(isPlainObject(entries),  'entries must be a plain object (with depth)');\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // retain derivation-specific parameters in self\r\n    this.entries = entries;\r\n\r\n    // remaining logic\r\n    // ... hook into the standard SmartModel.constructorConfig()\r\n    //     so this will be accomplished in pseudo construction too!\r\n    // ?? DO THIS -and- call it in our pseudo construction\r\n\r\n    // initialize our catalogs\r\n    this.initializeCatalogs(this.entries);\r\n\r\n    // introduce the value-added meta API to all our classes (including package registration)\r\n    this.adornContainedClasses();\r\n\r\n    // mark our top-level entries as PkgEntries\r\n    Object.values(this._entryCatalog).forEach( (entry) => {\r\n      entry.markAsPkgEntry(); // ... internally markAsPkgEntry() will register them to changeManager\r\n    });\r\n\r\n    // reset the baseline crc throughout our containment tree\r\n    this.resetBaseCrc();\r\n\r\n    // register self's (SmartPkg) state to changeManager\r\n    changeManager.registerEPkg(this);\r\n\r\n    // console.log(`xx HERE IS A SmartPkg: `, this);\r\n  }\r\n\r\n  // support persistance by encoding needed props of self\r\n  getEncodingProps() {\r\n    return [...super.getEncodingProps(), ...['entries']];\r\n  }\r\n\r\n  /**\r\n   * Return self's package ID (ex: 'com.astx.acme').\r\n   */\r\n  getPkgId() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Return self's package name (ex: 'ACME System').\r\n   */\r\n  getPkgName() {\r\n    return this.name;\r\n  }\r\n\r\n  // change isaPkg() to indicate we are SmartPkg instances\r\n  isaPkg() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Return self's pkgResourcePath (if any).\r\n   * \r\n   * When a SmartPkg is persisted (i.e. pulled from, or saved to a\r\n   * file/url), it will contain a pkgResourcePath.\r\n   * - this merely identifies it's persistent form and provides a\r\n   *   convenient means by which changes can be saved\r\n   * \r\n   * NOTE: The `pkgResourcePath` attribute is NOT persisted, rather\r\n   *       it is retained as a result of an open/save operation\r\n   *       (see: pkgPersist.js open/save operators).\r\n   *\r\n   * @returns {PkgResourcePath} the pkgResourcePath (if any),\r\n   * undefined for none.\r\n   */\r\n  getPkgResourcePath() {\r\n    return this.pkgResourcePath;\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether this package can be persisted.\r\n   * \r\n   * NOTE: Packages that contain code cannot be persisted.\r\n   *\r\n   * @returns {boolean} true: can persist, false otherwise.\r\n   */\r\n  canPersist() {\r\n    return !this.entriesContainCode;\r\n  }\r\n\r\n  /**\r\n   * Set self's pkgResourcePath (see notes in getPkgResourcePath()).\r\n   *\r\n   * @param {PkgResourcePath} pkgResourcePath - the resource path\r\n   * where self is persisted.\r\n   */\r\n  setPkgResourcePath(pkgResourcePath) {\r\n    this.pkgResourcePath = pkgResourcePath;\r\n  }\r\n\r\n  /**\r\n   * An internal method that recurses through self's entries,\r\n   * initializing our two catalogs.\r\n   *\r\n   * @param {Object} entry - the current entry node being processed.\r\n   */\r\n  initializeCatalogs(entry) {\r\n\r\n    // reset our catalogs on the top-level invocation\r\n    if (entry === this.entries) {\r\n      this._classRefCatalog = {};\r\n      this._entryCatalog    = {};\r\n\r\n      // prime our indicator as to whether our content contains code\r\n      // ... used in determining if this package can be persisted\r\n      //     (see: `canPersist()`).\r\n      this.entriesContainCode = false; // ... start out assuming NO code\r\n    }\r\n\r\n    // recurse over entry\r\n    // ... for plain objects, each member is a directory node\r\n    if (isPlainObject(entry)) {\r\n      // pass through through all directory nodes (object members),\r\n      // ... and recurse into each\r\n      for (const dirName in entry) {\r\n        const dirContent = entry[dirName];\r\n        this.initializeCatalogs(dirContent);\r\n      }\r\n    }\r\n    // ... for array entry,\r\n    else if (Array.isArray(entry)) {\r\n      entry.forEach( (arrItem) => {\r\n\r\n        // normally this is a smartObj\r\n        if (isSmartObject(arrItem)) {\r\n          const smartObj = arrItem;\r\n\r\n          // catalog any pseudoClasses in our _classRefCatalog\r\n          if (PseudoClass.isPseudoClassMaster(smartObj)) {\r\n            const className = PseudoClass.getClassName(smartObj);\r\n            this._classRefCatalog[className] = smartObj;\r\n          }\r\n\r\n          // catalog all entries in our _entryCatalog\r\n          this._entryCatalog[smartObj.id] = smartObj; // ??!! should entries contain real classes too (they do contain pseudo classes)\r\n\r\n          // maintain our parentage\r\n          smartObj.setParent(this);\r\n        }\r\n\r\n        // can be a real class reference\r\n        else if (isClass(arrItem)) { // ??!! specific to real class\r\n          const realClass = arrItem;\r\n\r\n          // mark our package as containing code\r\n          this.entriesContainCode = true;\r\n\r\n          // catalog classes in our _classRefCatalog\r\n          const className = PseudoClass.getClassName(realClass);\r\n          this._classRefCatalog[className] = realClass;\r\n\r\n          // AI: most likely we need to register SOMETHING from a class in our this._entryCatalog (as is done for PseudoClassMaster above)\r\n        }\r\n\r\n        // can be a nested sub-directory (mixed in with our tab activation entries)\r\n        else if (isPlainObject(arrItem)) {\r\n          this.initializeCatalogs(arrItem);\r\n        }\r\n\r\n        // other items are NOT supported (should not happen - defensive only)\r\n        else {\r\n          const errMsg = '***ERROR*** SmartPkg.initializeCatalogs() found UNSUPPORTED array entry ... must be a smartObj or class or plain nested directory object ... see logs for entry';\r\n          console.error(errMsg, {arrItem});\r\n          throw new Error(errMsg);\r\n        }\r\n      });\r\n    }\r\n\r\n    // ... other entries are NOT supported (should not happen - defensive only)\r\n    else {\r\n      const errMsg = '***ERROR*** SmartPkg.initializeCatalogs() found UNSUPPORTED entry ... must be a plain directory object or an array of smartObjs ... see logs for entry';\r\n      console.error(errMsg, {entry});\r\n      throw new Error(errMsg);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Introduce the `.smartClassRef` on all our classes, providing\r\n   * value-added utility that unifies the meta API for both real\r\n   * classes and pseudoClasses.\r\n   *\r\n   * It also ties this package to the each class for the first time\r\n   * (registering self's package ID)!\r\n   */\r\n  adornContainedClasses() {\r\n    Object.values(this._classRefCatalog).forEach( (clazz) => {\r\n      // ?? what do we do if this clazz is already registered to some other package?\r\n      clazz.smartClassRef = new SmartClassRef(clazz, this.getPkgId());\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return self's classRef matching the supplied `className` (undefined for\r\n   * not-found).\r\n   *\r\n   * NOTE: This method is a key aspect that makes pkgManager work.\r\n   *\r\n   * @param {string} className - the class name of the classRef to return.\r\n   *\r\n   * @returns {SmartClassRef} the classRef matching the supplied `className`\r\n   * (undefined for not-found).\r\n   */\r\n  getClassRef(className) {\r\n    // NOTE: To avoid name clash with SmartModel.getClassRef(), \r\n    //       an unrelated method to ours:\r\n    //       - we redirect to it based on the distinct param signature!!\r\n    //       - I really wanted to use this \"getClassRef\" in both cases\r\n    //       - This is analogous to \"Static Polymorphism\" in Java/C++,\r\n    //         where the entire method signature is employed in it's\r\n    //         polymorphic behavior :-)\r\n    if (arguments.length === 0) {\r\n      return super.getClassRef();\r\n    }\r\n\r\n    // this methods real implementation :-)\r\n    return this._classRefCatalog[className].smartClassRef;\r\n  }\r\n\r\n  /**\r\n   * Return the entry matching the supplied `entryId` (undefined for\r\n   * not-found).\r\n   *\r\n   * NOTE: This method is a key aspect that integrates with the\r\n   *       visuals (displayed in the tab manager).\r\n   *       HOWEVER however it is currently not needed.\r\n   *       ... as of 2/16/2020, this method NOT being used.\r\n   *\r\n   * @param {string} entryId - the entry ID of the entry to return.\r\n   *\r\n   * @returns {PkgEntry} the entry matching the supplied `entryId`,\r\n   * `undefined` for not-found.\r\n   */\r\n  getPkgEntry(entryId) {\r\n    return this._entryCatalog[entryId];\r\n  }\r\n\r\n  /**\r\n   * A static method that reconstitutes SmartPkg objects from\r\n   * smartJSON.\r\n   *\r\n   * NOTE: This is specialized logic (from `SmartModel.fromSmartJSON()`),\r\n   *       because it must FIRST resolve pseudoClass MASTER\r\n   *       definitions, in support of self-referencing pseudoClasses\r\n   *       (ex: collage referencing scene instances)\r\n   * \r\n   *       This is accomplished in a two-phase process:\r\n   * \r\n   *       - PHASE-1: pre-process the smartJSON to resolve pseudoClass MASTER definitions\r\n   *                  ... in support of self-referencing pseudoClasses\r\n   *                      (ex: collage referencing scene instances)\r\n   * \r\n   *       - PHASE-2: hydrate the entire object\r\n   *                  ... now that pseudoClass MASTER definitions have been resolved\r\n   * \r\n   *       KEY: After researching the possibility of \"generically\"\r\n   *            including this logic in `SmartModel.fromSmartJSON()`,\r\n   *            it is felt that the logic better belongs here!  It\r\n   *            contains specific logic around SmartPkg objects.  For\r\n   *            example it traverses the `entries` structure of a\r\n   *            SmartPkg (see: `resolvePseudoClassMasters(smartJSON.entries)`\r\n   *            below).\r\n   * \r\n   * @param {JSON} smartJSON - the smartJSON structure representing\r\n   * the SmartPkg object to rehydrate.\r\n   *\r\n   * @returns {SmartPkg} a newly instantiated SmartPkg object from the\r\n   * supplied smartJSON.\r\n   *\r\n   * @throws {Error} an Error is thrown in various scenarios\r\n   * (unresolved class references, invalid params, etc.).\r\n   */\r\n  static fromSmartJSON(smartJSON) {\r\n\r\n    // validate supplied parameters\r\n    const check = verify.prefix('SmartPkg.fromSmartJSON(smartJSON) parameter violation: ');\r\n\r\n    // ... smartJSON\r\n    check(smartJSON,                 'smartJSON is required');\r\n    check(isPlainObject(smartJSON),  'smartJSON must be a JSON object');\r\n    check(smartJSON.smartType === 'SmartPkg',\r\n          `smartJSON does NOT represent a SmartPkg object, rather a ${smartJSON.smartType} object.`);\r\n\r\n    //***\r\n    //*** PHASE-1: pre-process the smartJSON to resolve pseudoClass MASTER definitions\r\n    //***          ... in support of self-referencing pseudoClasses\r\n    //***              (ex: collage referencing scene instances)\r\n    //***\r\n\r\n    // NOTE: We currently mutate smartJSON with real objects (resolving pseudoClass MASTER TYPEs).\r\n    //       While this should work, may want to consider making a copy.\r\n\r\n    // the catalog of pseudoClass MASTERs (supporting the extraClassResolver)\r\n    const pseudoClassMasters = {};\r\n\r\n    // retain the pkgId being resolved (used in our extraClassResolver)\r\n    // ... NOTE: for SmartPkg JSON, the top-level id IS the package ID\r\n    //           see: getPkgId()\r\n    const pkgIdBeingResolved = smartJSON.id;\r\n\r\n    // our recursive function that performs the pre-processing\r\n    function resolvePseudoClassMasters(jsonEntry) {\r\n\r\n      // entry is a plain JSON object\r\n      if (isPlainObject(jsonEntry)) {\r\n\r\n        // entry is a smartObject\r\n        if (jsonEntry.smartType) {\r\n\r\n          // hydrate our pseudoClass MASTERs early\r\n          // ... IMPORTANT: this is the reason we are pre-processing!\r\n          // ... NOTE: All our pseudoClass MASTER will appear in the root of any entries directory!\r\n          //           In other words, no need to drill any further deep!\r\n          if (jsonEntry.isPseudoClassMaster) {\r\n\r\n            // morph into a real object\r\n            const resolvedObj = SmartModel.fromSmartJSON(jsonEntry); // ... no need for extraClassResolver (pseudoClass Masters resolve via core classes)\r\n\r\n            // adorn the .smartClassRef early (normally done by SmartPkg at the end of it's construction)\r\n            resolvedObj.smartClassRef = new SmartClassRef(resolvedObj, pkgIdBeingResolved);\r\n\r\n            // catalog in pseudoClassMasters\r\n            pseudoClassMasters[resolvedObj.id] = resolvedObj;\r\n\r\n\r\n            // pass it through\r\n            // ... see note on \"mutate smartJSON with real objects\" (above)\r\n            return resolvedObj;\r\n          }\r\n          \r\n          // pass ALL OTHER smartObjects through (JSON as-is)\r\n          // ... things like:\r\n          //     - pseudoClass INSTANCEs\r\n          //     - other SmartClasses (should NEVER happen in our entries structure\r\n          // ... this will be processed in PHASE-2\r\n          else {\r\n            return jsonEntry;\r\n          }\r\n        }\r\n\r\n        // entry is a plain JSON object\r\n        else {\r\n          // recursively pass through through all object members\r\n          for (const key in jsonEntry) {\r\n            const oldVal = jsonEntry[key];\r\n            const newVal = resolvePseudoClassMasters(oldVal);\r\n            jsonEntry[key] = newVal; // potential mutation\r\n          }\r\n          return jsonEntry;\r\n        }\r\n      }\r\n\r\n      // entry is an array\r\n      else if (Array.isArray(jsonEntry)) {\r\n        // recursively pass through through all array items\r\n        for (let i=0; i<jsonEntry.length; i++) {\r\n          const oldVal = jsonEntry[i];\r\n          const newVal = resolvePseudoClassMasters(oldVal);\r\n          jsonEntry[i] = newVal; // potential mutation\r\n        }\r\n        return jsonEntry;\r\n      }\r\n\r\n      // entry is a JavaScript class\r\n      // ... should NOT find this in resource-based pkgs (simply defensive)\r\n      else if (isClass(jsonEntry)) {\r\n        // pass it through\r\n        console.warn('SmartPkg.fromSmartJSON(smartJson).resolvePseudoClassMasters(jsonEntry) PHASE-1: NOT expecting to pass through (class) ... ', {jsonEntry, smartJSON});\r\n        return jsonEntry;\r\n\r\n      }\r\n\r\n      // handle anything else\r\n      // ... primitives\r\n      // ... should NOT happen within our entries structure\r\n      else {\r\n        // pass it through\r\n        console.warn('SmartPkg.fromSmartJSON(smartJson).resolvePseudoClassMasters(jsonEntry) PHASE-1: NOT expecting to pass through (primitive) ... ', {jsonEntry, smartJSON});\r\n        return jsonEntry;\r\n      }\r\n\r\n    }\r\n\r\n    // resolve the pseudoClass MASTER definitions (within the smartJSON)\r\n    resolvePseudoClassMasters(smartJSON.entries);\r\n    \r\n\r\n    //***\r\n    //*** PHASE-2: hydrate the entire object\r\n    //***          ... now that pseudoClass MASTER definitions have been resolved\r\n    //***\r\n\r\n    // utilize an extraClassResolver that can resolve self-referencing pseudoClasses\r\n    // ... ex: collage referencing scene instances\r\n    function extraClassResolver(pkgId, className) {\r\n      const clazz = (pkgId === pkgIdBeingResolved) ? pseudoClassMasters[className] : undefined;\r\n      //console.log(`xx TEMP ... in extraClassResolver(pkgId:'${pkgId}', className:'${className}') ... comparing pkgIdBeingResolved:'${pkgIdBeingResolved}'` +\r\n      //            ` >>> ${clazz ? 'FOUND IT' : 'NOT FOUND'} ... pseudoClassMasters: `, pseudoClassMasters);\r\n\r\n      return clazz ? clazz.smartClassRef : undefined;\r\n    }\r\n\r\n    // use the normal SmartModel.fromSmartJSON() to do this work\r\n    // ... this passes through any objects that are already hydrated in our smartJSON\r\n    try {\r\n      const hydratedObj = SmartModel.fromSmartJSON(smartJSON, extraClassResolver);\r\n      return hydratedObj;\r\n    }\r\n    catch(err) {\r\n      // add additional context to reveal any errors resolving THIS SmartPkg\r\n      throw err.defineAttemptingToMsg(`hydrate SmartPkg '${pkgIdBeingResolved}'`);\r\n    }\r\n  }\r\n\r\n}\r\nSmartPkg.unmangledName = 'SmartPkg';\r\n","import React              from 'react';\r\nimport LeftNavMenuPallet  from './comp/LeftNavMenuPallet';\r\nimport SmartPkg           from 'core/SmartPkg';\r\nimport verify             from 'util/verify';\r\n\r\n\r\n/**\r\n * LeftNavManager is an agent managing LeftNav items.\r\n */\r\nclass LeftNavManager {\r\n\r\n  /**\r\n   * Create a LeftNavManager.\r\n   */\r\n  constructor() {\r\n\r\n    // carve out our state\r\n    // ... injected by: baseUI feature.appInit()\r\n    // ... all other state managed by redux\r\n    this.fassets  = null;\r\n    this.dispatch = null;\r\n    this.leftNavCache = []; // SmartPkg[]\r\n  }\r\n\r\n  /**\r\n   * Internal method that injects operational dependencies into self\r\n   * ... invoked early in the startup process by feature.appInit()\r\n   * @private\r\n   */\r\n  injectDependency(fassets, dispatch) {\r\n\r\n    // retain operational dependencies\r\n    this.fassets  = fassets;\r\n    this.dispatch = dispatch;\r\n\r\n    // process any cached entries (waiting to be operational)\r\n    this.leftNavCache.forEach( (smartPkg) => this.processAddLeftNav(smartPkg) );\r\n    this.leftNavCache = []; // clear the cache\r\n  }\r\n\r\n  /**\r\n   * Internal method that processes addLeftNav() requests.\r\n   * @private\r\n   */\r\n  processAddLeftNav(smartPkg) {\r\n    // cache request, when self it not yet operational\r\n    if (!this.fassets) {\r\n      this.leftNavCache.push(smartPkg);\r\n    }\r\n    // process request\r\n    else {\r\n      this.dispatch( this.fassets.actions.addLeftNavItem(smartPkg.getPkgName(), () => (\r\n        <LeftNavMenuPallet smartPkg={smartPkg}/>\r\n      )) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Display the supplied package in the LeftNav menu.\r\n   *\r\n   * NOTE: To be operational, this method requires the injection of\r\n   *       fassets/dispatch (see: injectDependency()). If invoked\r\n   *       prior to this, the request will be cached, to be executed\r\n   *       later (minimizing feature order dependency).\r\n   *\r\n   * @param {SmartPkg} smartPkg - the package to be registered.\r\n   */\r\n  addLeftNav(smartPkg) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.constructor.name}.addLeftNav() parameter violation: `);\r\n\r\n    // ... smartPkg\r\n    check(smartPkg,                     'smartPkg is required');\r\n    check(smartPkg instanceof SmartPkg, 'smartPkg must be a SmartPkg instance');\r\n\r\n    // process request\r\n    this.processAddLeftNav(smartPkg);\r\n  }\r\n\r\n  // AI: + removeLeftNav(smartPkg?): void <<< L8TR\r\n}\r\n\r\n// expose our single leftNavManager utility ... AI: singleton code smell ... see if fassets entry will suffice (if this works can simply be the standard action)\r\nconst leftNavManager = new LeftNavManager();\r\nexport default leftNavManager;\r\n","import React,\r\n       {useState,\r\n        useCallback}       from 'react';\r\nimport Collapse            from '@material-ui/core/Collapse';\r\nimport ExpandLessIcon      from '@material-ui/icons/ExpandMore';   // in effect WHEN EXPANDED  ... i.e. clicking will collapse\r\nimport ExpandMoreIcon      from '@material-ui/icons/ChevronRight'; // in effect WHEN COLLAPSED ... i.e. clicking will expand\r\nimport ListItem            from '@material-ui/core/ListItem';\r\nimport ListItemIcon        from '@material-ui/core/ListItemIcon';\r\nimport ListItemText        from '@material-ui/core/ListItemText';\r\nimport PaletteIconDefault  from '@material-ui/icons/Palette';\r\nimport Paper               from '@material-ui/core/Paper';\r\nimport {makeStyles}        from '@material-ui/core/styles';\r\n\r\n\r\n/**\r\n * LeftNavCollapsibleItem: A top-level LeftNav entry that adorns it's children\r\n *                         (the pallet) with a collapsible control.\r\n *\r\n * The pallet (i.e. the children) will typically contain an expandable\r\n * tree ... however this is not required.\r\n */\r\nexport default function LeftNavCollapsibleItem({name, PaletteIcon=PaletteIconDefault, children}) {\r\n\r\n  const classes         = useStyles();\r\n  const [open, setOpen] = useState(false);\r\n  const toggleExpansion = useCallback(() => {\r\n    setOpen(!open);\r\n  }, [open]);\r\n\r\n  return (\r\n    <>\r\n    <ListItem button onClick={toggleExpansion}>\r\n      <ListItemIcon>\r\n        <PaletteIcon/>\r\n      </ListItemIcon>\r\n      <ListItemText primary={name}/>\r\n      {open ? <ExpandLessIcon/> : <ExpandMoreIcon/>}\r\n    </ListItem>\r\n    <Collapse in={open}\r\n              // NOTE: removed unmountOnExit (was causing tree expansion to loose state)\r\n              timeout=\"auto\">\r\n      <Paper className={classes.pallet}>\r\n        {children}\r\n      </Paper>\r\n    </Collapse>\r\n    </>\r\n  );\r\n}\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n  pallet: {\r\n    margin:  theme.spacing(0, 2, 2, 2),\r\n    padding: theme.spacing(1),\r\n  },\r\n}) );\r\n","import verify         from 'util/verify';\r\nimport {isString}     from 'util/typeCheck';\r\n\r\n/**\r\n * TabController is an abstract base class that provides the API\r\n * through which the Tabs UI may interact with the visualize-it object\r\n * model.\r\n * \r\n * Derivations of this class are created for each of the specific\r\n * top-level object types, rendered by a tab.\r\n */\r\nexport default class TabController {\r\n\r\n  /**\r\n   * Create a TabController.\r\n   *\r\n   * @param {string} tabId - the globally unique key, identifying the\r\n   * tab in question. Typically a federated namespace is employed to\r\n   * insure this key is globally unique (ex: compLibName/comp, or\r\n   * systemName/view, etc.).\r\n   *\r\n   * @param {string} tabName the human interpretable name displayed in\r\n   * the tab.\r\n   */\r\n  constructor(tabId, tabName) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}() constructor parameter violation: `);\r\n    // ... tabId\r\n    check(tabId,              'tabId is required');\r\n    check(isString(tabId),    'tabId must be a string');\r\n    // ... tabName\r\n    check(tabName,            'tabName is required');\r\n    check(isString(tabName),  'tabName must be a string');\r\n\r\n    // carve out our object state\r\n    this.tabId   = tabId;\r\n    this.tabName = tabName;\r\n  }\r\n\r\n  /**\r\n   * Return self's tabId.\r\n   * @returns {string} the tabId of self.\r\n   */\r\n  getTabId() {\r\n    return this.tabId;\r\n  }\r\n\r\n  /**\r\n   * Return self's tabName.\r\n   * @returns {string} the tabName of self.\r\n   */\r\n  getTabName() {\r\n    return this.tabName;\r\n  }\r\n\r\n  /**\r\n   * Return the top-level object model targeted by this tab.\r\n   * @returns {SmartObj} the target object rendered by this tab.\r\n   */\r\n  getTarget() {\r\n    throw new Error(`***ERROR*** TabController.getTarget() the ${this.diagClassName()} class derivation MUST implement this abstract method (tabId:${this.tabId}, tabName:${this.tabName})!!`);\r\n  }\r\n\r\n  /**\r\n   * Return the \"no property\" component that renders self in the tab panel.\r\n   * @returns {ReactComp} the \"no property\" component that renders self in the tab panel.\r\n   */\r\n  getTabPanelComp() {\r\n    // cache our TabPanelComp so as to prevent constant re-renders -and- heavy-weight Konva mounts\r\n    if (!this.TabPanelComp) {\r\n      this.TabPanelComp = this.createTabPanelComp();\r\n    }\r\n    return this.TabPanelComp;\r\n  }\r\n\r\n\r\n  /**\r\n   * Create the \"no property\" component that renders self in the tab panel.\r\n   * @returns {ReactComp} the \"no property\" component that renders self in the tab panel.\r\n   */\r\n  createTabPanelComp() {\r\n    throw new Error(`***ERROR*** TabController.createTabPanelComp() the ${this.diagClassName()} class derivation MUST implement this abstract method (tabId:${this.tabId}, tabName:${this.tabName})!!`);\r\n  }\r\n\r\n\r\n  /**\r\n   * Return self's \"real\" class name, used for diagnostic purposes\r\n   * (such as logs and errors).  The name is unmangled (even in\r\n   * production builds).\r\n   *\r\n   * @returns {string} self's \"real\" class name.\r\n   */\r\n  diagClassName() {\r\n    return this.constructor.unmangledName || this.constructor.name;\r\n  }\r\n}\r\nTabController.unmangledName = 'TabController';\r\n","import TabController from './TabController';\r\nimport verify        from 'util/verify';\r\nimport {isString}    from 'util/typeCheck';\r\n\r\n/**\r\n * TabRegistry provides a registry of ALL tabs (TabControllers).\r\n *\r\n * Tab registration occurs early.  Registered entries have the\r\n * \"potential\" of being displayed.\r\n *\r\n * When a tab is initially referenced (a dynamic process), it will be\r\n * created through the `TabController.getTabPanelComp()` API.\r\n * \r\n * Once a tab has been displayed, all interaction to it funnels\r\n * through the TabController API.\r\n */\r\nclass TabRegistry {\r\n\r\n  /**\r\n   * Create a TabRegistry.\r\n   */\r\n  constructor() {\r\n    // carve out our tabRegistry\r\n    this.tabRegistry = {\r\n      // [tabId]: tabController,\r\n      // ...\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register the supplied `tabController` as a potential tab that can\r\n   * be rendered in our system.\r\n   *\r\n   * @param {TabController} tabController the controller to register.\r\n   *\r\n   * @throws {Error} an Error is thrown for invalid params\r\n   * (NO LONGER: or if the controller has already been registered).\r\n   */\r\n  registerTab(tabController) {\r\n\r\n    // validate parameters\r\n    const check = verify.prefix('TabRegistry.registerTab() parameter violation: ');\r\n\r\n    // ... tabController\r\n    check(tabController,                          'tabController is required');\r\n    check(tabController instanceof TabController, 'tabController must be a TabController instance');\r\n\r\n    // maintain our tabRegistry catalog\r\n    const tabId = tabController.getTabId();\r\n    // console.log(`xx TabRegistry.registerTab() registering tabController(${tabId}): `, tabController);\r\n    if (this.tabRegistry[tabId]) { // NO LONGER: verify tabController is not already loaded!\r\n      // ... we tightly control the tabId federated name-space,\r\n      //     so any re-registration is presumably due to left-nav menu regeneration\r\n      //     - THEREFORE we do not throw an exception here\r\n      //     - IN ADDITION, we re-use the old registration (due to else clause below), BECAUSE:\r\n      //       * the DispMode is NOT retained in the tab panel itself\r\n      //         ... need more research\r\n      //       * SHOULD BE OK: I can't imagine what could change that would impact the TabController\r\n      // throw new Error(`***ERROR*** TabRegistry.registerTab() tabId: ${tabId} is already registered :-(`);\r\n    }\r\n    else {\r\n      this.tabRegistry[tabId] = tabController;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the TabController registered to the supplied `tabId`\r\n   * (undefined for NOT registered).\r\n   *\r\n   * @param {string} tabId - the id of the TabController to return.\r\n   *\r\n   * @returns {TabController} the TabController registered to the\r\n   * supplied `tabId` (undefined for NOT registered).\r\n   */\r\n  getTabController(tabId) {\r\n    // validate parameters\r\n    const check = verify.prefix('TabRegistry.getTabController() parameter violation: ');\r\n    // ... tabId\r\n    check(tabId,             'tabId is required');\r\n    check(isString(tabId),   'tabId must be a string');\r\n\r\n    // return the TabController (if any)\r\n    return this.tabRegistry[tabId];\r\n  }\r\n\r\n}\r\n\r\n// expose our single tabRegistry utility ... AI: singleton code smell\r\nconst tabRegistry = new TabRegistry();\r\nexport default tabRegistry;\r\n","import React               from 'react';\r\nimport {useRef, useEffect} from 'react';\r\nimport {createLogger}      from 'util/logger';\r\n\r\n// our internal diagnostic logger (normally disabled)\r\nconst log = createLogger('***DIAG*** <ReactSmartView> ... ').disable();\r\n\r\n\r\n// ReactSmartView: a re-usable React Component that mounts (i.e. renders) a SmartView.\r\n//                 NOTE: This is part of util because it is a react utility \r\n//                       used by the interactive tool ... NOT a core offering!\r\nfunction ReactSmartView({view, ...otherProps}) {\r\n\r\n  const stageElm = useRef(null);\r\n\r\n  // mount the view canvas graphics, once self is fully manifest in the real HTML DOM\r\n  useEffect( () => {\r\n    view.mount(stageElm.current);    \r\n  }, [view]); // ... the dependency list prevents redundant mounts()\r\n\r\n  // ?? crude test\r\n  // ? style={{backgroundColor: 'gray', borderWidth: 5, borderStyle: 'solid', borderColor: 'purple'}}\r\n  // ?? AI: the style characteristics (below) will be eventually gleaned from future SmartView API\r\n  //        ex: view.backgroundColor, view.width, view.height \r\n  //        THE BORDER is provided by US (not sure) to expose the view border and/or ability to edit width/height (unsure about this last one)\r\n  log('here is my view: ', view);\r\n  const {width, height} = view.getSize();\r\n  return <div ref={stageElm} {...otherProps} style={{backgroundColor: 'gray', width, height, border: '1px solid black'}}/>;\r\n}\r\n\r\n// PERF: memo is critical (without it re-render is frequent, even activating tabs)\r\n//       - bypasses render if props are the same (can override shallow comparison with a second fn param to memo()\r\n//       - also still allows re-render on hooks direction\r\nexport default React.memo(ReactSmartView);\r\n","/* eslint-disable react/no-is-mounted */ // isMount() usage is NOT react-based\r\nimport SmartModel        from './SmartModel';\r\nimport SmartPallet       from './SmartPallet';\r\nimport Konva             from 'konva';\r\nimport verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\nimport {createLogger}    from 'util/logger';\r\n\r\n// our internal diagnostic logger (normally disabled, but keep enabled for a while)\r\nconst log = createLogger('***DIAG*** <SmartView> ... ').disable();\r\n\r\n/**\r\n * SmartView is a viewport in which pallet(s) are displayed/visualized.\r\n * \r\n * Derivations of the contained SmartPallet will handle the specifics\r\n * of visualizing a single scene (Scene obj) or multiple scenes\r\n * (Collage obj).\r\n * \r\n * In all cases, this visualization can be \"displayed\":\r\n *   - in-line:  within the \"contained\" HTML DOM container\r\n *   - external: using an external browser window\r\n * TODO: this MAY BE more of a run-time consideration (rather than\r\n *       specified/retained by constructor params driven by our editor)\r\n */\r\nexport default class SmartView extends SmartModel {\r\n\r\n  /**\r\n   * Create a SmartView.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this view.\r\n   * @param {string} [name=id] - the human interpretable name of this\r\n   * view (DEFAULT to id).\r\n   * @param {SmartPallet} pallet - the pallet visualized in this view\r\n   * (can be a single scene (Scene obj) or multiple scenes (Collage\r\n   * obj).\r\n   */\r\n  constructor({id, name, pallet, ...unknownArgs}={}) {\r\n\r\n    super({id, name});\r\n\r\n    // validate SmartView() constructor parameters\r\n    const check = verify.prefix(`${this.diagClassName()}(id:'${id}', name:'${name}') constructor parameter violation: `);\r\n    \r\n    // ... id/name validated by base class\r\n\r\n    // ... pallet\r\n    check(pallet,                        'pallet is required');\r\n    check(pallet instanceof SmartPallet, 'pallet must be a SmartPallet instance');\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n    \r\n    // retain parameters in self\r\n    this.pallet = pallet;\r\n\r\n    // maintain our \"view\" containment tree parentage\r\n    this.pallet.setViewParent(this);\r\n  }\r\n\r\n  // support persistance by encoding needed props of self\r\n  // ... currently SmartView is NOT persisted\r\n  //     - the persistance entry point is SmartPkg -to- SmartPallet (skipping SmartView)\r\n  //     - however we support `getEncodingProps()` should it be needed\r\n  //       ... either a smartClone() operation or future needs of persistence\r\n  getEncodingProps() {\r\n    return [...super.getEncodingProps(), ...['pallet']];\r\n  }\r\n\r\n  // change isaView() to indicate we are SmartView instances\r\n  isaView() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Verify self has been mounted.\r\n   * @param {string} [method] - the method name on which behalf we are checking.\r\n   */\r\n  checkMounted(method) {\r\n    verify(this.isMounted(), `${this.diagClassName()}.${method}() can only be invoked after mounting.`);\r\n  }\r\n\r\n  /**\r\n   * Get self's size.\r\n   *\r\n   * @returns {Size} our current size: {width, height}\r\n   */\r\n  getSize() {\r\n    // simply defer to our pallet size\r\n    // ... use our pallet's sizeCache (no need for our own)\r\n    return this.pallet.getSize();\r\n  }\r\n\r\n  /**\r\n   * Perform any static binding of self's size change (such as HTML or\r\n   * Konva bindings).\r\n   *\r\n   * @param {Size} oldSize - the previous size ... {width, height}.\r\n   * @param {Size} newSize - the new size ... {width, height}.\r\n   */\r\n  bindSizeChanges(oldSize, newSize) {\r\n    // sync size to our Konva.Stage\r\n    this.konvaStage.size(newSize);\r\n    this.konvaStage.draw();\r\n\r\n    // sync size to our containingHtmlElm\r\n    this.containingHtmlElm.style.width  = `${newSize.width}px`;\r\n    this.containingHtmlElm.style.height = `${newSize.height}px`;\r\n  }\r\n\r\n\r\n  /**\r\n   * Mount the visuals of this view, binding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * Prior to `mount()` execution, the visualize-it object\r\n   * representation is very lightweight.\r\n   *\r\n   * @param {HtmlElm} containingHtmlElm - The container of this view\r\n   * (an HTML Element).\r\n   */\r\n  mount(containingHtmlElm) {\r\n    log(`mounting SmartView id: ${this.id}`);\r\n    \r\n    // retain our containingHtmlElm\r\n    this.containingHtmlElm = containingHtmlElm;\r\n\r\n    // create our stage where our pallet will be mounted\r\n    const {width, height} = this.getSize();\r\n    this.konvaStage = new Konva.Stage({\r\n      container: containingHtmlElm,\r\n      x:         0, // we assume an offset at the origin\r\n      y:         0,\r\n      width,\r\n      height,\r\n    });\r\n    \r\n    // mount our pallet into this stage\r\n    this.pallet.mount(this.konvaStage);\r\n\r\n    // regenerate actual size, once mounting is complete\r\n    // ... propagate this request into our pallet\r\n    this.pallet.trickleUpChange();\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is mounted (i.e. bound to the Konva graphics).\r\n   *\r\n   * @returns {boolean} `true`: self is mounted, `false` otherwise\r\n   */\r\n  isMounted() {\r\n    return this.konvaStage ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Unmount the visuals of this view, unbinding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * @param {boolean} [konvaPreDestroyed=false] - an internal\r\n   * parameter that indicates if konva nodes have already been\r\n   * destroyed (when a parent Konva.Node has already issued the\r\n   * konvaNode.destroy()).\r\n   */\r\n  unmount(konvaPreDestroyed=false) {\r\n    log(`unmounting SmartView id: ${this.id}`);\r\n\r\n    // destroy our Konva representation\r\n    // ... the Konva.destroy() is deep (clearing all containment)\r\n    // ... therefore, we do it conditionally, when not already accomplished by our parent\r\n    if (!konvaPreDestroyed) {\r\n      this.konvaStage.destroy();\r\n    }\r\n\r\n    // clear our konva state (established in our mount())\r\n    this.containingHtmlElm = null;\r\n    this.konvaStage        = null;\r\n    \r\n    // propagate request into our children\r\n    this.pallet.unmount(true/*konvaPreDestroyed*/);\r\n  }\r\n}\r\nSmartView.unmangledName = 'SmartView';\r\n","import React          from 'react';\r\nimport ReactSmartView from 'util/ReactSmartView';\r\n\r\nimport TabController  from './TabController';\r\n\r\nimport verify         from 'util/verify';\r\n\r\nimport Scene          from 'core/Scene';\r\nimport SmartView      from 'core/SmartView';\r\n\r\n\r\n/**\r\n * TabControllerScene is a concrete class that manages a specific Scene tab.\r\n */\r\nexport default class TabControllerScene extends TabController {\r\n\r\n  /**\r\n   * Create a TabControllerScene.\r\n   *\r\n   * @param {string} tabId - the globally unique key, identifying the\r\n   * tab in question. Typically a federated namespace is employed to\r\n   * insure this key is globally unique (ex: compLibName/comp, or\r\n   * systemName/view, etc.).\r\n   *\r\n   * @param {string} tabName the human interpretable name displayed in\r\n   * the tab.\r\n   *\r\n   * @param {Scene} scene the scene being displayed/managed by this tab.\r\n   */\r\n  constructor(tabId, tabName, scene) {\r\n    super(tabId, tabName);\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}() constructor parameter violation: `);\r\n    // ... tabId/tabName done by base class\r\n    // ... scene\r\n    check(scene,                   'scene is required');\r\n    check(scene instanceof Scene,  'scene must be a Scene object');\r\n\r\n    // retain state specific to this derivation\r\n    this.scene = scene;\r\n  }\r\n\r\n  // our target is our scene\r\n  getTarget() {\r\n    return this.scene;\r\n  }\r\n\r\n  // wrap our scene in the panel display\r\n  createTabPanelComp() {\r\n    const view = new SmartView({id: `view-${this.getTabId()}`, name: `view-${this.getTabName()}`, pallet: this.scene});\r\n    const panelComp = () => <ReactSmartView view={view}/>;\r\n    return panelComp;\r\n  }\r\n\r\n}\r\n","import React          from 'react';\r\nimport ReactSmartView from 'util/ReactSmartView';\r\n\r\nimport TabController  from './TabController';\r\n\r\nimport verify         from 'util/verify';\r\n\r\nimport Collage        from 'core/Collage';\r\nimport SmartView      from 'core/SmartView';\r\n\r\n\r\n/**\r\n * TabControllerCollage is a concrete class that manages a specific Collage tab.\r\n */\r\nexport default class TabControllerCollage extends TabController {\r\n\r\n  /**\r\n   * Create a TabControllerCollage.\r\n   *\r\n   * @param {string} tabId - the globally unique key, identifying the\r\n   * tab in question. Typically a federated namespace is employed to\r\n   * insure this key is globally unique (ex: compLibName/comp, or\r\n   * systemName/view, etc.).\r\n   *\r\n   * @param {string} tabName the human interpretable name displayed in\r\n   * the tab.\r\n   *\r\n   * @param {Collage} collage the collage being displayed/managed by this tab.\r\n   */\r\n  constructor(tabId, tabName, collage) {\r\n    super(tabId, tabName);\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}() constructor parameter violation: `);\r\n    // ... tabId/tabName done by base class\r\n    // ... collage\r\n    check(collage,                     'collage is required');\r\n    check(collage instanceof Collage,  'collage must be a Collage object');\r\n\r\n    // retain state specific to this derivation\r\n    this.collage = collage;\r\n  }\r\n\r\n  // our target is our collage\r\n  getTarget() {\r\n    return this.collage;\r\n  }\r\n\r\n  // wrap our collage in the panel display\r\n  createTabPanelComp() {\r\n    const view = new SmartView({id: `view-${this.getTabId()}`, name: `view-${this.getTabName()}`, pallet: this.collage});\r\n    const panelComp = () => <ReactSmartView view={view}/>;\r\n    return panelComp;\r\n  }\r\n\r\n}\r\n","import React                from 'react';\r\nimport ReactSmartView       from 'util/ReactSmartView';\r\n\r\nimport TabController        from './TabController';\r\n\r\nimport SmartView            from 'core/SmartView';\r\nimport CompRef              from 'core/CompRef';\r\n\r\nimport verify               from 'util/verify';\r\n\r\n/**\r\n * TabControllerCompRef is a concrete class that manages a specific component tab.\r\n */\r\nexport default class TabControllerCompRef extends TabController {\r\n\r\n  /**\r\n   * Create a TabControllerCompRef.\r\n   *\r\n   * @param {string} tabId - the globally unique key, identifying the\r\n   * tab in question. Typically a federated namespace is employed to\r\n   * insure this key is globally unique (ex: compLibName/comp, or\r\n   * systemName/view, etc.).\r\n   *\r\n   * @param {string} tabName the human interpretable name displayed in\r\n   * the tab.\r\n   *\r\n   * @param {CompRef} compRef the component class being displayed/managed by this tab.\r\n   */\r\n  constructor(tabId, tabName, compRef) {\r\n\r\n    super(tabId, tabName);\r\n\r\n    // validate parameters\r\n    const check = verify.prefix(`${this.diagClassName()}() constructor parameter violation: `);\r\n    // ... tabId/tabName done by base class\r\n    // ... compRef\r\n    check(compRef,                     'compRef is required');\r\n    check(compRef instanceof CompRef,  'compRef must be a CompRef type');\r\n\r\n    // retain state specific to this derivation\r\n    this.compRef = compRef;\r\n  }\r\n\r\n  // our target is our component instance, maintained in CompRef\r\n  getTarget() {\r\n    return this.compRef.getCompInstance();\r\n  }\r\n\r\n  // wrap our class in the panel display\r\n  createTabPanelComp() {\r\n    const view = new SmartView({id: `view-${this.compRef.getId()}`, pallet: this.compRef});\r\n    const panelComp = () => <ReactSmartView view={view}/>;\r\n    return panelComp;\r\n  }\r\n\r\n}\r\n","/* eslint-disable react/no-is-mounted */ // isMount() usage is NOT react-based\r\nimport Konva                from 'konva';\r\nimport PseudoClass          from './PseudoClass';\r\nimport SmartPallet          from './SmartPallet';\r\nimport {ancestorOfLayer,\r\n        containerSizeFudge} from './konvaUtil';\r\nimport verify               from 'util/verify';\r\nimport checkUnknownArgs     from 'util/checkUnknownArgs';\r\nimport {isNumber, isEqual}  from 'util/typeCheck';\r\nimport {changeManager}      from 'features/xtra';\r\n\r\n/**\r\n * Scene is a SmartPallet derivation that models a single Scene to be\r\n * displayed/visualized.\r\n *\r\n * A Scene represents a graphical perspective that visualizes a system\r\n * (either in part or whole).\r\n *\r\n * - a scene contains visual components, arranged in a way that\r\n *   resembles a system\r\n *\r\n * - a scene can DIRECTLY mange it's x/y properties (this is used in\r\n *   the context of a Collage, where multiple scenes are offset within\r\n *   a viewport).\r\n *\r\n * - different scenes may visualize various aspects of a system (for\r\n *   example a functional breakdown)\r\n *   * each scene INTERNALLY correlates to a separate Konva.Layer\r\n *\r\n * - FUTURE: support of user-defined functional layers:\r\n *   - scene may be further sub-divided into MULTIPLE functional layers\r\n *   - components of a scene will belong to one of these functional layers\r\n *     ... Quest: is this a direct containment, or some logical tagging?\r\n *   - this allows the visualization of these functional layers to be toggled on/off\r\n *\r\n * - FUTURE: Animation Consideration:\r\n *   - internally each scene (and their functional layers) is\r\n *     sub-divided into two Konva layers:\r\n *     - a static layer\r\n *     - an animation layer\r\n *     > NEEDS WORK: may want to do things in our static layer (like change component color)\r\n *\r\n * **NOTE**: Scene objects are pseudoClasses.  In other words Scene\r\n *           instances are considered logical types.  Take for example\r\n *           `Foo`: a Scene instance with an id of `Foo`.  The master\r\n *           `Foo` object can be defined and edited, however `Foo`\r\n *           instances (copies of the `Foo` object) may be may created\r\n *           and referenced many times within the various Collages.\r\n */\r\nexport default class Scene extends SmartPallet {\r\n\r\n  /**\r\n   * Create a Scene.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this scene.\r\n   * @param {string} [name=id] - the human interpretable name of this\r\n   * scene (DEFAULT to id).\r\n   *\r\n   * @param {int} [x=0] - the optional x offset of this scene within it's container (used by Collage container - managing multiple Scenes)\r\n   * @param {int} [y=0] - the optional y offset of this scene within it's container (used by Collage container - managing multiple Scenes)\r\n   *\r\n   * @param {SmartComp[]} comps - the set of components (SmartComp) that \r\n   * make up this scene (logically our display list).\r\n   */\r\n  constructor({id,\r\n               name,\r\n               x=0,\r\n               y=0,\r\n               comps,\r\n               ...unknownArgs}={}) {\r\n\r\n    super({id, name});\r\n\r\n    // validate Scene() constructor parameters\r\n    const check = verify.prefix(`${this.diagClassName()}() constructor parameter violation: `);\r\n\r\n    // ... id/name validated by base class\r\n\r\n    // ... comps\r\n    check(comps,                'comps is required');\r\n    check(Array.isArray(comps), 'comps must be a SmartComp[] array');\r\n\r\n    // ... x\r\n    check(isNumber(x), `x must be a number (when supplied), NOT: ${x}`);\r\n\r\n    // ... y\r\n    check(isNumber(y), `y must be a number (when supplied), NOT: ${y}`);\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    //***\r\n    //*** maintain self state (instance vars)\r\n    //***\r\n\r\n    // Scene objects are pseudoClasses (see NOTE above)\r\n    this.pseudoClass = new PseudoClass();\r\n\r\n    // retain parameters in self\r\n    this.x     = x;\r\n    this.y     = y;\r\n    this.comps = comps;\r\n\r\n    // maintain our parentage\r\n    this.comps.forEach( (comp) => comp.setParent(this) );\r\n  }\r\n\r\n  // support persistance by encoding needed props of self\r\n  getEncodingProps() {\r\n\r\n    // define our \"baseline\"\r\n    const encodingProps = [['x',0], ['y',0]];\r\n\r\n    // for pseudoClass MASTERs, include non-temporal props\r\n    // ... see JavaDoc for: SmartModel.getEncodingProps()\r\n    if (this.pseudoClass.isType()) {\r\n      encodingProps.push('comps');\r\n    }\r\n\r\n    return [...super.getEncodingProps(), ...encodingProps];\r\n  }      \r\n  \r\n  /**\r\n   * Enable self's \"view\" DispMode (used in top-level objects targeted by a tab).\r\n   *\r\n   * NOTE: this is also invoked prior to other display modes, as a neutral reset :-)\r\n   */\r\n  enableViewMode() {\r\n    // clear everything from any of the other DispModes\r\n    // ... sequentially follow each item in the \"other\" DispModes\r\n    this.konvaSceneLayer.getChildren().each( (konvaComp, n) => konvaComp.draggable(false) );\r\n    this.konvaSceneLayer.off('dragend');\r\n    this.containingKonvaStage.off('click tap');\r\n    this.containingKonvaStage.find('Transformer').destroy(); // remove any outstanding transformers\r\n    this.konvaSceneLayer.getChildren().each( (konvaComp, n) => konvaComp.off('transformend') );\r\n    this.konvaSceneLayer.draw();\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"edit\" DispMode (used in top-level objects targeted by a tab).\r\n   */\r\n  enableEditMode() {\r\n\r\n    //***\r\n    //*** enable dragging ... to all top-level konvaComps\r\n    //***\r\n\r\n    // draggable: enable (propagate into each top-level shape/group)\r\n    this.konvaSceneLayer.getChildren().each( (konvaComp, n) => konvaComp.draggable(true) );\r\n\r\n    // monitor events at the Konva Scene Layer level (using Event Delegation and Propagation)\r\n    // ... dragend: monitor x/y changes - syncing KonvaLayer INTO our Scene SmartObject\r\n    this.konvaSceneLayer.on('dragend', (e) => {\r\n\r\n      // locate our component matching the target Konva.Group\r\n      // ... we correlate the id's between Konva/SmartObject\r\n      const konvaObj = e.target;\r\n      const id       = konvaObj.id();\r\n      const comp     = this.comps.find( (comp) => comp.id === id );\r\n      // console.log(`xx Konva Scene Layer dragend: index: ${konvaObj.index}, id: ${konvaObj.id()}, name: ${konvaObj.name()} x: ${konvaObj.x()}, y: ${konvaObj.y()} ... e:\\n`, {e, comp});\r\n\r\n      // helpers to service undo/redo\r\n      // NOTE: we use this.konvaSceneLayer (a lower-level obj) NOT this.containingKonvaStage\r\n      // IMPORTANT: all updates must be written in such a way that DOES NOT reference stale objects\r\n      //            - when using undo/redo (over the course of time) objects may be \"swapped out\" via the synchronization process\r\n      //            - SOLUTION: resolve all objects from the \"id\" string AT RUN-TIME!!\r\n      const oldLoc = {\r\n        x: comp.x,\r\n        y: comp.y\r\n      };\r\n      const newLoc = {\r\n        x: konvaObj.x(),\r\n        y: konvaObj.y()\r\n      };\r\n      const syncSmartObject = (loc) => {\r\n        const comp = this.comps.find( (comp) => comp.id === id );\r\n        comp.x = loc.x;\r\n        comp.y = loc.y;\r\n        return comp;\r\n      }\r\n      const syncKonva = (loc) => {\r\n        const konvaObj = this.konvaSceneLayer.findOne(`#${id}`);\r\n        konvaObj.x(loc.x);\r\n        konvaObj.y(loc.y);\r\n        this.konvaSceneLayer.draw();\r\n      }\r\n\r\n      // apply our change\r\n      changeManager.applyChange({\r\n        changeFn(redo) {\r\n          const comp = syncSmartObject(newLoc);\r\n          redo && syncKonva(newLoc);\r\n          return comp;\r\n        },\r\n        undoFn() {\r\n          const comp = syncSmartObject(oldLoc);\r\n          syncKonva(oldLoc);\r\n          return comp;\r\n        }\r\n      });\r\n\r\n    });\r\n\r\n\r\n    //***\r\n    //*** enable transformations ... to all top-level konvaComps\r\n    //***\r\n\r\n    // monitor component selection via click events\r\n    // NOTE: a click event will not trigger on Layer but on the Stage object instead\r\n    //       ... see: https://konvajs.org/docs/events/Stage_Events.html\r\n    this.containingKonvaStage.on('click tap', (e) => {\r\n\r\n      // console.log(`xx TRANSFORM: target:\\n`, e.target);\r\n\r\n      // on void click: remove all transformers\r\n      if (e.target === this.containingKonvaStage) {\r\n        this.containingKonvaStage.find('Transformer').destroy();\r\n        this.konvaSceneLayer.draw();\r\n        return;\r\n      }\r\n\r\n      // remove old transformers\r\n      this.containingKonvaStage.find('Transformer').destroy();\r\n\r\n      // our real target is the top-level group (the konva representation of our component)\r\n      const konvaComp = ancestorOfLayer(e.target);\r\n\r\n      // create/manage new transformer\r\n      var transformer = new Konva.Transformer();\r\n      this.konvaSceneLayer.add(transformer);\r\n      transformer.attachTo(konvaComp);\r\n      this.konvaSceneLayer.draw();\r\n\r\n      // sync Konva changes to Object Model\r\n      konvaComp.on('transformend', (e) => { // ... NOTE: updates x/y/rotation/scaleX/scaleY ... NOT width/height at all\r\n\r\n        // AI: there is a Konva BUG: where the 'transformend' is fired multiple times per event\r\n        //     - not only is this bad from a performance perspective\r\n        //     - BUT IT HAS BAD side-effects related to undo\r\n        //     - research this:\r\n        //       KJB: appears to be related to \"deselecting\" the transformer when undo occurs\r\n        //            ... this is the normal scenario\r\n        //            ... KJB: I really don't like how Konva does selection in it's Transformer\r\n        //     - KJB: WORK-AROUND: no-op when Konva/SmartObject have the same transformation\r\n\r\n\r\n        // locate our component matching the target Konva.Group\r\n        // ... we correlate the id's between Konva/SmartObject\r\n        const konvaObj = e.target;\r\n        const id       = konvaObj.id();\r\n        const comp     = this.comps.find( (comp) => comp.id === id );\r\n        // console.log(`xx Konva Scene Layer transformend: x: ${konvaObj.x()}, y: ${konvaObj.y()}, rotation: ${konvaObj.rotation()}, scaleX: ${konvaObj.scaleX()}, scaleY: ${konvaObj.scaleY()},  ... matching comp: `, comp);\r\n\r\n        // helpers to service undo/redo\r\n        // NOTE: we use this.konvaSceneLayer (a lower-level obj) NOT this.containingKonvaStage\r\n        // IMPORTANT: all updates must be written in such a way that DOES NOT reference stale objects\r\n        //            - when using undo/redo (over the course of time) objects may be \"swapped out\" via the synchronization process\r\n        //            - SOLUTION: resolve all objects from the \"id\" string AT RUN-TIME!!\r\n        const oldTrans = {\r\n          x:        comp.x,\r\n          y:        comp.y,\r\n          rotation: comp.rotation,\r\n          scaleX:   comp.scaleX,\r\n          scaleY:   comp.scaleY,\r\n        };\r\n        const newTrans = {\r\n          x:        konvaObj.x(),\r\n          y:        konvaObj.y(),\r\n          rotation: konvaObj.rotation(),\r\n          scaleX:   konvaObj.scaleX(),\r\n          scaleY:   konvaObj.scaleY(),\r\n        };\r\n\r\n        // no-op when Konva/SmartObject have the same transformation\r\n        // ... see: WORK-AROUND Konva BUG (above)\r\n        if (isEqual(oldTrans, newTrans)) {\r\n          // console.log('xx Scene: transformEnd NO-OP (identical transformation to self) *********************');\r\n          return;\r\n        }\r\n\r\n        const syncSmartObject = (trans) => {\r\n          const comp    = this.comps.find( (comp) => comp.id === id );\r\n          comp.x        = trans.x;\r\n          comp.y        = trans.y;\r\n          comp.rotation = trans.rotation;\r\n          comp.scaleX   = trans.scaleX;\r\n          comp.scaleY   = trans.scaleY;\r\n          return comp;\r\n        }\r\n        const syncKonva = (trans) => {\r\n          const konvaObj = this.konvaSceneLayer.findOne(`#${id}`);\r\n          konvaObj.x(trans.x);\r\n          konvaObj.y(trans.y);\r\n          konvaObj.rotation(trans.rotation);\r\n          konvaObj.scaleX(trans.scaleX);\r\n          konvaObj.scaleY(trans.scaleY);\r\n          this.konvaSceneLayer.draw();\r\n        }\r\n\r\n        // apply our change\r\n        changeManager.applyChange({\r\n          changeFn(redo) {\r\n            const comp = syncSmartObject(newTrans);\r\n            redo && syncKonva(newTrans);\r\n            return comp;\r\n          },\r\n          undoFn() {\r\n            const comp = syncSmartObject(oldTrans);\r\n            syncKonva(oldTrans);\r\n            return comp;\r\n          }\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"animate\" DispMode (used in top-level objects targeted by a tab).\r\n   */\r\n  enableAnimateMode() {\r\n    // yet to do\r\n  }\r\n\r\n  \r\n  /**\r\n   * Verify self has been mounted.\r\n   * @param {string} [method] - the method name on which behalf we are checking.\r\n   */\r\n  checkMounted(method) {\r\n    verify(this.isMounted(), `${this.diagClassName()}.${method}() can only be invoked after mounting.`);\r\n  }\r\n\r\n  /**\r\n   * Mount the visuals of this scene, binding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * Prior to `mount()` execution, the visualize-it object\r\n   * representation is very lightweight.\r\n   *\r\n   * @param {Konva.Stage} containingKonvaStage - the container of\r\n   * this scene (a Konva.Stage).\r\n   */\r\n  mount(containingKonvaStage) { \r\n\r\n    // retain our stage for selected event processing\r\n    this.containingKonvaStage = containingKonvaStage;\r\n\r\n    // create our layer where our components will be mounted\r\n    this.konvaSceneLayer = new Konva.Layer({\r\n      id: this.id,\r\n      x:  this.x,\r\n      y:  this.y,\r\n    });\r\n\r\n    // mount our components into this layer\r\n    this.comps.forEach( (comp) => comp.mount(this.konvaSceneLayer) );\r\n\r\n    // wire our layer into the supplied containingKonvaStage\r\n    // ... NOTE: This must be added AFTER the layer is populated :-(\r\n    //           UNSURE WHY: seems like a Konva limitation :-(\r\n    containingKonvaStage.add(this.konvaSceneLayer)\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is mounted (i.e. bound to the Konva graphics).\r\n   *\r\n   * @returns {boolean} `true`: self is mounted, `false` otherwise\r\n   */\r\n  isMounted() {\r\n    return this.konvaSceneLayer ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Unmount the visuals of this scene, unbinding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * @param {boolean} [konvaPreDestroyed=false] - an internal\r\n   * parameter that indicates if konva nodes have already been\r\n   * destroyed (when a parent Konva.Node has already issued the\r\n   * konvaNode.destroy()).\r\n   */\r\n  unmount(konvaPreDestroyed=false) {\r\n    // destroy our Konva representation\r\n    // ... the Konva.destroy() is deep (clearing all containment)\r\n    // ... therefore, we do it conditionally, when not already accomplished by our parent\r\n    if (!konvaPreDestroyed) {\r\n      this.konvaSceneLayer.destroy();\r\n    }\r\n\r\n    // clear our konva state (established in our mount())\r\n    this.containingKonvaStage = null;\r\n    this.konvaSceneLayer      = null;\r\n    \r\n    // propagate request into our children\r\n    this.comps.forEach( (comp) => comp.unmount(true/*konvaPreDestroyed*/) );\r\n  }\r\n\r\n\r\n  /**\r\n   * Get self's current size (dynamically calculated).\r\n   *\r\n   * @returns {Size} self's current size ... {width, height}.\r\n   */\r\n  getSize() {\r\n    // cached size takes precedence\r\n    // ... this sizeCache will be re-set whenever size has the potential of changing:\r\n    //     - both in our initial mount (replacing \"approximation\" with \"exact\" size)\r\n    //     - and during interactive edit changes (reflecting an updated size)\r\n    // ... see: SmartModel.trickleUpChange()\r\n    if (this.sizeCache) {\r\n      return this.sizeCache;\r\n    }\r\n\r\n    // compute size\r\n    if (this.konvaSceneLayer) { // ... when mounted\r\n      // dynamically calculate the size from our Layer/Canvas content\r\n      const size = this.sizeCache = {width: 10, height: 10}; // ... minimum size\r\n      this.konvaSceneLayer.getChildren().each( (shape,n) => {\r\n        if (shape.getClassName() !== 'Transformer') { // ... really dislike how Konva does Transformer (making it part of our display list)\r\n          const shapeBounds = shape.getClientRect();  // ... consider transformation\r\n          size.width  = Math.max(size.width,  shapeBounds.x + shapeBounds.width   + containerSizeFudge);\r\n          size.height = Math.max(size.height, shapeBounds.y + shapeBounds.height  + containerSizeFudge); \r\n        }\r\n      });\r\n    }\r\n    else { // ... when NOT mounted\r\n      // provide initial size approximation (will be re-set when mounted)\r\n      // ... AI: depending on initial flicker (of size changing when mounted)\r\n      //         - OP1: persist the sizeCache\r\n      //                ... although doesn't help component classes (the class may contain an .approxSize property)\r\n      //         - OP1: hide content till fully mounted\r\n      //         - OP2: some polymorphic API for initialSize()/approxSize()/guesstimateSize()\r\n      //                ... UNSURE: in what object ... more research needed\r\n      this.sizeCache = {width: 100, height: 100};\r\n    }\r\n\r\n    return this.sizeCache;\r\n  }\r\n\r\n  /**\r\n   * Perform any static binding of self's size change (such as HTML or\r\n   * Konva bindings).\r\n   *\r\n   * @param {Size} oldSize - the previous size ... {width, height}.\r\n   * @param {Size} newSize - the new size ... {width, height}.\r\n   */\r\n  bindSizeChanges(oldSize, newSize) {\r\n    // sync our newSize to our Konva.Layer\r\n    // NOTE: This is NOT needed (even though originally I thought it was)\r\n    //        - according to the Konva docs, the width/height are taken from the parent stage\r\n    //          ... NOT the Layer/Canvas\r\n    //        - makes sense, because size is NOT set in any of our Layer/Canvas context\r\n    //          ... in our constructor() or our mount()\r\n    //       We must however define this method (as a no-op) to fulfill the SmartView.bindSizeChanges() abstraction\r\n    // no-op:\r\n    // this.konvaSceneLayer.size(newSize);\r\n    // this.konvaSceneLayer.draw();\r\n  }\r\n\r\n}\r\nScene.unmangledName = 'Scene';\r\n","/* eslint-disable react/no-is-mounted */ // isMount() usage is NOT react-based\r\nimport SmartPallet       from './SmartPallet';\r\nimport Scene             from './Scene';\r\nimport verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\nimport {changeManager}   from 'features/xtra';\r\n\r\n/**\r\n * Collage is a SmartPallet derivation in which multiple Scenes are displayed/visualized.\r\n */\r\nexport default class Collage extends SmartPallet {\r\n\r\n  /**\r\n   * Create a Collage.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this  collage.\r\n   * @param {string} [name=id] - The name of this collage (DEFAULT to id).\r\n   * @param {Scene[]} scenes - the scenes visualized by this collage.\r\n   */\r\n  constructor({id, name, scenes, ...unknownArgs}={}) {\r\n    super({id, name});\r\n\r\n    // validate Collage() constructor parameters\r\n    const check = verify.prefix(`${this.diagClassName()}(id:'${id}', name:'${name}') constructor parameter violation: `);\r\n\r\n    // ... id/name validated by base class\r\n\r\n    // ... scenes\r\n    check(scenes,                 'scenes is required');\r\n    check(Array.isArray(scenes),  'scenes must be an Scene[] array');\r\n    scenes.forEach( (scene, indx) => {\r\n      check(scene instanceof Scene, `scenes[${indx}] must be a Scene instance`);\r\n    });\r\n\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // retain derivation-specific parameters in self\r\n    this.scenes = scenes;\r\n\r\n    // maintain our parentage\r\n    this.scenes.forEach( (scene) => scene.setParent(this) );\r\n  }\r\n\r\n  // support persistance by encoding needed props of self\r\n  getEncodingProps() {\r\n    return [...super.getEncodingProps(), ...['scenes']];\r\n  }\r\n\r\n  \r\n  /**\r\n   * Enable self's \"view\" DispMode (used in top-level objects targeted by a tab).\r\n   *\r\n   * NOTE: this is also invoked prior to other display modes, as a neutral reset :-)\r\n   */\r\n  enableViewMode() {\r\n    // clear everything from any of the other DispModes\r\n    // ... sequentially follow each item in the \"other\" DispModes\r\n    this.scenes.forEach( (scene) => scene.konvaSceneLayer.draggable(false) );\r\n    this.containingKonvaStage.off('dragend');\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"edit\" DispMode (used in top-level objects targeted by a tab).\r\n   */\r\n  enableEditMode() {\r\n    // draggable: enable (propagate into each top-level scene)\r\n    this.scenes.forEach( (scene) => scene.konvaSceneLayer.draggable(true) );\r\n\r\n    // monitor events at the Konva Stage level (using Event Delegation and Propagation)\r\n    // ... dragend: monitor x/y changes - syncing KonvaLayer INTO our Scene SmartObject\r\n    this.containingKonvaStage.on('dragend', (e) => {\r\n\r\n      // locate our scene matching the event target Konva.Layer\r\n      // ... we correlate the id's between Konva/SmartObject\r\n      const konvaObj = e.target;\r\n      const id       = konvaObj.id();\r\n      const scene    = this.scenes.find( (scene) => scene.id === id );\r\n      // console.log(`xx Konva Stage dragend: index: ${konvaObj.index}, id: ${konvaObj.id()}, name: ${konvaObj.name()} x: ${konvaObj.x()}, y: ${konvaObj.y()} ... e:\\n`, {e, scene});\r\n\r\n      // helpers to service undo/redo\r\n      // IMPORTANT: all updates must be written in such a way that DOES NOT reference stale objects\r\n      //            - when using undo/redo (over the course of time) objects may be \"swapped out\" via the synchronization process\r\n      //            - SOLUTION: resolve all objects from the \"id\" string AT RUN-TIME!!\r\n      const oldLoc = {\r\n        x: scene.x,\r\n        y: scene.y\r\n      };\r\n      const newLoc = {\r\n        x: konvaObj.x(),\r\n        y: konvaObj.y()\r\n      };\r\n      const syncSmartObject = (loc) => {\r\n        const scene = this.scenes.find( (scene) => scene.id === id );\r\n        scene.x = loc.x;\r\n        scene.y = loc.y;\r\n        return scene;\r\n      }\r\n      const syncKonva = (loc) => {\r\n        const konvaObj = this.containingKonvaStage.findOne(`#${id}`);\r\n        konvaObj.x(loc.x);\r\n        konvaObj.y(loc.y);\r\n        this.containingKonvaStage.draw();\r\n      }\r\n\r\n      // apply our change\r\n      changeManager.applyChange({\r\n        changeFn(redo) {\r\n          const scene = syncSmartObject(newLoc);\r\n          redo && syncKonva(newLoc);\r\n          return scene;\r\n        },\r\n        undoFn() {\r\n          const scene = syncSmartObject(oldLoc);\r\n          syncKonva(oldLoc);\r\n          return scene;\r\n        }\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"animate\" DispMode (used in top-level objects targeted by a tab).\r\n   */\r\n  enableAnimateMode() {\r\n    // yet to do\r\n  }\r\n\r\n  /**\r\n   * Mount the visuals of this collage, binding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * Prior to `mount()` execution, the visualize-it object\r\n   * representation is very lightweight.\r\n   *\r\n   * @param {Konva.Stage} containingKonvaStage - The container of\r\n   * this collage (a Konva.Stage).\r\n   */\r\n  mount(containingKonvaStage) {\r\n    // retain containingKonvaStage for event handling\r\n    this.containingKonvaStage = containingKonvaStage;\r\n\r\n    // propagate this request to each of our scenes (one canvas per scene)\r\n    this.scenes.forEach( (scene) => scene.mount(containingKonvaStage) );\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is mounted (i.e. bound to the Konva graphics).\r\n   *\r\n   * @returns {boolean} `true`: self is mounted, `false` otherwise\r\n   */\r\n  isMounted() {\r\n    return this.containingKonvaStage ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Unmount the visuals of this collage, unbinding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * @param {boolean} [konvaPreDestroyed=false] - an internal\r\n   * parameter that indicates if konva nodes have already been\r\n   * destroyed (when a parent Konva.Node has already issued the\r\n   * konvaNode.destroy()).\r\n   */\r\n  unmount(konvaPreDestroyed=false) {\r\n    // clear our konva state (established in our mount())\r\n    this.containingKonvaStage = null;\r\n    \r\n    // propagate request into our children\r\n    this.scenes.forEach( (scene) => scene.unmount(konvaPreDestroyed) );\r\n  }\r\n\r\n  /**\r\n   * Replace self's child reference, defined by the specified params.\r\n   *\r\n   * @param {any} oldRef - the existing child to be replaced with\r\n   * `newRef`.\r\n   *\r\n   * @param {any} newRef - the new child to replace `oldRef`.\r\n   */\r\n  childRefChanged(oldRef, newRef) {\r\n    const indx = this.scenes.indexOf(oldRef);\r\n    if (indx !== -1) {\r\n      // console.log(`xx Collage.childRefChanged() ... replacing indx: ${indx}\\n`, {oldRef, newRef});\r\n      this.scenes[indx] = newRef;\r\n    }\r\n    else {\r\n      const msg = `***ERROR*** ${this.diagClassName()}.childRefChanged() [id:${this.id}]: could NOT find oldRef to replace (see logs for details)`;\r\n      console.error(msg+'\\n', {oldRef, newRef});\r\n      throw new Error(msg);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get self's current size (dynamically calculated).\r\n   *\r\n   * @returns {Size} self's current size ... {width, height}.\r\n   */\r\n  getSize() {\r\n    // cached size takes precedence\r\n    // ... this sizeCache will be re-set whenever size has the potential of changing:\r\n    //     - both in our initial mount (replacing \"approximation\" with \"exact\" size)\r\n    //     - and during interactive edit changes (reflecting an updated size)\r\n    // ... see: SmartModel.trickleUpChange()\r\n    if (this.sizeCache) {\r\n      return this.sizeCache;\r\n    }\r\n\r\n    // compute size\r\n    if (this.isMounted()) { // ... when mounted\r\n      // dynamically accumulate the size from our scenes\r\n      this.sizeCache = this.scenes.reduce( (accum, scene) => {\r\n\r\n        // recalculate this scene size\r\n        // KEY: we force the scene to recalculate it's size\r\n        //      ... by clearing it's sizeCache\r\n        //      BECAUSE our sizeCache has NOT been established (see above)\r\n        //      ... either first time, or something has changed\r\n        scene.sizeCache = undefined;\r\n        const sceneSize = scene.getSize();\r\n\r\n        // accumulate this scene size\r\n        // ... NOTE: the sceneSize already contains the scene.x/y offset\r\n        accum.width  = Math.max(accum.width,  sceneSize.width); \r\n        accum.height = Math.max(accum.height, sceneSize.height);\r\n        return accum;\r\n      }, {width:100, height:100}); // ... minimum size\r\n    }\r\n    else { // ... when NOT mounted\r\n      // provide initial size approximation (will be re-set when mounted)\r\n      // ... AI: depending on initial flicker (of size changing when mounted)\r\n      //         - OP1: persist the sizeCache\r\n      //                ... although doesn't help component classes (the class may contain an .approxSize property)\r\n      //         - OP1: hide content till fully mounted\r\n      //         - OP2: some polymorphic API for initialSize()/approxSize()/guesstimateSize()\r\n      //                ... UNSURE: in what object ... more research needed\r\n      this.sizeCache = {width: 200, height: 200};\r\n    }\r\n\r\n    return this.sizeCache;\r\n  }\r\n\r\n  /**\r\n   * Perform any static binding of self's size change (such as HTML or\r\n   * Konva bindings).\r\n   *\r\n   * @param {Size} oldSize - the previous size ... {width, height}.\r\n   * @param {Size} newSize - the new size ... {width, height}.\r\n   */\r\n  bindSizeChanges(oldSize, newSize) {\r\n    // propagate this to our scenes\r\n    // ... not really needed because our Scene currently no-ops (but that's OK)\r\n    this.scenes.forEach( (scene) => scene.bindSizeChanges(oldSize, newSize) );\r\n  }\r\n\r\n}\r\nCollage.unmangledName = 'Collage';\r\n","import Collage     from './Collage';\r\nimport PseudoClass from './PseudoClass';\r\nimport Scene       from './Scene';\r\nimport SmartPkg    from './SmartPkg';\r\nimport SmartView   from './SmartView';\r\nimport pkgManager  from './pkgManager';\r\n\r\n// register a silent package that resolves the core classes\r\n// ... needed for resource-based rehydration (i.e. persistance)\r\n// ... only core \"concrete\" classes that live in SmartPkgs are registered!\r\n//     - the advantage of NOT registering abstract classes is:\r\n//         it further highlights missing \"unmangledName\" class registrations,\r\n//         manifest in a persistance rehydration attempt to instantiate \r\n//         a \"non registered\" SmartModel (as an example)\r\npkgManager.registerPkg( new SmartPkg({\r\n  id:   'core',\r\n  name: 'core classes',\r\n  entries: {\r\n    core: [\r\n      Collage,\r\n//    PkgManager,       NOT: a service object NOT part of our persistent object model\r\n      PseudoClass,\r\n      Scene,\r\n//    SmartComp,        NOT: an abstract class (see docs above)\r\n//    SmartModel        NOT: an abstract class (see docs above)\r\n      SmartPkg,      // the root of our persistent model\r\n//    SmartPallet,      NOT: an abstract class (see docs above)\r\n      SmartView,\r\n    ],\r\n  },\r\n}) );\r\n","// various featureFlags used throughout the application\r\nexport default {\r\n\r\n  // should app use WIFI?\r\n  // ... regulates various services (real/mocked)\r\n  useWIFI: false,\r\n\r\n  // should app emit diagnostic logs?\r\n  //  - false:     no logs\r\n  //  - true:      generate 'non verbose' logs (e.g. actions will NOT include redux state)\r\n  //  - 'verbose': generate 'verbose'     logs (e.g. actions WILL     include redux state)\r\n  log:     false,\r\n\r\n  // should app enable diagnostic sandbox controls?\r\n  sandbox: true,\r\n};\r\n","/**\r\n * Escape all regular expression special characters.\r\n * \r\n * Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\n * \r\n * @param {string} str the string to escape.\r\n * \r\n * @return {string} the newly escaped string, representing the\r\n * supplied `str`.\r\n */\r\nfunction escapeRegExp(str) {\r\n  return str.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\r\n}\r\n\r\n/**\r\n * Replace all occurrences of `find` with `replace` in the supplied\r\n * `str`.\r\n * \r\n * @param {string} str the string to operate on.\r\n * @param {string} find the \"from\" string to be replaced.  Note that\r\n * all regular expression special characters are escaped.\r\n * @param {string} replace the \"to\" string to replace.\r\n * \r\n * @return {string} the newly replaced string.\r\n */\r\nexport function replaceAll(str, find, replace) {\r\n  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\r\n}\r\n","import Konva             from 'konva';\r\nimport SmartModel        from './SmartModel';\r\nimport verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\nimport {isNumber}        from 'util/typeCheck';\r\nimport DispMode          from './DispMode';\r\n\r\n/**\r\n * SmartComp is the abstract base class for all visualize-it\r\n * components.\r\n *\r\n * These are graphical representations of components found in a system:\r\n *\r\n *  - they bind to a data model (for visual affects and animation)\r\n *\r\n *  - their graphics are atomically managed (selection and transformation)\r\n *    ... using a single rooted Konva.Group\r\n *\r\n *  - NOTE: SmartComp is abstract requiring derivation (for code-based compPkgs)\r\n *          HOWEVER: there is a concrete derivation that supports \r\n *                   dynamic-based resource-loaded compPkgs\r\n *                   (maintained by the visualize-it component editor)\r\n *  \r\n *                 SmartComp        ... abstract\r\n *             isA   DynamicComp ... a concrete derivation for dynamic-based resource-loaded compPkgs\r\n *                                     ... managed by the visualize-it component editor\r\n *                   others      ... for code-based compPkgs\r\n */\r\nexport default class SmartComp extends SmartModel {\r\n\r\n  /**\r\n   * Create a SmartComp.\r\n   *\r\n   * **Please Note** this constructor uses named parameters.\r\n   *\r\n   * @param {string} id - the unique identifier of this component.\r\n   * @param {string} [name=id] - the human interpretable name of this\r\n   * component (DEFAULT to id).\r\n   *\r\n   * @param {number} [x=0] - the optional x offset within it's container (used in transformations of Scene container)\r\n   * @param {number} [y=0] - the optional y offset within it's container (used in transformations of Scene container)\r\n   * @param {number} [rotation=0] - the optional rotation within it's container (used in transformations of Scene container)\r\n   * @param {number} [scaleX=0] - the optional scaleX within it's container (used in transformations of Scene container)\r\n   * @param {number} [scaleY=0] - the optional scaleY within it's container (used in transformations of Scene container)\r\n   */\r\n  constructor({id, name, x=0, y=0, rotation=0, scaleX=1, scaleY=1, ...unknownArgs}={}) {\r\n    super({id, name});\r\n\r\n    // validate SmartComp() constructor parameters\r\n    const check = verify.prefix('SmartComp() constructor parameter violation: ');\r\n    // ... id/name validated by base class\r\n    // ... x\r\n    check(isNumber(x), `x must be a number (when supplied), NOT: ${x}`);\r\n    // ... y\r\n    check(isNumber(y), `y must be a number (when supplied), NOT: ${y}`);\r\n    // ... rotation\r\n    check(isNumber(rotation), `rotation must be a number (when supplied), NOT: ${rotation}`);\r\n    // ... scaleX\r\n    check(isNumber(scaleX), `scaleX must be a number (when supplied), NOT: ${scaleX}`);\r\n    // ... scaleY\r\n    check(isNumber(scaleY), `scaleY must be a number (when supplied), NOT: ${scaleY}`);\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n\r\n    // retain parameters in self\r\n    this.x        = x;\r\n    this.y        = y;\r\n    this.rotation = rotation;\r\n    this.scaleX   = scaleX;\r\n    this.scaleY   = scaleY;\r\n  }\r\n\r\n  // support persistance by encoding needed props of self\r\n  getEncodingProps() {\r\n    return [...super.getEncodingProps(), ...[['x',0], ['y',0], ['rotation',0], ['scaleX',1], ['scaleY',1]]];\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self supports the supplied `dispMode`.\r\n   *\r\n   * @param {DispMode} dispMode - the display mode to evaluate.\r\n   *\r\n   * @throws {boolean} true: can handle, false: not supported.\r\n   */\r\n  canHandleDispMode(dispMode) {\r\n    return dispMode !== DispMode.edit; // by default, SmartComps cannot be edited\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"view\" DispMode (used in top-level objects targeted by a tab).\r\n   *\r\n   * NOTE: this is also invoked prior to other display modes, as a neutral reset :-)\r\n   */\r\n  enableViewMode() {\r\n    // clear everything from any of the other DispModes\r\n    // ... sequentially follow each item in the \"other\" DispModes\r\n    // L8TR: do something when edit/animate is supported\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"edit\" DispMode (used in top-level objects targeted by a tab).\r\n   */\r\n  enableEditMode() {\r\n    // L8TR: do something when we support edit of DynamicComp\r\n  }\r\n\r\n  /**\r\n   * Enable self's \"animate\" DispMode (used in top-level objects targeted by a tab).\r\n   */\r\n  enableAnimateMode() {\r\n    // L8TR: do something when animate is supported\r\n  }\r\n\r\n  /**\r\n   * Mount the visuals of this component, binding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * Prior to `mount()` execution, the visualize-it object\r\n   * representation is very lightweight.\r\n   *\r\n   * @param {Konva.Layer} containingKonvaLayer - The container of\r\n   * this component (a Konva.Layer).\r\n   */\r\n  mount(containingKonvaLayer) {\r\n    // create our top-level group containing our component sub-shapes\r\n    // ... this is an expected setup to allow components to be treated as an atomic unit\r\n    this.compGroup = new Konva.Group({\r\n      id: this.id,\r\n      x:  this.x,\r\n      y:  this.y,\r\n      rotation: this.rotation,\r\n      scaleX:   this.scaleX,\r\n      scaleY:   this.scaleY,\r\n    });\r\n    containingKonvaLayer.add(this.compGroup);\r\n  }\r\n\r\n  /**\r\n   * Return an indicator as to whether self is mounted (i.e. bound to the Konva graphics).\r\n   *\r\n   * @returns {boolean} `true`: self is mounted, `false` otherwise\r\n   */\r\n  isMounted() {\r\n    return this.compGroup ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Unmount the visuals of this component, unbinding the graphics to the\r\n   * underlying canvas.\r\n   *\r\n   * @param {boolean} [konvaPreDestroyed=false] - an internal\r\n   * parameter that indicates if konva nodes have already been\r\n   * destroyed (when a parent Konva.Node has already issued the\r\n   * konvaNode.destroy()).\r\n   */\r\n  unmount(konvaPreDestroyed=false) {\r\n    // destroy our Konva representation\r\n    // ... the Konva.destroy() is deep (clearing all containment)\r\n    // ... therefore, we do it conditionally, when not already accomplished by our parent\r\n    if (!konvaPreDestroyed) {\r\n      this.compGroup.destroy();\r\n    }\r\n\r\n    // clear our konva state (established in our mount())\r\n    this.compGroup = null;\r\n    \r\n    // N/A: this is the lowest level :-)\r\n    // propagate request into our children\r\n  }\r\n\r\n}\r\nSmartComp.unmangledName = 'SmartComp';\r\n","import Konva          from 'konva';\r\nimport SmartComp      from 'core/SmartComp';\r\nimport SmartPkg       from 'core/SmartPkg';\r\nimport pkgManager     from 'core/pkgManager';\r\n\r\nclass Valve1 extends SmartComp {\r\n\r\n  // eslint: no-useless-constructor\r\n  // constructor(namedParams) {\r\n  //   super(namedParams);\r\n  // }\r\n\r\n  // NOTE: this component demonstrates multi shapes grouped in a compGroup\r\n  mount(containingKonvaLayer) {\r\n    super.mount(containingKonvaLayer); // defines: this.compGroup\r\n\r\n    const shape1 = new Konva.Rect({\r\n      x: 10, // sub-shape location\r\n      width: 100,\r\n      height: 50,\r\n      fill: 'green',\r\n      stroke: 'black',\r\n      strokeWidth: 5,\r\n    });\r\n    this.compGroup.add(shape1);\r\n\r\n    const connector1 = new Konva.Circle({\r\n      x: 5+2.5, // consider x/strokeWidth (above)\r\n      y: 25,\r\n      radius: 5,\r\n      fill: 'black',\r\n      stroke: 'black',\r\n      strokeWidth: 5,\r\n    });\r\n    this.compGroup.add(connector1);\r\n\r\n    const connector2 = new Konva.Circle({\r\n      x: 5+100+5, // consider x/width/strokeWidth (above)\r\n      y: 25,\r\n      radius: 5,\r\n      fill: 'black',\r\n      stroke: 'black',\r\n      strokeWidth: 5,\r\n    });\r\n    this.compGroup.add(connector2);\r\n\r\n    // setup a sub-group JUST to insure (test) our algorithms can find/use the top-level group\r\n    const subGroup = new Konva.Group({\r\n      x: 0, // NOTE: cannot be based on this.x, RATHER a constant\r\n      y: 0, //       BECAUSE this.compGroup reflects the transformation parameters (so we can't apply the transformations multiple times)\r\n    });\r\n    this.compGroup.add(subGroup);\r\n\r\n    const subCircle = new Konva.Circle({\r\n      x: 10+(100/2), // WHY no strokeWidth: +2.5\r\n      y: 0+(50/2),   // WHY no strokeWidth: +2.5\r\n      radius: 10,\r\n      fill: 'red',\r\n      stroke: 'red',\r\n      strokeWidth: 1,\r\n    });\r\n    subGroup.add(subCircle);\r\n  }\r\n}\r\nValve1.unmangledName = 'Valve1';\r\n\r\nclass Valve2 extends SmartComp {\r\n\r\n  // eslint: no-useless-constructor\r\n  // constructor(namedParams) {\r\n  //   super(namedParams);\r\n  // }\r\n\r\n  mount(containingKonvaLayer) {\r\n    super.mount(containingKonvaLayer); // defines: this.compGroup\r\n\r\n    const shape = new Konva.Rect({\r\n      width: 100,\r\n      height: 50,\r\n      fill: 'red',\r\n      shadowBlur: 10,\r\n      cornerRadius: 10\r\n    });\r\n    this.compGroup.add(shape);\r\n  }\r\n}\r\nValve2.unmangledName = 'Valve2';\r\n\r\nclass Valve3 extends SmartComp {\r\n\r\n  // eslint: no-useless-constructor\r\n  // constructor(namedParams) {\r\n  //   super(namedParams);\r\n  // }\r\n\r\n  mount(containingKonvaLayer) {\r\n    super.mount(containingKonvaLayer); // defines: this.compGroup\r\n\r\n    const shape = new Konva.Rect({\r\n      width:  100,\r\n      height: 100,\r\n      fill: 'blue',\r\n      cornerRadius: [0, 10, 20, 30]\r\n    });\r\n    this.compGroup.add(shape);\r\n  }\r\n}\r\nValve3.unmangledName = 'Valve3';\r\n\r\n// our sandbox code-based component package\r\n// ... registered in our sandbox feature appInit()\r\nconst generalCompsPkg = new SmartPkg({\r\n  id:   'generalComps',\r\n  name: 'SandBox Comps',\r\n  entries: {\r\n    \"Class Comps\": [\r\n      Valve1,\r\n      Valve2,\r\n      Valve3,\r\n    ],\r\n  },\r\n});\r\n\r\n// register these components, supporting persistent file resolution\r\npkgManager.registerPkg(generalCompsPkg);\r\n","import Collage        from 'core/Collage';\r\nimport Scene          from 'core/Scene';\r\nimport SmartClassRef  from 'core/SmartClassRef';\r\nimport SmartPkg       from 'core/SmartPkg';\r\nimport pkgManager     from 'core/pkgManager';\r\nimport {replaceAll}   from 'util/strUtil';\r\nimport {createLogger} from 'util/logger';\r\nimport                     './generalComps'; // unnamed import activating it's package registration\r\n\r\nconst log = createLogger('***DIAG*** konvaSandboxSmartPkg ... ').disable(); // enable this to see JSON in logs\r\n\r\nconst Valve1 = pkgManager.getClassRef('generalComps', 'Valve1');\r\nconst Valve2 = pkgManager.getClassRef('generalComps', 'Valve2');\r\nconst Valve3 = pkgManager.getClassRef('generalComps', 'Valve3');\r\n\r\n\r\n//************************************************************************************\r\n//*** Scene: scene1\r\n//************************************************************************************\r\n\r\nconst scene1 = new Scene({\r\n  id: 'scene1',\r\n  comps: [\r\n    Valve1.createSmartObject({id: 'myValve1', x:  20, y:  20}),\r\n    Valve2.createSmartObject({id: 'myValve2', x: 150, y:  40}),\r\n    Valve3.createSmartObject({id: 'myValve3', x:  50, y: 120}),\r\n  ],\r\n});\r\n\r\n\r\n//************************************************************************************\r\n//*** Scene: scene2\r\n//************************************************************************************\r\n\r\nconst scene2 = new Scene({\r\n  id: 'scene2',\r\n  comps: [\r\n    Valve1.createSmartObject({id: 'myValve1', x:  20, y:  20}),\r\n    Valve2.createSmartObject({id: 'myValve2', x: 150, y:  40}),\r\n  ],\r\n});\r\n\r\n\r\n//**********************************************************\r\n//*** Collage: collage1\r\n//**********************************************************\r\n\r\n// create an instance of type scene1 (to live in our collage)\r\n//const scene1ClassRef = pkgManager.getClassRef('sceneView1', 'scene1'); // NORMALLY HOW DONE - HOWEVER we don't have a pkg yet\r\nconst scene1ClassRef = new SmartClassRef(scene1, 'DUMMY-PKG-NAME');      // DO THIS INSTEAD ... NOTE: this DUMMY-PKG-NAME is NOT propagated into any persistence!\r\nconst scene1Copy     = scene1ClassRef.createSmartObject({\r\n  id: 'scene1Copy',\r\n  // comps: [ // KOOL: do NOT need comps ... they are created (cloned) from the scene1 pseudoClass!\r\n  //          new Valve1({id: 'myValve1'}),\r\n  //          new Valve2({id: 'myValve2'}),\r\n  //          new Valve3({id: 'myValve3'}),\r\n  // ],\r\n  x:0,\r\n  y:0,\r\n});\r\n\r\n// create an instance of type scene2 (to live in our collage)\r\n//const scene2ClassRef = pkgManager.getClassRef('sceneView2', 'scene2'); // NORMALLY HOW DONE - HOWEVER we don't have a pkg yet\r\nconst scene2ClassRef = new SmartClassRef(scene2, 'DUMMY-PKG-NAME');      // DO THIS INSTEAD ... NOTE: this DUMMY-PKG-NAME is NOT propagated into any persistence!\r\nconst scene2Copy     = scene2ClassRef.createSmartObject({\r\n  id: 'scene2Copy',\r\n  // comps: [ // KOOL: do NOT need comps ... they are created (cloned) from the scene2 pseudoClass!\r\n  //   new Valve1({id: 'myValve1'}),\r\n  //   new Valve2({id: 'myValve2'}),\r\n  //   // new Valve3({id: 'myValve3'}), // omit JUST to make it different\r\n  // ],\r\n  x:300,\r\n  y:250,\r\n});\r\n\r\n// our Collage\r\nconst collage1 = new Collage({id: 'collage1', name: 'Collage 1', scenes: [scene1Copy, scene2Copy]});\r\n\r\n\r\n//******************************************************************************\r\n//*** konvaSandboxSmartPkg: our FIRST smartPkg!!\r\n//******************************************************************************\r\n\r\nconst konvaSandboxSmartPkg = new SmartPkg({\r\n  id:   'com.astx.KONVA',\r\n  name: 'Konva Sandbox I',\r\n  entries: {\r\n    scenes: [\r\n      scene1,\r\n      { // ... nested sub-entries mixed in with our tabs\r\n        \"More Depth\": [\r\n          scene2,\r\n        ],\r\n      },\r\n    ],\r\n    collages: [\r\n      collage1,\r\n    ],\r\n  },\r\n});\r\n\r\npkgManager.registerPkg(konvaSandboxSmartPkg);\r\n\r\n\r\n//******************************************************************************\r\n//*** CRUDE TEST: Exercise clone process to insure NO runtime errors :-)\r\n//******************************************************************************\r\n\r\n// clone konvaSandboxSmartPkg\r\nconst clonedPkg = konvaSandboxSmartPkg.smartClone();\r\n\r\n// rename, so clonedPkg can co-exist (in pkgManager) with konvaSandboxSmartPkg\r\n// ... NOTE: Even with this rename, the clonedPkg will retain the original\r\n//           self referenced pkg of: \"com.astx.KONVA\"\r\n//           ... SO the konvaSandboxSmartPkg must be pre-registered for \r\n//               the clonedPkg to operate\r\nclonedPkg.id   = 'cloned.pkg';\r\nclonedPkg.name = 'Cloned Pkg';\r\n// ... simulate what would happen if the manual change above was in our controlled environment\r\nclonedPkg.trickleUpChange(); // ... sync the change\r\n// ... re-baseline the baseCrc (so it doesn't start out needing to be saved)\r\nclonedPkg.resetBaseCrc();\r\n\r\n// register clonedPkg to our pkgManager\r\npkgManager.registerPkg(clonedPkg);\r\n\r\n\r\n\r\n//******************************************************************************\r\n//*** CRUDE TEST: Exercise JSON persistance to insure NO runtime errors :-)\r\n//******************************************************************************\r\n\r\n// You can use the logged JSON to prime-the-pump, manually placing in a visualize-it file, and loading it in the system\r\n// 1. enable the log control (at the top of this file) to see the JSON in our logs\r\n// 2. mouse the JSON string (found in logs)\r\n// 3. into a file (ex: C:\\Users\\kevin\\Dropbox\\Camera Uploads\\visualize-it\\myFirst.vit)\r\n// 4. load the package from that file (via the visualize-it file menu)\r\n\r\n// convert to JSON\r\nlog(`PERSISTENT TEST: JSONIZE smartPkg:\\n`, {konvaSandboxSmartPkg});\r\nconst json = konvaSandboxSmartPkg.toSmartJSON();\r\nlog(`PERSISTENT TEST: HERE is the json:\\n`, {json});\r\n\r\n// for this conversion to be self-sufficient, we need to change the pkgId/pkgName in the JSON\r\nconst pkgId   = konvaSandboxSmartPkg.id;\r\nconst pkgName = konvaSandboxSmartPkg.name;\r\nlet   jsonStr = JSON.stringify(json, null, 2);\r\njsonStr = replaceAll(jsonStr,          // pkgId (including any self referenced pkgId)\r\n                     `\"${pkgId}\"`,     //   ex: \"com.astx.KONVA\"\r\n                     `\"${pkgId}2\"`);   //   ex: \"com.astx.KONVA2\"\r\njsonStr = replaceAll(jsonStr,          // pkgName\r\n                     `\"${pkgName}\"`,   //   ex: \"Konva Sandbox I\"\r\n                     `\"${pkgName}I\"`); //   ex: \"Konva Sandbox II\"\r\nlog(`PERSISTENT TEST: HERE is the \"pretty\" jsonStr (after id changes):\\n`, jsonStr);\r\n\r\n// rehydrate the JSON back to a SmartPkg object\r\nconst rehydratedSmartPkg = SmartPkg.fromSmartJSON(JSON.parse(jsonStr));\r\nlog(`PERSISTENT TEST: HERE is the RE-HYDRATED smartPkg:\\n`, {rehydratedSmartPkg});\r\n","import {createFeature}  from 'feature-u';\r\nimport featureFlags     from 'featureFlags'\r\nimport {leftNavManager} from 'features/xtra';\r\nimport pkgManager       from 'core/pkgManager';\r\nimport                  './konvaSandbox/konvaSandboxSmartPkg'; // unnamed import activating it's package registration\r\n\r\n// feature: sandbox\r\n//          sandbox to play with konva.js\r\nexport default createFeature({\r\n  name:    'sandbox',\r\n\r\n  enabled: featureFlags.sandbox,\r\n\r\n  // register sandbox LeftNav packages\r\n  appInit({showStatus, fassets, getState, dispatch}) {\r\n\r\n    // our sandbox code-based component package\r\n    const generalCompsPkg = pkgManager.getPkg('generalComps');\r\n    leftNavManager.addLeftNav(generalCompsPkg);\r\n\r\n    // our sandbox resource-based system package\r\n    const konvaSandboxSmartPkg = pkgManager.getPkg('com.astx.KONVA');\r\n    leftNavManager.addLeftNav(konvaSandboxSmartPkg);\r\n\r\n    // our clonedPkg\r\n    const clonedPkg = pkgManager.getPkg('cloned.pkg');\r\n    leftNavManager.addLeftNav(clonedPkg);\r\n  },\r\n});\r\n","import verify          from 'util/verify';\r\nimport {isString,\r\n        isPlainObject} from 'util/typeCheck';\r\n\r\n\r\n/**\r\n * Encode the supplied ref into a string representation.\r\n *\r\n * - supporting an optional safeguard (obfuscate content making it\r\n *   obscure to public visibility)\r\n *\r\n * - employing embedded-recognition so the process can be reversed using\r\n *   self-recognition\r\n *\r\n * TERMINOLOGY:\r\n *\r\n * - encode:  package content into a string representation (which can\r\n *            be reversed) ... ex: obj2str\r\n *\r\n * - decode:  reverse the process of encode()\r\n *\r\n * - safeguard: obfuscate content so as to make it obscure to public\r\n *              visibility\r\n *              NOTE: this is a \"lighter weight\" process than full\r\n *                    encryption\r\n *\r\n * - embedded-recognition: the ability to recognize and reverse the\r\n *                         process of either encoding and/or\r\n *                         safeguarding, producing the original\r\n *                         ref (that was originally encoded)\r\n *\r\n * @param {string|jsonObj} ref the reference to encode\r\n * @param {boolean} [safeguard=false] an indicator as to whether the\r\n * result should be obfuscated (true) or not (false - the DEFAULT).\r\n * \r\n * @return {string} an encoded representation of the supplied ref.\r\n */\r\nexport function encode(ref, safeguard=false) {\r\n\r\n  // validate our parameters\r\n  const check = verify.prefix('encode(ref) parameter violation: ');\r\n\r\n  // ... ref\r\n  check(ref,                                 'ref is required');\r\n  check(isString(ref) || isPlainObject(ref), 'ref must be a string -or- an object literal. NOT: ', ref);\r\n\r\n  // ... safeguard\r\n  check(safeguard===true || safeguard===false, 'safeguard must be a boolean (true/false), NOT: ', safeguard);\r\n\r\n  // encode the supplied ref into a string representation\r\n  let encoding = ref;            // ... by default, a string is left un-touched\r\n  if (isPlainObject(encoding)) { // ... encode objects\r\n    encoding = demarkObjEncoding + JSON.stringify(encoding);\r\n  }\r\n\r\n  // safeguard, when requested\r\n  if (safeguard) {\r\n    encoding = demarkSafeguard + obfuscate(encoding);\r\n  }\r\n\r\n  // thats all folks :-)\r\n  return encoding;\r\n}\r\n\r\n\r\n/**\r\n * Decode the supplied ref, reversing the process of `encode()`.\r\n * \r\n * NOTE: `decode()` can be invoked on a non-encoded ref, in which case\r\n *       it will simply pass-through the un-encoded ref.  This is a\r\n *       convenience, and is made possible by embedded-recognition.\r\n * \r\n * @param {any} ref the reference object to decode ... either the\r\n * output of `encode()` (a recognized encoded string), or any other\r\n * reference (simply passed-through).\r\n * \r\n * @return {any} the decoded representation of the supplied ref.\r\n */\r\nexport function decode(ref) {\r\n\r\n  // validate our parameters\r\n  const check = verify.prefix('decode(ref) parameter violation: ');\r\n\r\n  // ... ref\r\n  check(ref, 'ref is required');\r\n\r\n  // simply pass-through any non-strig ref\r\n  if (!isString(ref)) {\r\n    return ref;\r\n  }\r\n\r\n  // KEY: at this point we know ref is a string :-)\r\n  let result = ref;\r\n\r\n  // unwind any safeguards\r\n  if (result.indexOf(demarkSafeguard) === 0) {\r\n    result = result.substring(demarkSafeguard.length);\r\n    result = deobfuscate(result);\r\n  }\r\n\r\n  // unwind any encodings\r\n  if (result.indexOf(demarkObjEncoding) === 0) {\r\n    result = result.substring(demarkObjEncoding.length);\r\n    result = JSON.parse(result);\r\n  }\r\n\r\n  // thats all folks :-)\r\n  return result;\r\n}\r\n\r\n// embedded-recognition keywords\r\nconst demarkObjEncoding = 'obj2str:';\r\nconst demarkSafeguard   = 'afesa'; // ... use a obsecure phrase, so as to NOT \"stand out\"\r\n                                   //     - pig Latin for \"safe\"\r\n                                   //     - preventing it from being uniquely identified\r\n                                   //       and harvested within a global deployment\r\n\r\n\r\nfunction obfuscate(str) {\r\n  if (!window.btoa) {\r\n    throw new Error('*** ERROR *** encode(): ENCODING NOT supported by this browser (btoa).');\r\n  }\r\n  const encoding = window.btoa(str);\r\n  return encoding;\r\n}\r\n\r\nfunction deobfuscate(str) {\r\n  if (!window.atob) {\r\n    throw new Error('*** ERROR *** encode(): DECODING NOT supported by this browser (atob).');\r\n  }\r\n  const clearTxt = window.atob(str);\r\n  return clearTxt;\r\n}\r\n","import firebase  from 'firebase/app';\r\nimport {decode}  from 'util/encoder';\r\n\r\n// initialize the Google Firebase service\r\n// ... a feature-u app-life-cycle-hook\r\nexport default async function initializeFirebase({showStatus, fassets, getState, dispatch}) {\r\n\r\n  // inform user what we are doing\r\n  showStatus('Initializing Firebase');\r\n  \r\n  // fetch our FireBase App Configuration from our own deployment site: `public/fbac`\r\n  const resp = await fetch('fbac'); // NOTE: relative path support server deployment in sub-directory\r\n  \r\n  // console.log(`xx resp.ok: ${resp.ok}, resp.status: ${resp.status} ... resp: `, resp);\r\n  if (!resp.ok) {\r\n    // NOTE: Due to routing considerations, a non-existent resource is allowed,\r\n    //       AND returns the entire content of index.html\r\n    //       IN OTHER WORDS: this condition is NEVER EXECUTED (i.e. resp.ok is ALWAYS true)\r\n    //       ... (see check below)\r\n    throw new Error(`**ERROR** Accessing /fbac resource was REJECTED with status: ${resp.status}`);\r\n  }\r\n  \r\n  // convert response to text\r\n  const txt = await resp.text();\r\n  \r\n  // check for non-existent resource (see NOTE above)\r\n  if (txt.includes('<html')) {\r\n    // NOTE: this is the only real error we will ever emit\r\n    throw new Error(`**ERROR** Non Existent Resource: /fbac`);\r\n  }\r\n  \r\n  // decode our credentials\r\n  // console.log(`xx /fbac resource content: '${txt}'`);\r\n  const firebaseAppConfig = decode(txt);\r\n  // console.log('xx firebaseAppConfig: ', firebaseAppConfig);\r\n  \r\n  // process our credentials\r\n  // NOTE: THE initializeApp() invocation generates absolutely NO error condition\r\n  //       - for example if the API key is invalid it executes through (even with a try/catch), \r\n  //         and we receive runtime errors when attempting to use the service (ex: login screen)\r\n  //         ... Error: Your API key is invalid, please check you have copied it correctly.\r\n  await firebase.initializeApp(firebaseAppConfig);\r\n}\r\n","import {createFeature}     from 'feature-u';\r\nimport featureFlags        from 'featureFlags';\r\nimport initializeFirebase  from './initializeFirebase';\r\n\r\n// feature: initFirebase\r\n//          initialize the Google Firebase service (when needed)\r\nexport default createFeature({\r\n  name: 'initFirebase',\r\n\r\n  // firebase is only required when we are using real services (i.e. when WIFI enabled)\r\n  enabled: featureFlags.useWIFI,\r\n\r\n  appInit: initializeFirebase,\r\n});\r\n","import {generateActions} from 'action-u';\r\nimport _baseUI           from './featureName';\r\n\r\nexport default generateActions.root({\r\n  [_baseUI]: { // prefix all actions with our feature name, guaranteeing they unique app-wide!\r\n\r\n    toggleUITheme: { // actions.toggleUITheme(): Action\r\n                     // > toggle the UI Theme ('light'/'dark')\r\n                     actionMeta: {},\r\n    },\r\n\r\n    setResponsiveMode: {  // actions.setResponsiveMode(responsiveMode): Action\r\n                          // > change the responsiveMode to the supplied value ('md'/'lg'/'off')\r\n                          actionMeta: {\r\n                            traits: ['responsiveMode'],\r\n                          },\r\n    },\r\n\r\n    changeView: {  // actions.changeView(viewName): Action\r\n                   // > change the curView to the supplied viewName\r\n                   actionMeta: {\r\n                     traits: ['viewName'],\r\n                   },\r\n    },\r\n\r\n    addLeftNavItem: { // actions.addLeftNavItem(leftNavKey, LeftNavComp): Action\r\n                      // > add a new LeftNav menu item to the LeftNav (ordered by leftNavKey)\r\n                      actionMeta: {\r\n                        traits: ['leftNavKey', 'LeftNavComp'],\r\n                      },\r\n    },\r\n\r\n    removeLeftNavItem: { // actions.removeLeftNavItem(leftNavKey): Action\r\n                         // > removed the supplied LeftNav menu item\r\n                         actionMeta: {\r\n                           traits: ['leftNavKey'],\r\n                         },\r\n    },\r\n\r\n  },\r\n});\r\n","/**\r\n * Expose our featureName through a mini-meta module that is\r\n * \"importable\" in all use-cases (a single-source-of-truth).\r\n */\r\nexport default 'baseUI';\r\n","/**\r\n * A \"no op\" function that does absolutely nothing (think IEFBR14 :-)\r\n */\r\nexport default function noOp() {\r\n}\r\n","import verify          from 'util/verify';\r\nimport {isString,\r\n        isPlainObject} from 'util/typeCheck';\r\nimport noOp            from 'util/noOp';\r\nimport {encode,\r\n        decode}        from 'util/encoder';\r\n\r\n/**\r\n * Store the supplied entry in local device storage.\r\n *\r\n * @param {string} key the unique key that catalogs this entry.\r\n * @param {string|jsonObj} ref the reference to store.\r\n * @param {boolean} [safeguard=false] an indicator as to whether the\r\n * entry should be obfuscated (true) or not (false - the DEFAULT).\r\n */\r\nexport function storeItem(key, ref, safeguard=false) {\r\n\r\n  // validate our parameters\r\n  const check = verify.prefix('storeItem() parameter violation: ');\r\n\r\n  // ... key\r\n  check(key,           'key is required');\r\n  check(isString(key), 'key must be a string, NOT: ', key);\r\n\r\n  // ... ref\r\n  check(ref,                                 'ref is required');\r\n  check(isString(ref) || isPlainObject(ref), 'ref must be a string -or- an object literal, NOT: ', ref);\r\n\r\n  // ... safeguard\r\n  check(safeguard===true || safeguard===false, 'safeguard must be a boolean (true/false), NOT: ', safeguard);\r\n\r\n  // encode the supplied ref into a string representation\r\n  // SUPPORTING:\r\n  //   - object encoding (to a string representation)\r\n  //     NOTE: plain strings are NOT altered in this operation\r\n  //   - safeguard (obfuscation)\r\n  const value = encode(ref, safeguard);\r\n\r\n  // store the entry into our deviceStorage\r\n  deviceStorage.setItem(key, value);\r\n}\r\n\r\n\r\n/**\r\n * Fetch the stored entry from local device storage.\r\n *\r\n * @param {string} key the unique key that catalogs this entry.\r\n * \r\n * @return {any} the entry stored from the supplied key (null for\r\n * none), implicitly unpacked to the original ref (supplied to\r\n * `storeItem()`).\r\n */\r\nexport function fetchItem(key) {\r\n\r\n  // validate our parameters\r\n  const check = verify.prefix('fetchItem() parameter violation: ');\r\n\r\n  // ... key\r\n  check(key,           'key is required');\r\n  check(isString(key), 'key must be a string, NOT: ', key);\r\n\r\n  // retrieve the entry from our deviceStorage\r\n  const value = deviceStorage.getItem(key);\r\n\r\n  // no-op for non-existent entries\r\n  if (!value) {\r\n    return null;\r\n  }\r\n\r\n  // decode the entry, unpacking it into the original form (ref)\r\n  const ref = decode(value);\r\n\r\n  // that's all folks :-)\r\n  return ref;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Remove the stored entry from local device storage.\r\n *\r\n * @param {string} key the unique key of the entry to remove.\r\n */\r\nexport function removeItem(key) {\r\n\r\n  // validate our parameters\r\n  const check = verify.prefix('removeItem() parameter violation: ');\r\n\r\n  // ... key\r\n  check(key,           'key is required');\r\n  check(isString(key), 'key must be a string, NOT: ', key);\r\n\r\n  // remove the entry from our local device storage\r\n  deviceStorage.removeItem(key);\r\n}\r\n\r\n\r\n\r\n\r\n//***\r\n//*** Abstract the Web Storage API (gracefully no-oping for unsupported browsers)\r\n//***\r\n//***  NOTE 1: This API is synchronous!\r\n//***  NOTE 2: Apparently this API is available on both http (non SSL) as well as https (SSL).\r\n//***\r\n\r\n// feature detection\r\n// ... NOTE: can't just assert window.localStorage exists\r\n//           see: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\r\nconst _localStorageAvailable = storageAvailable('localStorage');\r\nfunction storageAvailable(type) {\r\n  let storage;\r\n  try {\r\n    storage = window[type];\r\n    let x = '__storage_test__';\r\n    storage.setItem(x, x);\r\n    storage.removeItem(x);\r\n    return true;\r\n  }\r\n  catch(e) {\r\n    return e instanceof DOMException && (\r\n      // everything except Firefox\r\n      e.code === 22 ||\r\n      // Firefox\r\n      e.code === 1014 ||\r\n      // test name field too, because code might not be present\r\n      // everything except Firefox\r\n      e.name === 'QuotaExceededError' ||\r\n      // Firefox\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n           // acknowledge QuotaExceededError only if there's something already stored\r\n           (storage && storage.length !== 0);\r\n  }\r\n}\r\n\r\n// log warning when deviceStorage is NOT in affect\r\nif (!_localStorageAvailable) {\r\n  console.warn('***WARNING*** deviceStorage module ... localStorage (Web Storage API) is NOT available in this browser ... all deviceStorage usage will silently no-op!!');\r\n}\r\n\r\n// our localStorage pass-through that gracefully no-ops for unsupported browsers\r\nconst deviceStorage = _localStorageAvailable ? {\r\n  setItem:    (keyName, keyValue) => window.localStorage.setItem(keyName, keyValue),\r\n  getItem:    (keyName)           => window.localStorage.getItem(keyName),\r\n  removeItem: (keyName)           => window.localStorage.removeItem(keyName),\r\n} : {\r\n  setItem:    noOp,\r\n  getItem:    noOp,\r\n  removeItem: noOp,\r\n};\r\n\r\n// TEMP crude test of deviceStorage ... invoke these separately!\r\n// deviceStorage.setItem('WowZeeKey', 'WowZeeValue');\r\n// console.log(`test deviceStorage ... '${deviceStorage.getItem('WowZeeKey')}'`);\r\n","import {storeItem,\r\n        fetchItem,\r\n        removeItem}   from 'util/deviceStorage';\r\n\r\n/**\r\n * Store uiTheme on local device.\r\n * \r\n * @param {string} uiTheme the UI Theme to store.\r\n */\r\nexport function storeUITheme(uiTheme) {\r\n  storeItem(uiThemeKey, uiTheme);\r\n}\r\n\r\n/**\r\n * Fetch uiTheme stored on local device (if any).\r\n * \r\n * @return {string} the persisted UI Theme (null for none).\r\n */\r\nexport function fetchUITheme() {\r\n  return fetchItem(uiThemeKey);\r\n}\r\n\r\n/**\r\n * Remove uiTheme from local device.\r\n */\r\nexport function removeUITheme() {\r\n  removeItem(uiThemeKey);\r\n}\r\n\r\nconst uiThemeKey = 'uiTheme';\r\n","import {storeItem,\r\n        fetchItem,\r\n        removeItem}   from 'util/deviceStorage';\r\n\r\n/**\r\n * Store the responsiveMode on local device.\r\n * \r\n * @param {string} responsiveMode the \"responsive mode\" to store.\r\n */\r\nexport function storeResponsiveMode(responsiveMode) {\r\n  storeItem(responsiveModeKey, responsiveMode);\r\n}\r\n\r\n/**\r\n * Fetch responsiveMode stored on local device (if any).\r\n * \r\n * @return {string} the persisted \"responsive mode\" (null for none).\r\n */\r\nexport function fetchResponsiveMode() {\r\n  return fetchItem(responsiveModeKey);\r\n}\r\n\r\n/**\r\n * Remove responsiveMode from local device.\r\n */\r\nexport function removeResponsiveMode() {\r\n  removeItem(responsiveModeKey);\r\n}\r\n\r\nconst responsiveModeKey = 'responsiveMode';\r\n","import {expandWithFassets}    from 'feature-u';\r\nimport {combineReducers}      from 'redux';\r\nimport {reducerHash}          from 'astx-redux-util';\r\nimport {slicedReducer}        from 'feature-redux';\r\nimport _baseUI                from './featureName';\r\nimport _baseUIAct             from './actions';\r\nimport {fetchUITheme}         from './uiThemeStorage';\r\nimport {fetchResponsiveMode}  from './responsiveModeStorage';\r\nimport {createSelector}       from 'reselect';\r\nimport {fnRefEncode,\r\n        fnRefDecode}          from 'util/reduxFnRef';\r\n\r\n\r\n// ***\r\n// *** Our feature reducer, managing our state.\r\n// ***\r\n\r\nconst reducer = slicedReducer(_baseUI, expandWithFassets( (fassets) => combineReducers({\r\n\r\n  // uiTheme: 'light'/'dark'\r\n  uiTheme: reducerHash({\r\n    [_baseUIAct.toggleUITheme]: (state, action) => state==='dark' ? 'light' : 'dark',\r\n  }, fetchUITheme() ), // initialState (default to a persistent state)\r\n\r\n  // responsiveMode: 'md'/'lg'/'off'\r\n  responsiveMode: reducerHash({\r\n    [_baseUIAct.setResponsiveMode]: (state, action) => action.responsiveMode,\r\n  }, fetchResponsiveMode() || 'sm' ), // initialState (from device storage, default to small (a tablet))\r\n\r\n  // the current view\r\n  curView: reducerHash({ // TODO: suspect curView is OBSOLETE for visualize-it ... we are using the dynamic Tab Manager\r\n    [_baseUIAct.changeView]:   (state, action) => action.viewName,\r\n//  AI: DECIDE_AUTH_USER_NEEDED\r\n//  [fassets.actions.signOut]: (state, action) => 'eateries', // AI: Inappropriate app knowledge dependency (really part of an @@INIT app payload) ... AI: streamline in \"INITIALIZATION\" journal entry\r\n  }, 'uninitialized'), // initialState\r\n\r\n  // leftNavItems: {leftNavKey1: LeftNavComp1, leftNavKey2: LeftNavComp2, ...}\r\n  leftNavItems: reducerHash({\r\n    [_baseUIAct.addLeftNavItem]:    (state, action) => ({...state, ...{[action.leftNavKey]: fnRefEncode(action.LeftNavComp)}}),\r\n    [_baseUIAct.removeLeftNavItem]: (state, action) => {\r\n      const {[action.leftNavKey]: omit, ...remainder} = state;\r\n      return remainder;\r\n    },\r\n  }, {}), // initialState\r\n\r\n}) ) );\r\n\r\nexport default reducer;\r\n\r\n\r\n// ***\r\n// *** Various Selectors\r\n// ***\r\n\r\n/** Our feature state root (via slicedReducer as a single-source-of-truth) */\r\nconst getFeatureState           = (appState) => reducer.getSlicedState(appState);\r\nconst gfs = getFeatureState;      // ... concise alias (used internally)\r\n\r\n                                  /** UI Theme: 'light'/'dark' */\r\nexport const getUITheme         = (appState) => gfs(appState).uiTheme || 'light'; // default to 'light' (on first occurrence -or- deviceStorage() NOT supported)\r\n\r\n                                  /** Responsive Mode: 'md'/'lg'/'off' */\r\nexport const getResponsiveMode  = (appState) => gfs(appState).responsiveMode;\r\n\r\n                                  /** current view (ex: 'eateries') */\r\nexport const curView            = (appState) => gfs(appState).curView;\r\n\r\n                                       /** raw leftNavItems */\r\nconst getLeftNavItems = (appState)  => gfs(appState).leftNavItems;\r\n\r\n                                       /** ordered leftNavItems */\r\nexport const getOrderedLeftNavItems  = createSelector( // return: [ [leftNavKey1, LeftNavItem1], [leftNavKey2, LeftNavItem2], ... ]\r\n  getLeftNavItems,\r\n  (leftNavItems) => {\r\n\r\n    // convert to [ [leftNavKey1, encodedLeftNavItem1], [leftNavKey2, encodedLeftNavItem2], ... ]\r\n    const encodedEntries = Object.entries( leftNavItems );\r\n\r\n    // decode component functions [ [leftNavKey1, LeftNavItem1], [leftNavKey2, LeftNavItem2], ... ]\r\n    const entries = encodedEntries.map( ([leftNavKey, encodedLeftNavComp]) => [leftNavKey, fnRefDecode(encodedLeftNavComp)]);\r\n\r\n    // order by leftNavKey\r\n    const orderedEntries = entries.sort( ([k1], [k2]) => k1.localeCompare(k2) );\r\n\r\n    return orderedEntries;\r\n  }\r\n);\r\n","/**\r\n * A function encoding technique which allows function references to be\r\n * visible in Redux DevTools.\r\n * \r\n * As a general rule, redux recommends using plain serializable state within.\r\n * ... https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state\r\n * \r\n * In some cases, however, the dynamics afforded by using functional state\r\n * (or react functional components) is extremely powerful.\r\n * \r\n * If you are NOT relying on the ability to persist and rehydrate redux\r\n * state, you may wish to use functional state to gain additional\r\n * dynamics in advanced systems.\r\n * \r\n * Functional state does in fact work, with the caveats mentioned above,\r\n * however one \"quirkiness\" is that functional state is completely\r\n * invisible in the Redux DevTools ... which can be rather confusing :-(\r\n * \r\n * This simple wrapper, provides visibility of functions (and react\r\n * functional components) held within your redux store.\r\n * \r\n * ```js\r\n * someState: {               // Redux DevTools\r\n *   field1: fn,              // completely hidden: it is functional, just confusing\r\n *   field2: fnRefEncode(fn), // visible as:        field2: {fnRef: \"hidden in Redux DevTools\"}\r\n * }\r\n * ```\r\n * \r\n * When using this wrapper, don't forget to decode it ... for example\r\n * \r\n * ```js\r\n * fnRefDecode(someState.field2)(); // invocation of encoded redux state function\r\n * ```\r\n */\r\n\r\nexport const fnRefEncode = (fn) => ({fn, fnRef: 'hidden in Redux DevTools'});\r\n\r\nexport const fnRefDecode = (fnRef) => fnRef.fn;\r\n","import {createLogic}          from 'redux-logic';\r\nimport _baseUI                from './featureName';\r\nimport _baseUIAct             from './actions';\r\nimport {getUITheme,\r\n        getResponsiveMode}    from './state';\r\nimport {storeUITheme}         from './uiThemeStorage';\r\nimport {storeResponsiveMode}  from './responsiveModeStorage';\r\n\r\n/**\r\n * Monitor UI Theme changes, persisting the latest theme in our device storage.\r\n */\r\nexport const persistUITheme = createLogic({\r\n\r\n  name: `${_baseUI}.persistUITheme`,\r\n  type: String(_baseUIAct.toggleUITheme),\r\n\r\n  process({getState, action, fassets}, dispatch, done) {\r\n    storeUITheme( getUITheme(getState()) );\r\n    done();\r\n  },\r\n\r\n});\r\n\r\n\r\n/**\r\n * Monitor responsiveMode changes, persisting the latest in our device storage.\r\n */\r\nexport const persistResponsiveMode = createLogic({\r\n\r\n  name: `${_baseUI}.persistResponsiveMode`,\r\n  type: String(_baseUIAct.setResponsiveMode),\r\n\r\n  process({getState, action, fassets}, dispatch, done) {\r\n    storeResponsiveMode( getResponsiveMode(getState()) );\r\n    done();\r\n  },\r\n\r\n});\r\n\r\n\r\n// promote all logic modules for this feature\r\n// ... NOTE: individual logic modules are unit tested using the named exports.\r\nexport default [\r\n  persistUITheme,\r\n  persistResponsiveMode,\r\n];\r\n","import React                    from 'react';\r\n\r\nimport {makeStyles}             from '@material-ui/core/styles';\r\n\r\nimport Drawer                   from '@material-ui/core/Drawer';\r\nimport List                     from '@material-ui/core/List';\r\nimport Toolbar                  from '@material-ui/core/Toolbar';\r\n\r\nimport {getOrderedLeftNavItems} from '../state';\r\nimport {useSelector}            from 'react-redux'\r\n\r\n\r\n/**\r\n * LeftNav: our LeftNav component that accumulates menu items \r\n * via a programmatic API: fassets.action.activateTab()\r\n */\r\nexport default function LeftNav() {\r\n\r\n  const classes = useStyles();\r\n\r\n  const orderedLeftNavItems = useSelector((appState) => getOrderedLeftNavItems(appState), []);\r\n\r\n  // LeftNav is dynamic, only displayed when it has entries\r\n  if (orderedLeftNavItems.length <= 0) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <Drawer className={classes.leftNav}\r\n            variant=\"permanent\"\r\n            classes={{\r\n              paper: classes.leftNavPaper,\r\n            }}>\r\n\r\n      <Toolbar variant=\"dense\"\r\n               comment=\"spacer (hidden UNDER AppBar) so our LeftNav isn't covered up by the AppBar\"/>\r\n\r\n      <List>\r\n        {orderedLeftNavItems.map( ([leftNavKey, LeftNavComp]) => <LeftNavComp key={leftNavKey}/> )}\r\n      </List>\r\n    </Drawer>\r\n  );\r\n}\r\n\r\nconst drawerWidth = 240;\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n\r\n  leftNav: {\r\n    width: drawerWidth,\r\n    flexShrink: 0,\r\n  },\r\n\r\n  leftNavPaper: { // match same width in our LeftNav Drawer usage\r\n    width: drawerWidth,\r\n\r\n    //? // AI: ?? try some simple css (advanced) TO implement resizing\r\n    //? // RESULT: KINDA WORKS \r\n    //? //         - only operates in Chrome (NOT Edge) ... didn't test anything else\r\n    //? //         - resizes the LeftNav GREAT\r\n    //? //         - does NOT propagate to other elms (just overlays the main page) ... prob need some programmatic event handler\r\n    //? //         - kinda quirky (with little corner frame)\r\n    //? resize: 'horizontal', // KOOL: kinda works\r\n    //? // NOT NEEDED: border: '1px solid #333',\r\n    //? // NOT NEEDED: overflow: 'auto',\r\n  },\r\n\r\n}) );\r\n\r\n\r\n\r\n","import React,\r\n       {useState,\r\n        useCallback,\r\n        useMemo}      from 'react';\r\n//import PropTypes      from 'prop-types'; ... AI: DECIDE_AUTH_USER_NEEDED\r\n\r\nimport {useFassets}   from 'feature-u';\r\n\r\nimport IconButton     from '@material-ui/core/IconButton';\r\nimport Menu           from '@material-ui/core/Menu';\r\nimport UserIcon       from '@material-ui/icons/AccountCircle';\r\n//import Typography     from '@material-ui/core/Typography'; ... AI: DECIDE_AUTH_USER_NEEDED\r\n\r\n\r\n/**\r\n * UserMenu: our UserMenu component that accumulates menu items via use contract.\r\n */\r\nexport default function UserMenu({curUser}) {\r\n\r\n  const [anchorUserMenu, setAnchorUserMenu] = useState(null);\r\n  const userMenuOpen = useMemo(() => Boolean(anchorUserMenu), [anchorUserMenu]);\r\n\r\n  const openUserMenu = useCallback((event) => setAnchorUserMenu(event.currentTarget), []);\r\n  _closeUserMenu     = useCallback(()      => setAnchorUserMenu(null),                []);\r\n\r\n  const userMenuItems        = useFassets('AppMotif.UserMenuItem.*@withKeys');\r\n  const orderedUserMenuItems = useMemo(() => (\r\n    [...userMenuItems].sort(([item1Key], [item2Key]) => item1Key.localeCompare(item2Key))\r\n  ), [userMenuItems]);\r\n\r\n  return (\r\n    <div>\r\n      <IconButton color=\"inherit\"\r\n                  onClick={openUserMenu}>\r\n        <UserIcon/>\r\n        {/* ... AI: DECIDE_AUTH_USER_NEEDED\r\n        <Typography variant=\"subtitle2\" color=\"inherit\" noWrap>\r\n          &nbsp;{curUser.name}\r\n        </Typography>\r\n        */}\r\n      </IconButton>\r\n      <Menu anchorEl={anchorUserMenu}\r\n            anchorOrigin={{\r\n              vertical: 'top',\r\n              horizontal: 'right',\r\n            }}\r\n            transformOrigin={{\r\n              vertical: 'top',\r\n              horizontal: 'right',\r\n            }}\r\n            open={userMenuOpen}\r\n            onClose={closeUserMenu}>\r\n        {orderedUserMenuItems.map( ([fassetsKey, UserMenuItem]) => <UserMenuItem key={fassetsKey}/> )}\r\n      </Menu>\r\n    </div>\r\n  );\r\n}\r\n\r\n// AI: DECIDE_AUTH_USER_NEEDED\r\n//UserMenu.propTypes = {\r\n//  curUser: PropTypes.object.isRequired,\r\n//};\r\n\r\n\r\n\r\n/**\r\n * Utility function that closes our user menu.\r\n */\r\nexport function closeUserMenu() { // exported for use by our own: UserMenuItem\r\n  if (_closeUserMenu) {\r\n    _closeUserMenu();\r\n  }\r\n}\r\nlet _closeUserMenu = null;\r\n","import SmartPkg    from './SmartPkg';\r\nimport pkgManager  from './pkgManager';\r\nimport verify      from 'util/verify';\r\n\r\n/**\r\n * Load a package (SmartPkg) from an external resource (ex: web or\r\n * local file) and catalog it in pkgManager.\r\n *\r\n * The newly loaded package will automatically be registered in pkgManager\r\n * (via pkgManager.registerPkg()).\r\n *\r\n * @param {PkgResourcePath} [pkgResourcePath] - the optional resource\r\n * path of the package to retrieve.  When not supplied, an interactive\r\n * file picker dialog will be presented.\r\n *\r\n * @returns {SmartPkg via Promise} the newly loaded package (undefined\r\n * when user cancels the picker dialog).\r\n * \r\n * @throws {Error} an Error is thrown in various scenarios\r\n * (pkgResourcePath not found, uninterpretable resource content,\r\n * invalid params, etc.).\r\n */\r\nexport async function openPkg(pkgResourcePath) {\r\n  // validate parameters\r\n  const check = verify.prefix('openPkg() parameter violation: ');\r\n\r\n  // ... pkgResourcePath (when supplied)\r\n  if (pkgResourcePath) {\r\n    check(pkgResourcePath,       'pkgResourcePath is currently NOT a supported param (omit it to activate the \"interactive file picker dialog\")'); // AI: add support for pkgResourcePath\r\n    check(pkgResourcePath===123, 'pkgResourcePath (when supplied) must be a YetUnknown'); // AI: future TEMPLATE\r\n  }\r\n  else { // ... for interactive file picker dialog\r\n    // insure we have access to the \"Native File System API TRIAL\"\r\n    if (!window.chooseFileSystemEntries) {\r\n      throw new Error('***ERROR*** openPkg() the \"Native File System API TRIAL\" is NOT available in this environment :-(')\r\n        .defineAttemptingToMsg('use the interactive file picker dialog');\r\n    }\r\n  }\r\n\r\n  // define our fileHandle\r\n  // ... AI: determine how to retain a neutral version of this resource, for \"save\" operations (possibly in loaded SmartPkg)\r\n  let fileHandle = null;\r\n\r\n  // ... when pkgResourcePath IS supplied\r\n  if (pkgResourcePath) {\r\n    // NOTE: currently errors out (in parameter validation above)\r\n    // AI: figure this out\r\n  }\r\n  // ... when pkgResourcePath NOT supplied\r\n  else {\r\n    // select the fileHandle via an interactive file picker dialog\r\n    try {\r\n      fileHandle = await window.chooseFileSystemEntries({\r\n        type: 'openFile',\r\n        accepts: [{\r\n          description: 'visualize-it file',\r\n          extensions: ['vit'],\r\n          mimeTypes: ['application/json'],\r\n        }],\r\n      });\r\n    }\r\n    catch(err) {\r\n      // prune expected errors\r\n      if (err.message === 'The user aborted a request.') { // ... user canceled request\r\n        return; // return undefined when user cancels the picker dialog (as documented above)\r\n      }\r\n      // re-throw \"qualified\" unexpected errors\r\n      throw err.defineAttemptingToMsg('use the file picker dialog');\r\n    }\r\n  }\r\n\r\n  // load the file blob\r\n  // ... NOTE: file is w3c - https://w3c.github.io/FileAPI/#dfn-file\r\n  // ... for now, just pass through unexpected errors\r\n  const file = await fileHandle.getFile();\r\n\r\n  // resolve the file content\r\n  // ... see: https://w3c.github.io/FileAPI/#text-method-algo\r\n  // ... for now, just pass through unexpected errors\r\n  const fileContent = await file.text();\r\n\r\n  // resolve content to json\r\n  let smartJSON = null\r\n  try {\r\n    smartJSON = JSON.parse(fileContent);\r\n  }\r\n  catch(err) { // SyntaxError\r\n    // something about err emitted from JSON, doesn't show attemptingToMsg in discloseError() detail\r\n    // >>> throw err.defineAttemptingToMsg('interpret resource as smartJSON in openPkg()');\r\n    // ... suspect it is somehow NOT purely Error based (not really sure what this is)\r\n    // ... for now re-create it, but concerned may loose something out of the original\r\n    throw new Error(`INVALID JSON - ${err.message}`)\r\n    .defineUserMsg('Please select a valid visualize-it package'); // consider this a user error (in their selection)\r\n  }\r\n\r\n  // resolve the json to a SmartPkg\r\n  // ... this auto adorns .defineAttemptingToMsg()\r\n  const pkg = SmartPkg.fromSmartJSON(smartJSON);\r\n\r\n  // retain the pkgResourcePath\r\n  pkg.setPkgResourcePath(fileHandle);\r\n\r\n  // register this package in our pkgManager\r\n  pkgManager.registerPkg(pkg);\r\n\r\n  // reset the pkg baseline crc (reflecting what was pulled from our file)\r\n  // pkg.resetBaseCrc(); // ... N/A because this is accomplished in the SmartPkg constructor\r\n\r\n  // that's all folks\r\n  return pkg;\r\n}\r\n\r\n/**\r\n * Save the supplied package (SmartPkg) to an external resource (ex:\r\n * web or local file).\r\n *\r\n * @param {SmartPkg} pkg - the package to be saved.\r\n * @param {boolean} [saveAs=false] - true: save in a user\r\n * selected file, false: save in the original pkg's `pkgResourcePath`.\r\n *\r\n * @returns {void | 'UserCancel' | 'SaveNotNeeded' via Promise} a\r\n * \"void\" promise is resolved when successfully complete\r\n * -or- 'UserCancel' when user cancels the request\r\n * -or- 'SaveNotNeeded' when save is not needed\r\n * \r\n * @throws {Error} an Error is thrown in various unexpected scenarios.\r\n */\r\nexport async function savePkg(pkg, saveAs=false) {\r\n  // validate parameters\r\n  const check = verify.prefix('savePkg() parameter violation: ');\r\n\r\n  // ... pkg\r\n  check(pkg,                     'pkg is required')\r\n  check(pkg instanceof SmartPkg, 'pkg must be a SmartPkg');\r\n\r\n  // ... saveAs\r\n  if (saveAs) {\r\n    check(saveAs === true || saveAs === false, 'saveAs must be a boolean (when supplied)');\r\n  }\r\n\r\n  // insure we have access to the \"Native File System API TRIAL\"\r\n  if (!window.chooseFileSystemEntries) {\r\n    throw new Error('***ERROR*** savePkg() the \"Native File System API TRIAL\" is NOT available in this environment :-(')\r\n      .defineAttemptingToMsg('save a package to a local file system');\r\n  }\r\n\r\n  // no-op when save operation that has NO changes\r\n  if (!saveAs &&             // a save request\r\n      pkg.pkgResourcePath && // that doesn't morph into a save-as\r\n      pkg.isInSync()) {      // and it has NO changes\r\n    return 'SaveNotNeeded';\r\n  }\r\n\r\n  // create the JSON content, representing our pkg\r\n  // ... placement of this process is crucial - any unexpected errors\r\n  //     occurring here will short-circuit the creation of an empty file!\r\n  const smartJSON = pkg.toSmartJSON();\r\n  const content   = JSON.stringify(smartJSON);\r\n\r\n  // locate the file where the pkg will be saved\r\n  let fileHandle = saveAs ? undefined : pkg.getPkgResourcePath();\r\n  // ... conditionally prompt the user to select the file\r\n  //     (either there is no `pkg.pkgResourcePath`, or a `saveAs` operation was requested)\r\n  if (!fileHandle) {\r\n    try {\r\n      fileHandle = await window.chooseFileSystemEntries({\r\n        type: 'saveFile',\r\n        accepts: [{\r\n          description: 'visualize-it file',\r\n          extensions: ['vit'],\r\n          mimeTypes: ['application/json'],\r\n        }],\r\n      });\r\n    }\r\n    catch (err) {\r\n      // prune expected errors\r\n      if (err.name === 'AbortError') { // ... user canceled request\r\n        return 'UserCancel';\r\n      }\r\n      // re-throw \"qualified\" unexpected errors\r\n      throw err.defineAttemptingToMsg(`select the file to save the \"${pkg.getPkgName()}\" package`);\r\n    }\r\n  }\r\n\r\n  // write the file\r\n  try {\r\n    // create a writer (request permission if necessary)\r\n    const writer = await fileHandle.createWriter();\r\n\r\n    // write the content\r\n    await writer.write(0, content);\r\n\r\n    // close the file and write the contents to disk\r\n    await writer.close();\r\n  }\r\n  catch(err) {\r\n    // prune expected errors\r\n    if (err.name === 'NotAllowedError') { // ... user did not allow the file write\r\n      err.defineUserMsg('User disallowed the file write');\r\n    }\r\n    // re-throw \"qualified\" unexpected errors\r\n    throw err.defineAttemptingToMsg(`save the \"${pkg.getPkgName()}\" package`);\r\n  }\r\n\r\n  // retain the pkgResourcePath\r\n  pkg.setPkgResourcePath(fileHandle);\r\n\r\n  // reset the pkg baseline crc (reflecting what has been filed)\r\n  pkg.resetBaseCrc();\r\n}\r\n\r\n\r\n//******************************************************************************\r\n//*** Specifications\r\n//******************************************************************************\r\n\r\n/**\r\n * @typedef {Unknown} PkgResourcePath\r\n *\r\n * PkgResourcePath is intended to be a generic abstraction that\r\n * encapsulates the resource path of where a SmartPkg is persisted\r\n * (either a file, or url, etc.).\r\n *\r\n * Currently it's type is limited to the FileSystemFileHandle _(a\r\n * Native File System type)_.\r\n * \r\n * When a SmartPkg is persisted (i.e. pulled from, or saved to a\r\n * file/url), it will contain a pkgResourcePath.\r\n * - this merely identifies it's persistent form and provides a\r\n *   convenient means by which changes can be saved\r\n * - NOTE: the SmartPkg.pkgResourcePath attribute is NOT persisted,\r\n *         rather it is retained as a result of an open/save operation.\r\n *\r\n * AI: More research is needed to expand pkgResourcePath to it's more\r\n *     generic form.\r\n *     - regarding FileSystemFileHandle\r\n *       * it does not appear you can ascertain the internal actual local file name\r\n *         cannot glean path/directory ... only fileName (ex: 'textDat.txt')\r\n *         - fileHandle: {\r\n *             isDirectory: false\r\n *             isFile:      true\r\n *             name:        'testData.txt'\r\n *           }\r\n *         - file: {\r\n *             name:        'testData.txt'\r\n *             lastModified: 222333444\r\n *             webkitRelativePath: ''\r\n *             size:  123\r\n *             type: 'text/plain'\r\n *           }\r\n *         - there is a fileHandle = directoryHandle.getFile(name)\r\n *       * in it's early form, it is NOT YET serializable\r\n *       * unsure, but running from a PWA may help\r\n *       * there are TWO handle refs ... can be:\r\n *         - FileSystemFileHandle ........ handle.isFile\r\n *         - FileSystemDirectoryHandle ... handle.isDirectory\r\n *     - more broadly, how do we encapsulate both file and url usage (ultimately)\r\n */\r\n","import {toast, alert}    from 'util/notify';\r\nimport verify            from 'util/verify';\r\nimport checkUnknownArgs  from 'util/checkUnknownArgs';\r\n\r\nconst DYNAMIC_DEFAULT = 'DYNAMIC_DEFAULT';\r\n\r\n/**\r\n * The discloseError() utility provides a standard way to \r\n * disclose errors both to the user (toasts) and logs.\r\n *\r\n * This utility uses the heuristics defined by the\r\n * ErrorExtensionPolyfill, and therefore require it to be present.\r\n *\r\n * The emission of both user notifications and logs can be controlled,\r\n * through parameters that dynamically default (based on \"expected\"\r\n * vs. \"unexpected\" error status).\r\n *\r\n * All user notifications occur through toasts, and are sanitized:\r\n *  - showing appropriate user-level detail,\r\n *  - with more information available via a button click\r\n *\r\n * Log formats are also standardized.\r\n *\r\n * **Please Note** this function uses named parameters.\r\n *\r\n * @param {Error} err the Error object to be disclosed (logged and\r\n * user-notified).\r\n *\r\n * @param {boolean} [showUser=true] an indicator as to whether the\r\n * user should be shown this error.\r\n *\r\n * @param {boolean} [logIt=DYNAMIC_DEFAULT] an indicator as to whether\r\n * a log entry should be emitted, dynamically defaulted (LOG when err\r\n * is Unexpected, NO-LOG when Expected).\r\n */\r\nexport default function discloseError({err,\r\n                                       showUser=true,         // DEFAULT: true ................. i.e. always SHOW\r\n                                       logIt=DYNAMIC_DEFAULT, // DEFAULT: err.isUnexpected() ... i.e. LOG when Unexpected, NO-LOG when Expected\r\n                                       ...unknownArgs}={}) {\r\n\r\n  // validate parameters\r\n  try {\r\n    const check = verify.prefix('discloseError() parameter violation: ')\r\n    // ... err\r\n    check(err,           'err is required');\r\n    check(err instanceof Error, 'err must be an Error object, NOT: ', err);\r\n    // ... showUser\r\n    showUser = showUser===DYNAMIC_DEFAULT ? err.isExpected() : showUser; // dynamic DEFAULT semantics\r\n    check(showUser===true || showUser===false, 'showUser must be a boolean');\r\n    // ... logIt\r\n    logIt = logIt===DYNAMIC_DEFAULT ? err.isUnexpected() : logIt; // dynamic DEFAULT semantics\r\n    check(logIt===true || logIt===false, 'logIt must be a boolean');\r\n    // ... unknown arguments\r\n    checkUnknownArgs(check, unknownArgs, arguments);\r\n  }\r\n  // NOTE: this handler CANNOT throw an error, \r\n  //       because it is typically used inside a promise.catch()\r\n  //       which will generate an \"Unhandled promise rejection\"\r\n  catch(e) {\r\n    console.log('YIKES ... visualize-it\\'s discloseError() was attempting to report on err: ', err);\r\n    console.log('HOWEVER AN INVOCATION PROBLEM was detected in the parameters passed to discloseError()!\\n' +\r\n                '... discloseError() CANNOT throw an error (when used in a promise an \"Unhandled promise rejection\" will result)!!\\n' +\r\n                '... PLEASE FIX THE FOLLOWING INVOCATION PROBLEM: ', e);\r\n    return; // cannot throw(e) ... see log (above)\r\n  }\r\n\r\n  // show user when requested\r\n  if (showUser) {\r\n    // unexpended errors display as error toasts with additional details link\r\n    if (err.isUnexpected()) {\r\n      toast.error({  // ... will auto close -OR- when \"details\" is clicked\r\n        msg: err.formatUserMsg(),\r\n        actions: [\r\n          { txt:    'details',\r\n            action: () => {\r\n              alert.error({ msg: `An unexpected error occurred:\r\n\r\n${err}\r\n\r\nIf this problem persists, please contact your tech support.`\r\n              });\r\n            }},\r\n        ]\r\n      });\r\n    }\r\n\r\n    // expended errors display as warning toasts with NO additional detail\r\n    else {\r\n      toast.warn({  // ... will auto close\r\n        msg: err.formatUserMsg()\r\n      });\r\n    }\r\n        \r\n  }\r\n\r\n  // generate log entry when requested\r\n  if (logIt) {\r\n\r\n    // log the details of the error (with traceback) for tech review\r\n    // NOTE 1: we refrain from using console.warn() and console.error() \r\n    //         because of BAD semantics inferred by react-native/expo:\r\n    //          - console.warn():  generates yellow popup\r\n    //          - console.error(): kills app with \"red screen of death\"\r\n    // NOTE 2: react-native/expo appears to be doing something non standard\r\n    //         when passing error as the 2nd parameter of log():\r\n    //             log('msg', error)\r\n    //         ... in this case is merely emitting error.toString()\r\n    //         ... we can however receive a stack trace by calling log(error) as the first parameter\r\n    const prefix = err.isUnexpected() ? '*** Unexpected Error:\\n\\n' : '*** Expected Error:\\n\\n';\r\n    console.log(prefix + err);\r\n    if (err.isUnexpected()) { // produce stack traces only for unexpected errors\r\n      console.log('Stack Trace ...');\r\n      console.log(err);\r\n    }\r\n  }\r\n\r\n}\r\n","import React,\r\n       {useState,\r\n        useCallback,\r\n        useMemo}        from 'react';\r\n\r\nimport {openPkg, \r\n        savePkg}        from 'core/pkgPersist';\r\n\r\nimport {leftNavManager,\r\n        tabRegistry}    from 'features/xtra';\r\n\r\nimport discloseError    from 'util/discloseError';\r\nimport verify           from 'util/verify';\r\nimport {toast}          from 'util/notify';\r\n\r\nimport {useFassets}     from 'feature-u';\r\nimport {useSelector}    from 'react-redux'\r\n\r\nimport Button           from '@material-ui/core/Button';\r\nimport Menu             from '@material-ui/core/Menu';\r\nimport MenuItem         from '@material-ui/core/MenuItem';\r\nimport Typography       from '@material-ui/core/Typography';\r\n\r\n/**\r\n * FileMenu: our FileMenu component.\r\n */\r\nexport default function FileMenu() {\r\n\r\n  const [anchorFileMenu, setAnchorFileMenu] = useState(null);\r\n  const fileMenuOpen = useMemo(() => Boolean(anchorFileMenu), [anchorFileMenu]);\r\n\r\n  const openFileMenu = useCallback((event) => setAnchorFileMenu(event.currentTarget), []);\r\n  _closeFileMenu     = useCallback(()      => setAnchorFileMenu(null),                []);\r\n\r\n  const fassets      = useFassets();\r\n  const activeTabId  = useSelector( (appState) => fassets.sel.getActiveTabId(appState), [fassets] );\r\n  const isActiveTab  = activeTabId ? true : false;\r\n\r\n  return (\r\n    <div>\r\n      <Button color=\"inherit\"\r\n              onClick={openFileMenu}>\r\n\r\n        <Typography variant=\"button\"\r\n                    color=\"inherit\"\r\n                    noWrap>\r\n          File\r\n        </Typography>\r\n      </Button>\r\n      <Menu anchorEl={anchorFileMenu}\r\n            anchorOrigin={{\r\n              vertical: 'top',\r\n              horizontal: 'right',\r\n            }}\r\n            transformOrigin={{\r\n              vertical: 'top',\r\n              horizontal: 'right',\r\n            }}\r\n            open={fileMenuOpen}\r\n            onClose={closeFileMenu}>\r\n\r\n        <MenuItem onClick={handleOpenPkg}>Open ...</MenuItem>\r\n        <MenuItem onClick={() => handleSavePkg(activeTabId)}       disabled={!isActiveTab}>Save</MenuItem>\r\n        <MenuItem onClick={() => handleSavePkg(activeTabId, true)} disabled={!isActiveTab}>Save As ...</MenuItem>\r\n\r\n      </Menu>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Utility function that closes our file menu.\r\n */\r\nfunction closeFileMenu() {\r\n  if (_closeFileMenu) {\r\n    _closeFileMenu();\r\n  }\r\n}\r\nlet _closeFileMenu = null;\r\n\r\n\r\n/**\r\n * Open (i.e. load) a SmartPkg selected from the user's local file system.\r\n */\r\nasync function handleOpenPkg() {\r\n  closeFileMenu();\r\n\r\n  try {\r\n    const pkg = await openPkg();\r\n    if (!pkg) {\r\n      return; // no-op when user canceled the pick dialog\r\n    }\r\n\r\n    // register it in our LeftNav\r\n    // ... this dispatches an action, so any error cannot be caught here\r\n    leftNavManager.addLeftNav(pkg);\r\n\r\n    toast({msg: `\"${pkg.getPkgName()}\" has been loaded in the Left Nav Menu`})\r\n  }\r\n  catch (err) {\r\n    // gracefully report unexpected conditions to user\r\n    discloseError({err, logIt:true});\r\n  }\r\n}\r\n\r\n/**\r\n * Save the supplied SmartPkg (identified from the supplied tab) to\r\n * an external resource (ex: web or local file).\r\n *\r\n * @param {string} activeTabId - the tab identifier from which we\r\n * determine the SmartPkg to save.\r\n * @param {boolean} [saveAs=false] - true: save in a newly user\r\n * selected file, false: save in the original pkg's `pkgResourcePath`.\r\n */\r\nasync function handleSavePkg(activeTabId, saveAs=false) {\r\n  closeFileMenu();\r\n\r\n  try {\r\n    // resolve the package from the supplied activeTabId\r\n    const pkg = resolvePkg(activeTabId);\r\n\r\n    // insure the package is a candidate for saving\r\n    if (!pkg.canPersist()) {\r\n      toast.warn({msg: `The \"${pkg.getPkgName()}\" package cannot be saved ... it contains code, which cannot be persisted!`});\r\n      return;\r\n    }\r\n\r\n    // save the package\r\n    const result = await savePkg(pkg, saveAs);\r\n    if (result === 'UserCancel') {\r\n    }\r\n    else if (result === 'SaveNotNeeded') {\r\n      toast.warn({msg: `The \"${pkg.getName()}\" package does NOT need to be saved ... you must first apply some changes`});\r\n    }\r\n    else {\r\n      toast({msg: `The \"${pkg.getPkgName()}\" package has been saved!`});\r\n    }\r\n  }\r\n  catch(err) {\r\n    // gracefully report unexpected conditions to user\r\n    discloseError({err, logIt:true});\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve the SmartPkg identified from the supplied tab.\r\n *\r\n * @param {string} activeTabId - the tab identifier from which we\r\n * determine the SmartPkg.\r\n *\r\n * @returns {SmartPkg} the package belonging to the supplied tab.\r\n *\r\n * @throws {Error} an Error is thrown when the SmartPkg could not be\r\n * identified (an unexpected condition).\r\n */\r\nfunction resolvePkg(activeTabId) {\r\n  // locate the package that contains the resource in the active tab\r\n  const tabController = tabRegistry.getTabController(activeTabId);\r\n  const targetObj     = tabController.getTarget(); // can be: Scene/Collage or SmartComp (for classes)\r\n  let   pkg           = targetObj.getPkg();\r\n\r\n  // verify the package is resolved\r\n  verify(pkg, `***ERROR*** <FileMenu> \"save/saveAs\" operation ... could not locate the SmartPkg for the '${activeTabId}' active tab :-(`);\r\n\r\n  // that's all folks :-)\r\n  // console.log(`xx SmartPkg resolved: `, pkg);\r\n  return pkg;\r\n}\r\n","import {generateActions}    from 'action-u';\r\nimport _toolBar             from './featureName';\r\n\r\nexport default generateActions.root({\r\n  [_toolBar]: { // prefix all actions with our feature name, guaranteeing they unique app-wide!\r\n\r\n    dispModeChanged: { // actions.dispModeChanged(dispMode): Action\r\n                       // > the toolBar's dispMode has changed\r\n                       actionMeta: {\r\n                         traits: ['dispMode'],\r\n                       },\r\n    },\r\n\r\n  },\r\n});\r\n","/**\r\n * Expose our featureName through a mini-meta module that is\r\n * \"importable\" in all use-cases (a single-source-of-truth).\r\n */\r\nexport default 'toolBar';\r\n","import {combineReducers}    from 'redux';\r\nimport {reducerHash}        from 'astx-redux-util';\r\nimport {expandWithFassets}  from 'feature-u';\r\nimport {slicedReducer}      from 'feature-redux';\r\nimport _toolBar             from './featureName';\r\nimport _toolBarAct          from './actions';\r\nimport DispMode             from 'core/DispMode';\r\nimport {tabRegistry}        from 'features/xtra';\r\n\r\n// ***\r\n// *** Our feature reducer, managing state for our toolBar process.\r\n// ***\r\n\r\nconst reducer = slicedReducer(_toolBar, expandWithFassets( (fassets) => combineReducers({\r\n\r\n  // dispMode: string ... 'view'/'edit'/'animate' via DispMode enum\r\n  dispMode: reducerHash({\r\n    [fassets.actions.activateTab]: (state, action) => tabRegistry.getTabController(action.tabId).getTarget().getDispMode().enumKey,\r\n    [_toolBarAct.dispModeChanged]: (state, action) => action.dispMode.enumKey,\r\n  }, DispMode.view.enumKey), // initialState\r\n\r\n}) ) );\r\n\r\nexport default reducer;\r\n\r\n\r\n// ***\r\n// *** Various Selectors\r\n// ***\r\n\r\n// Our feature state root (via slicedReducer as a single-source-of-truth)\r\nconst getFeatureState  = (appState) => reducer.getSlicedState(appState);\r\nconst gfs              = getFeatureState; // ... concise alias (used internally)\r\n\r\nexport const getDispMode = (appState) => DispMode.enumValueOf( gfs(appState).dispMode );\r\n","import React,\r\n       {useState,\r\n        useCallback}    from 'react';\r\n\r\nimport {useFassets}     from 'feature-u';\r\nimport {useSelector,\r\n        useDispatch}    from 'react-redux'\r\n\r\nimport DispMode         from 'core/DispMode';\r\n\r\nimport {tabRegistry, \r\n        changeManager}  from 'features/xtra';\r\n\r\nimport {createLogger}   from 'util/logger';\r\nimport {toast}          from 'util/notify';\r\n\r\nimport * as _toolBarSel from '../state';\r\nimport _toolBarAct      from '../actions';\r\n\r\nimport {makeStyles}     from '@material-ui/core/styles';\r\n\r\nimport FingerPrintIcon  from '@material-ui/icons/Fingerprint';\r\nimport RedoIcon         from '@material-ui/icons/Redo';\r\nimport UndoIcon         from '@material-ui/icons/Undo';\r\nimport IconButton       from '@material-ui/core/IconButton';\r\nimport MenuItem         from '@material-ui/core/MenuItem';\r\nimport Select           from '@material-ui/core/Select';\r\nimport Toolbar          from '@material-ui/core/Toolbar';\r\nimport Typography       from '@material-ui/core/Typography';\r\nimport Tooltip          from '@material-ui/core/Tooltip';\r\n\r\n// our internal diagnostic logger (normally disabled)\r\nconst log = createLogger('***DIAG*** <VitToolBar> ... ').disable();\r\n\r\n//***\r\n//*** Component: VitToolBar\r\n//***\r\nexport default function VitToolBar() {\r\n\r\n  const classes = useStyles();\r\n\r\n  const fassets     = useFassets();\r\n  const activeTabId = useSelector((appState) => fassets.sel.getActiveTabId(appState), [fassets]); // ... activeTabId is NOT pkgEntryId (IS: 'com.astx.KONVA-scenes-scene1' NOT: 'com.astx.KONVA/scene1')\r\n\r\n  // fallback to generic title, when NO tabs are active\r\n  if (!activeTabId) {\r\n    return (\r\n      <Typography variant=\"h6\"\r\n                  color=\"inherit\"\r\n                  noWrap\r\n                  className={classes.title}>\r\n        Visualize It\r\n      </Typography>\r\n    );\r\n  }\r\n\r\n  const pkgEntry = tabRegistry.getTabController(activeTabId).getTarget(); // ... target IS pkgEntry\r\n\r\n  // add stale indicator to pkgName\r\n  // ... AI: suspect responsiveness is working ONLY because we are refreshing too often <<< need to make responsive for real\r\n  const pkg          = pkgEntry.getPkg();\r\n  const pkgNameLabel = pkg.getPkgName() + (pkg.isInSync() ? '' : ' **');\r\n\r\n  return (\r\n    <Toolbar variant=\"dense\">\r\n      <Typography variant=\"h6\"\r\n                  color=\"inherit\"\r\n                  noWrap\r\n                  className={classes.title}>\r\n        {pkgNameLabel}\r\n      </Typography>\r\n\r\n      <UndoRedoTool/>\r\n\r\n      <Tooltip title=\"Silly Fingerprint\">\r\n        <IconButton onClick={()=>toast({msg: 'Silly little fingerprint!'})}><FingerPrintIcon/></IconButton>\r\n      </Tooltip>\r\n\r\n      <DispModeTool/>\r\n\r\n    </Toolbar>\r\n  );\r\n\r\n}\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n  title: {\r\n    flexGrow: 1, // moves right-most toolbar items to the right\r\n  },\r\n}) );\r\n\r\n\r\n\r\n//***\r\n//*** Component: DispMode\r\n//***\r\nfunction DispModeTool() {\r\n\r\n  const fassets     = useFassets();\r\n  const dispMode    = useSelector((appState) => _toolBarSel.getDispMode(appState),    []);\r\n  const activeTabId = useSelector((appState) => fassets.sel.getActiveTabId(appState), [fassets]); // ... activeTabId is NOT pkgEntryId (IS: 'com.astx.KONVA-scenes-scene1' NOT: 'com.astx.KONVA/scene1')\r\n\r\n  const dispatch             = useDispatch();\r\n  const handleDispModeChange = useCallback((event) => {\r\n    const newDispMode = DispMode.enumValueOf(event.target.value);\r\n    log(`dispMode changed to: ${newDispMode}`);\r\n    dispatch( _toolBarAct.dispModeChanged(newDispMode) );\r\n  }, [dispatch]);\r\n\r\n  const pkgEntry = tabRegistry.getTabController(activeTabId).getTarget(); // ... target IS pkgEntry\r\n\r\n  // GEEZE: have to manage DispMode ToolTip so it doesn't cover up the active <Select>\r\n  const [tooltipOpen, setTooltipOpen] = useState(false)\r\n  const openTooltip  = () => setTooltipOpen(true);\r\n  const closeTooltip = () => setTooltipOpen(false);\r\n\r\n  return (\r\n    <Tooltip title=\"Display Mode\"\r\n             open={tooltipOpen}>\r\n      <IconButton>\r\n        <Select id=\"dispMode\"\r\n                labelId=\"dispModeLabel\"\r\n                value={dispMode.enumKey}\r\n                onMouseEnter={openTooltip}\r\n                onMouseLeave={closeTooltip}\r\n                onMouseDown={closeTooltip}\r\n                onChange={handleDispModeChange}>\r\n          { \r\n            Array.from(DispMode).map( (dm) => (\r\n              <MenuItem key={dm.enumKey}\r\n                        value={dm.enumKey}\r\n                        disabled={!pkgEntry.canHandleDispMode(dm)}>{dm.enumKey}</MenuItem>\r\n            ) )\r\n          }\r\n        </Select>\r\n      </IconButton>\r\n    </Tooltip>\r\n  );\r\n\r\n}\r\n\r\n\r\n//***\r\n//*** Component: UndoRedoTool\r\n//***\r\nfunction UndoRedoTool() {\r\n\r\n  const fassets     = useFassets();\r\n  const dispMode    = useSelector((appState) => _toolBarSel.getDispMode(appState),    []);\r\n  const activeTabId = useSelector((appState) => fassets.sel.getActiveTabId(appState), [fassets]); // ... activeTabId is NOT pkgEntryId (IS: 'com.astx.KONVA-scenes-scene1' NOT: 'com.astx.KONVA/scene1')\r\n\r\n  const pkgEntry    = tabRegistry.getTabController(activeTabId).getTarget(); // ... target IS pkgEntry\r\n  const pkgEntryId  = pkgEntry.getEPkgId();\r\n\r\n  const isUndoAvail = useSelector((appState) => fassets.sel.isUndoAvail(appState, pkgEntryId), [fassets, pkgEntryId]);\r\n  const isRedoAvail = useSelector((appState) => fassets.sel.isRedoAvail(appState, pkgEntryId), [fassets, pkgEntryId]);\r\n\r\n  const handleUndo  = () => changeManager.applyUndo(pkgEntryId);\r\n  const handleRedo  = () => changeManager.applyRedo(pkgEntryId);\r\n\r\n  // no-op if NOT in edit mode\r\n  if (dispMode !== DispMode.edit) {\r\n    return null;\r\n  }\r\n  \r\n  return (\r\n    <>\r\n    <Tooltip title=\"Undo\">\r\n      <span>\r\n        <IconButton disabled={!isUndoAvail} onClick={handleUndo}><UndoIcon/></IconButton>\r\n      </span>\r\n    </Tooltip>\r\n    <Tooltip title=\"Redo\">\r\n      <span>\r\n        <IconButton disabled={!isRedoAvail} onClick={handleRedo}><RedoIcon/></IconButton>\r\n      </span>\r\n    </Tooltip>\r\n    </>\r\n  );\r\n\r\n}\r\n","import React,\r\n       {useMemo}      from 'react';\r\nimport PropTypes      from 'prop-types';\r\n\r\nimport {useFassets}   from 'feature-u';\r\nimport {useSelector}  from 'react-redux'\r\n\r\nimport {makeStyles}   from '@material-ui/core/styles';\r\n\r\nimport LeftNav        from './LeftNav';\r\nimport UserMenu       from './UserMenu';\r\nimport FileMenu       from './FileMenu';\r\n\r\nimport AppBar         from '@material-ui/core/AppBar';\r\nimport IconButton     from '@material-ui/core/IconButton';\r\nimport MenuIcon       from '@material-ui/icons/Menu';\r\nimport Toolbar        from '@material-ui/core/Toolbar';\r\n\r\nimport VitToolBar     from '../../../toolBar/comp/VitToolBar'; // NEW (TEMPORARY)\r\n\r\nimport {toast}        from 'util/notify';\r\n\r\n\r\n/**\r\n * AppMotif is a re-usable top-level component that establishes\r\n * the following application characteristics:\r\n * \r\n * - a **Left Nav** menu\r\n * - a **User Menu** menu\r\n * - a **Current View** state _(orchestrating which application view is active)_\r\n * - a **Tool Bar** with various artifacts (ex: title bar and footer)\r\n * \r\n * While these controls are promoted through AppMotif, it's content\r\n * is accumulated from external features through various **Use\r\n * Contracts**.\r\n\r\n * AppMotif is auto injected through the MainLayout component,\r\n * however, it is only active when an active user is **signed-in**.\r\n * \r\n * The main page content is rendered as children of this component\r\n * (like eateries, discovery, etc.).\r\n *\r\n * USAGE:\r\n * ```\r\n *   <AppMotif>\r\n *     ... app page content here\r\n *   </AppMotif>\r\n * ```\r\n * \r\n * Please refer to the **`baseUI` README** for more information.\r\n */\r\nexport default function AppMotif({children}) {\r\n\r\n  const fassets = useFassets();\r\n\r\n//const curUser = useSelector( (appState) => fassets.sel.curUser(appState), [fassets] );\r\n  const curView = useSelector( (appState) => fassets.sel.curView(appState), [fassets] );\r\n\r\n  const classes = useStyles();\r\n\r\n  // define our auxiliary view content\r\n  const viewAuxiliaryContent    = fassets.get('AppMotif.auxViewContent.*@withKeys');\r\n  const curViewAuxiliaryContent = useMemo(() => resolveCurViewAuxiliaryContent(curView, viewAuxiliaryContent), [curView, viewAuxiliaryContent]);\r\n  const {TitleComp, FooterComp} = curViewAuxiliaryContent;\r\n\r\n  // no-op when no user is signed-in ... AI: DECIDE_AUTH_USER_NEEDED\r\n//if (!curUser.isUserSignedIn()) {\r\n//  return (\r\n//    <>\r\n//      {children}\r\n//    </>\r\n//  );\r\n//}\r\n\r\n  return (\r\n    <div className={classes.app}>\r\n\r\n      {/* Title Bar */}\r\n      <AppBar className={classes.appBar}\r\n              position=\"fixed\"> {/* NOTE: eatery-nod-w used position \"absolute\" ... don't see any diff */}\r\n        <Toolbar className={classes.toolbar}\r\n                 variant=\"dense\"\r\n                 disableGutters={false}> {/*NOTE: doesn't seem that disableGutters does anything */}\r\n\r\n          {/* AI: Consider for some App Menu */}\r\n          <IconButton className={classes.menuButton}\r\n                      color=\"inherit\"\r\n                      onClick={ () => {\r\n                        toast.warn({msg: 'Collapsable Left Nav (coming soon)!'})\r\n                      }}>\r\n            <MenuIcon/>\r\n          </IconButton>\r\n\r\n          {/* File Menu */}\r\n          <FileMenu/>\r\n\r\n          {/* Title */}\r\n          <div className={classes.title}>\r\n            <TitleComp/>\r\n          </div>\r\n\r\n          {/* User Profile Menu ... AI: DECIDE_AUTH_USER_NEEDED ... curUser prop usage\r\n          <UserMenu curUser={curUser}/>\r\n            */}\r\n          <UserMenu/>\r\n\r\n        </Toolbar>\r\n      </AppBar>\r\n\r\n      {/* Left Nav */}\r\n      <LeftNav/>\r\n\r\n      {/* Page Content */}\r\n      <main className={classes.content}>\r\n\r\n        <Toolbar variant=\"dense\"\r\n                 comment=\"spacer (hidden UNDER AppBar) so our main content isn't covered up by the AppBar\"/>\r\n\r\n        {children}\r\n      </main>\r\n\r\n      {/* Optional Bottom Bar */}\r\n      {FooterComp && (\r\n         <AppBar className={classes.bottomBar}\r\n                 position=\"absolute\">\r\n           <Toolbar className={classes.toolbar}\r\n                    variant=\"dense\"\r\n                    disableGutters={false}>\r\n             <FooterComp/>\r\n           </Toolbar>\r\n         </AppBar>\r\n       )}\r\n\r\n    </div>\r\n  );\r\n}\r\n\r\nAppMotif.propTypes = {\r\n  children: PropTypes.node.isRequired, // main page content (like eateries and discovery)\r\n};\r\n\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n\r\n  app: {\r\n    display: 'flex', // KJB: does not seem to be doing anything\r\n  },\r\n\r\n  appBar: {\r\n    zIndex:     theme.zIndex.drawer + 1, // NOTE: forces AppBar to be OVER LeftNav (a drawer) ... this is new for fixed LeftNav\r\n  },\r\n\r\n  bottomBar: {\r\n    top:        'auto',\r\n    bottom:     0,\r\n  },\r\n\r\n  toolbar: {\r\n    // ***Dashboard Sample***\r\n    // paddingRight: 24, // keep right padding when drawer closed\r\n  },\r\n\r\n  menuButton: {\r\n    marginRight: 36, // proper spacing between menu button and title\r\n  },\r\n\r\n  title: {\r\n    flexGrow: 1, // moves right-most toolbar items to the right\r\n  },\r\n\r\n  content: {\r\n    flexGrow: 1,\r\n    height: '100vh',                 // content window is height is same as our viewport (100%)\r\n    overflow: 'auto',                // add scrollbar ONLY when necessary\r\n  },\r\n}) );\r\n\r\n\r\nfunction resolveCurViewAuxiliaryContent(curView, viewAuxiliaryContent) {\r\n  const matchKey = `AppMotif.auxViewContent.${curView}`;\r\n  const [, curViewAuxiliaryContent] = viewAuxiliaryContent.find( ([key]) => key === matchKey ) || fallbackViewAuxiliaryContent;\r\n  return curViewAuxiliaryContent;\r\n}\r\n\r\nconst fallbackViewAuxiliaryContent = ['AppMotif.auxViewContent.FALLBACK', {\r\n  // TODO: ?? do NOT believe we need a customizable Title within our app\r\n  //       - temporarily inject our CUSTOM \"Visualize It\" toolbar\r\n  // ORIGINAL:\r\n  //?TitleComp: () => (\r\n  //?  <Typography variant=\"h6\"\r\n  //?              color=\"inherit\"\r\n  //?              noWrap>\r\n  //?    App Motif\r\n  //?  </Typography>\r\n  //?),\r\n  // NEW (TEMPORARY):\r\n  TitleComp: VitToolBar,\r\n}];\r\n","import React  from 'react';\r\nimport Fade   from '@material-ui/core/Fade';\r\nimport Slide  from '@material-ui/core/Slide';\r\nimport Zoom   from '@material-ui/core/Zoom';\r\n\r\n//***\r\n//*** Common Transition components used throughout our app :-)\r\n//***\r\n\r\nexport const TransitionFade  = React.forwardRef( (props, ref) => <Fade  ref={ref} timeout=\"1000\"                   {...props} /> );\r\nexport const TransitionSlide = React.forwardRef( (props, ref) => <Slide ref={ref} direction=\"right\" timeout=\"1000\" {...props} /> );\r\nexport const TransitionZoom  = React.forwardRef( (props, ref) => <Zoom  ref={ref} timeout=\"1000\"                   {...props} /> );\r\n","import React, {useState} from 'react';\r\nimport PropTypes         from 'prop-types';\r\n\r\nimport {makeStyles}      from '@material-ui/core/styles';\r\nimport {useForCellPhone} from 'util/responsiveBreakpoints';\r\n\r\nimport Button            from '@material-ui/core/Button';\r\nimport Progress          from '@material-ui/core/LinearProgress';  // -or- '@material-ui/core/CircularProgress';\r\nimport Dialog            from '@material-ui/core/Dialog';\r\nimport DialogContent     from '@material-ui/core/DialogContent';\r\nimport DialogTitle       from '@material-ui/core/DialogTitle';\r\nimport Typography        from '@material-ui/core/Typography';\r\nimport {TransitionZoom}  from 'util/Transition';\r\nimport {alert}           from 'util/notify';\r\n\r\n\r\n/**\r\n * A modal SplashScreen used when there is nothing else to display :-)\r\n *\r\n * The SplashScreen will responsively/dynamically utilize the full\r\n * screen for cell phone devices.\r\n *\r\n * The SplashScreen can be instantiated with a direct message to display:\r\n * ```js\r\n * <SplashScreen msg=\"hello world\" [err={error}]/>\r\n * ```\r\n * \r\n * In support of the programmatic API, a single SplashScreen must be statically\r\n * instantiated in the root of your DOM (without any msg):\r\n * ```js\r\n * <SplashScreen/>\r\n * ```\r\n *\r\n * Supporting the following programmatic API:\r\n * ```js\r\n *   + splash(msg, [err]): void ... display the supplied msg/err in the programmatic SplashScreen\r\n *   + splash(): void           ... clear the programmatic SplashScreen\r\n * ```\r\n */\r\nexport default function SplashScreen({msg, err}) {\r\n\r\n  const isCellPhone = useForCellPhone();\r\n  const classes     = useStyles();\r\n\r\n  // conditionally render SplashScreenProgrammatic when NO msg is supplied\r\n  return msg ? <SplashScreenCommon msg={msg} err={err} open={true} fullScreen={isCellPhone} classes={classes}/>\r\n             : <SplashScreenProgrammatic                           fullScreen={isCellPhone} classes={classes}/>;\r\n}\r\n\r\nSplashScreen.propTypes = {\r\n  msg: PropTypes.string,\r\n  err: PropTypes.object,\r\n};\r\n\r\nSplashScreen.defaultProps = {\r\n  msg: '',\r\n  err: null,\r\n};\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n  title: {\r\n    color:           theme.palette.common.white,\r\n    backgroundColor: theme.palette.primary.main, // theme.palette.primary.main (bluish) or theme.palette.secondary.main (redish)\r\n  },\r\n\r\n  progress: {\r\n    margin: theme.spacing(4),\r\n  },\r\n}) );\r\n\r\n\r\n// ***\r\n// *** Our programmatic API (see docs above)\r\n// ***\r\n\r\n// <SplashScreenProgrammatic fullScreen= classes= />\r\nfunction SplashScreenProgrammatic({fullScreen, classes}) {\r\n\r\n  // maintain our programmatic state ... the msg/err to display\r\n  const [splashState, setSplashState] = useState({\r\n    msg: '',\r\n    err: null,\r\n  });\r\n\r\n  // broaden the scope of our splashState setter (used in our `splash(msg, [err])` programmatic API)\r\n  if (_setSplashState && _setSplashState!==setSplashState) { // validate that only one instance exists\r\n    throw new Error('***ERROR*** <SplashScreen/> (supporting the programmatic `splash(msg, [err])` API) should only be instantiated ONE TIME (in the app root DOM)');\r\n  }\r\n  _setSplashState = setSplashState; // THIS should work ... no need for: _setSplashState = useCallback(...);\r\n\r\n  // render our component\r\n  return <SplashScreenCommon msg={splashState.msg} err={splashState.err} open={splashState.msg ? true : false} fullScreen={fullScreen} classes={classes} />;\r\n}\r\n\r\n// our programmatic API\r\nexport function splash(msg='', err=null) {\r\n  // implement in terms of <SplashScreenProgrammatic> state\r\n  if (!_setSplashState) {\r\n    throw new Error('***ERROR*** the programmatic `splash(msg, [err])` API requires <SplashScreen/> be instantiated in the app root DOM');\r\n  }\r\n  _setSplashState({msg, err});\r\n}\r\nlet _setSplashState = null; // expose our inner function\r\n\r\n\r\n// ***\r\n// *** Our \"common\" rendering agent shared by BOTH `<SplashScreen>` and `<SplashScreenProgrammatic>`\r\n// ***\r\n\r\nlet _errLastReported = null;\r\n\r\n// <SplashScreenCommon msg= open= fullScreen= classes= />\r\nfunction SplashScreenCommon({msg, err, open, fullScreen, classes}) {\r\n\r\n  // setup any error rendering constructs\r\n  const errCntl = !err ? null : (\r\n    <>\r\n      <br/>\r\n      <Typography variant=\"subtitle2\" color=\"secondary\">Encountered ERROR: {err.formatUserMsg()}</Typography>\r\n      <Button variant=\"contained\" color=\"secondary\" onClick={handleErr}>\r\n        <Typography variant=\"subtitle2\">Show Detail</Typography>\r\n      </Button>\r\n    </>\r\n  );\r\n  function handleErr() {\r\n    alert.error({ msg: `An unexpected error occurred:\r\n\r\n${err}\r\n\r\nIf this problem persists, please contact your tech support.`\r\n    });\r\n  }\r\n\r\n  // when supplied, log the details of the error (with traceback) for tech review\r\n  // NOTE 1: we refrain from using console.warn() and console.error() \r\n  //         because of BAD semantics inferred by react-native/expo:\r\n  //          - console.warn():  generates yellow popup\r\n  //          - console.error(): kills app with \"red screen of death\"\r\n  // NOTE 2: react-native/expo appears to be doing something non standard\r\n  //         when passing error as the 2nd parameter of log():\r\n  //             log('msg', error)\r\n  //         ... in this case is merely emitting error.toString()\r\n  //         ... we can however receive a stack trace by calling log(error) as the first parameter\r\n  if (err && err !== _errLastReported) {\r\n    _errLastReported = err;\r\n    const prefix = err.isUnexpected() ? '*** Unexpected Error:\\n\\n' : '*** Expected Error:\\n\\n';\r\n    console.log(prefix + err);\r\n    if (err.isUnexpected()) { // produce stack traces only for unexpected errors\r\n      console.log('Stack Trace ...');\r\n      console.log(err);\r\n    }\r\n  }\r\n\r\n  // render our component\r\n  return (\r\n    <Dialog open={open}\r\n            fullScreen={fullScreen}\r\n            TransitionComponent={TransitionZoom}>\r\n      \r\n      <DialogTitle className={classes.title}>\r\n        <center className={classes.title}>Visualize It</center>\r\n      </DialogTitle>\r\n      \r\n      <DialogContent>\r\n        <center>\r\n          <br/>\r\n          <img width=\"120px\" src='visualize-it-logo.png' alt='visualize-it'/>\r\n          <br/>\r\n          <Progress className={classes.progress} color=\"secondary\"/>\r\n          <Typography variant=\"body2\">{msg}</Typography>\r\n          {errCntl}\r\n          <br/>\r\n        </center>\r\n      </DialogContent>\r\n      \r\n    </Dialog>\r\n  );\r\n}\r\n","import {useTheme}           from '@material-ui/core/styles';\r\nimport useMediaQuery        from '@material-ui/core/useMediaQuery';\r\nimport {useSelector}        from 'react-redux'\r\nimport {getResponsiveMode}  from 'features/common/baseUI/state'\r\n\r\n\r\n/**\r\n * A react hook promoting a boolean indicator (true/false) as to\r\n * whether the device's width represents a typical cell phone.\r\n * \r\n * @return {boolean} see description (above)\r\n */\r\nexport function useForCellPhone() {\r\n  const theme       = useTheme();\r\n  const isCellPhone = useMediaQuery(theme.breakpoints.down('xs')); // available breakpoints: xs/sm/md/lg/xl\r\n\r\n  return isCellPhone;\r\n}\r\n\r\n\r\n/**\r\n * A react hook promoting a boolean indicator (true/false) as to\r\n * whether the device's width is sufficient to be considered a tablet\r\n * (or greater - such as a desktop).\r\n *\r\n * @return {boolean} see description (above)\r\n *\r\n * @deprecated ... currently NOT used\r\n */\r\nexport function useForTabletPlus() {\r\n  const theme        = useTheme();\r\n  const isTabletPlus = useMediaQuery(theme.breakpoints.up('md')); // breakpoints: xs/sm/md/lg/xl\r\n\r\n  return isTabletPlus;\r\n}\r\n\r\n\r\n/**\r\n * A react hook promoting a boolean indicator (true/false) as to\r\n * whether the device's width is sufficient to be filled with more\r\n * content (such as a tablet or desktop).\r\n *\r\n * This algorithm is based on the breakpoint defined in the\r\n * reactiveMOde state, which can be controlled by the user -AND-\r\n * disabled.\r\n *\r\n * @return {boolean} see description (above)\r\n */\r\n\r\nexport function useForWiderDevice() {\r\n  const responsiveMode  = useSelector( (appState) => getResponsiveMode(appState), [] );\r\n  const theme           = useTheme();\r\n  const isWiderDevice   = useMediaQuery(theme.breakpoints.up(responsiveMode)); // NOTE: theme.breakpoints.up('off'): false\r\n\r\n  return isWiderDevice;\r\n}\r\n","import React,\r\n       {useMemo}          from 'react';\r\nimport {useSelector}      from 'react-redux'\r\nimport PropTypes          from 'prop-types';\r\nimport {makeStyles}       from '@material-ui/core/styles';\r\nimport {MuiThemeProvider,      // NOTE: MuiThemeProvider **SHOULD** be at the root of ALL visible components\r\n        createMuiTheme}   from '@material-ui/core/styles';\r\nimport CssBaseline        from '@material-ui/core/CssBaseline';\r\nimport AppMotif           from './AppMotif';\r\nimport Notify             from 'util/notify';\r\nimport SplashScreen       from 'util/SplashScreen';\r\nimport {getUITheme}       from '../state';\r\n\r\n\r\n/**\r\n * MainLayout is a re-usable top-level component that promotes the\r\n * proper Material-UI (MUI) theming/styling WITH a responsive layout.\r\n * \r\n * The following items are provided through this component:\r\n *\r\n * - a **Responsive Design** that auto adjusts for desktops, cell\r\n *   phones, and portable devices\r\n *\r\n * - a **UI Theme** allowing the user to choose from light/dark\r\n *   renditions\r\n *\r\n * - an **About Dialog** is promoted from information gleaned from the\r\n *   `package.json`\r\n *\r\n * - the **Notify** utility is activated, supporting programmatic\r\n *   **toasts, alerts, and confirmations**\r\n *\r\n * - the **SplashScreen** utility is activated, supporting the programmatic\r\n *   `splash(msg)` API\r\n * \r\n * Please refer to the **`baseUI` README** for more information.\r\n */\r\nexport default function MainLayout({children}) {\r\n\r\n  const uiTheme    = useSelector((appState) => getUITheme(appState), []);\r\n  const themeInUse = useMemo(() => uiTheme==='dark' ? darkTheme : lightTheme, [uiTheme]);\r\n  const classes    = useStyles();\r\n\r\n  return (\r\n    <MuiThemeProvider theme={themeInUse}>\r\n      <CssBaseline/>\r\n      <Notify/>\r\n      <SplashScreen/>\r\n      <main className={classes.main}>\r\n        <AppMotif>\r\n          {children}\r\n        </AppMotif>\r\n      </main>\r\n    </MuiThemeProvider>\r\n  );\r\n}\r\n\r\nMainLayout.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n};\r\n\r\n\r\nconst lightTheme = createMuiTheme({\r\n  typography: {\r\n    useNextVariants: true,\r\n    fontSize:        12,   // USE smaller font size ... default is 16 (seems more like 14)\r\n  },\r\n\r\n  palette: {\r\n    type: 'light',\r\n    // CREATED FROM: https://material.io/tools/color/\r\n    primary: {                 // REF: Teal 800\r\n      light:        '#439889',\r\n      main:         '#00695c',\r\n      dark:         '#003d33',\r\n      contrastText: '#f5f5f5', // OVERRIDE: Grey 200\r\n    },\r\n    secondary: {               // REF: Red 800\r\n      light:        '#ff5f52',\r\n      main:         '#c62828',\r\n      dark:         '#8e0000',\r\n      contrastText: '#f5f5f5', // OVERRIDE: Grey 200\r\n    },\r\n  },\r\n});\r\n\r\nconst darkTheme = createMuiTheme({\r\n  typography: {\r\n    useNextVariants: true,\r\n    fontSize:        12,   // USE smaller font size ... default is 16 (seems more like 14)\r\n  },\r\n  palette: {\r\n    type: 'dark',\r\n    // CREATED FROM: https://material.io/tools/color/\r\n    primary: {                 // REF: Teal 800\r\n      light:        '#439889',\r\n      main:         '#00695c',\r\n      dark:         '#003d33',\r\n      contrastText: '#f5f5f5', // OVERRIDE: Grey 200\r\n    },\r\n    secondary: {               // REF: Red 800\r\n      light:        '#ff5f52',\r\n      main:         '#c62828',\r\n      dark:         '#8e0000',\r\n      contrastText: '#f5f5f5', // OVERRIDE: Grey 200\r\n    },\r\n  },\r\n});\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n  main: {\r\n    width:        'auto',\r\n    display:      'block', // Fix IE 11 issue.\r\n // marginLeft:   theme.spacing(3), // N/A: bad news for the overall layout\r\n // marginRight:  theme.spacing(3),\r\n\r\n // reactive design // N/A:  THIS IS CAUSING HAVOC on my main content container overall width\r\n // [theme.breakpoints.up(400 + theme.spacing(3 * 2))]: {\r\n //   width:       400,\r\n //   marginLeft:  'auto',\r\n //   marginRight: 'auto',\r\n // },\r\n  },\r\n}) );\r\n","import React           from 'react';\r\nimport PropTypes       from 'prop-types';\r\nimport MenuItem        from '@material-ui/core/MenuItem';\r\nimport {closeUserMenu} from './UserMenu';\r\n\r\n/**\r\n * UserMenuItem: our UserMenuItem - a MenuItem wrapper that auto-closes the UserMenu.\r\n */\r\nexport default function UserMenuItem(props) {\r\n\r\n  // value-added onClick that auto-closes the UserMenu\r\n  const myOnClick = (...args) => {\r\n    // auto-close the UserMenu\r\n    closeUserMenu()\r\n\r\n    // pass-through to client onClick()\r\n    if (props.onClick) {\r\n      props.onClick(...args);\r\n    }\r\n  };\r\n\r\n  // wrap <MenuItem>\r\n  return (\r\n    <MenuItem {...props} onClick={myOnClick}>{props.children}</MenuItem>\r\n  );\r\n}\r\n\r\nUserMenuItem.propTypes = {\r\n  children: PropTypes.node.isRequired, // UserMenuItem content is required (i.e. the label)\r\n};\r\n","import React,\r\n       {useMemo,\r\n        useCallback} from 'react';\r\n\r\nimport {useSelector,\r\n        useDispatch} from 'react-redux'\r\n\r\nimport _baseUIAct    from '../actions';\r\nimport {getUITheme}  from '../state';\r\n\r\nimport Chip          from '@material-ui/core/Chip';\r\nimport Divider       from '@material-ui/core/Divider';\r\nimport MoonIcon      from '@material-ui/icons/Brightness3';\r\nimport SunIcon       from '@material-ui/icons/WbSunny';\r\nimport UserMenuItem  from 'features/common/baseUI/comp/UserMenuItem';\r\n\r\n\r\n/**\r\n * ToggleUITheme: our user-profile menu items (in the App Header)\r\n * \r\n * NOTE: Because this is a \"custom\" component that is held in Menu\r\n *       (a ButtonBase MenuItem) it must be able to hold a ref ... hence\r\n *       the React.forwardRef()!\r\n *       see: https://material-ui.com/guides/migration-v3/#button\r\n *            https://material-ui.com/guides/composition/#caveat-with-refs\r\n *            AVOIDS following log:\r\n *            Warning: Function components cannot be given refs. Attempts to access\r\n *                     this ref will fail. Did you mean to use React.forwardRef()?\r\n * NOTE: Subsequent Discovery: I think this is really due to the fact that\r\n *       we were injecting <Divider/> too!\r\n *       This React.forwardRef() was NOT needed in src/features/common/auth/comp/AuthUserMenu.js,\r\n *       where it simply injected a series of <UserMenuItem>s in a React.Fragment ... hmmmm\r\n */\r\nconst ToggleUITheme = React.forwardRef( (props, ref) => {\r\n  const uiTheme = useSelector((appState) => getUITheme(appState), []);\r\n\r\n  const ChipIcon = useMemo(() => uiTheme==='light' ? MoonIcon  : SunIcon,    [uiTheme]);\r\n  const label    = useMemo(() => uiTheme==='light' ? 'to dark' : 'to light', [uiTheme]);\r\n\r\n  const dispatch      = useDispatch();\r\n  const toggleUITheme = useCallback(() => dispatch( _baseUIAct.toggleUITheme() ), [dispatch]);\r\n\r\n  return (\r\n    <span {...props} ref={ref}>\r\n      <UserMenuItem onClick={toggleUITheme}>\r\n        <Chip label={label}\r\n              icon={<ChipIcon/>}/>\r\n      </UserMenuItem>\r\n      <Divider/>\r\n    </span>\r\n  );\r\n});  \r\nexport default ToggleUITheme;\r\n","import React,\r\n       {useMemo,\r\n        useCallback} from 'react';\r\n\r\nimport {useSelector,\r\n        useDispatch} from 'react-redux'\r\n\r\nimport _baseUIAct           from '../actions';\r\nimport {getResponsiveMode}  from '../state';\r\n\r\nimport Chip          from '@material-ui/core/Chip';\r\nimport Divider       from '@material-ui/core/Divider';\r\nimport CheckedIcon    from '@material-ui/icons/Check';\r\nimport UserMenuItem  from 'features/common/baseUI/comp/UserMenuItem';\r\n\r\nimport {confirm}     from 'util/notify';\r\n\r\n\r\n/**\r\n * MaintainResponsiveMode: our user-profile menu items (in the App Header)\r\n * \r\n * NOTE: Because this is a \"custom\" component that is held in Menu\r\n *       (a ButtonBase MenuItem) it must be able to hold a ref ... hence\r\n *       the React.forwardRef()!\r\n *       see: https://material-ui.com/guides/migration-v3/#button\r\n *            https://material-ui.com/guides/composition/#caveat-with-refs\r\n *            AVOIDS following log:\r\n *            Warning: Function components cannot be given refs. Attempts to access\r\n *                     this ref will fail. Did you mean to use React.forwardRef()?\r\n * NOTE: Subsequent Discovery: I think this is really due to the fact that\r\n *       we were injecting <Divider/> too!\r\n *       This React.forwardRef() was NOT needed in src/features/common/auth/comp/AuthUserMenu.js,\r\n *       where it simply injected a series of <UserMenuItem>s in a React.Fragment ... hmmmm\r\n */\r\nconst MaintainResponsiveMode = React.forwardRef( (props, ref) => {\r\n\r\n  const responsiveMode = useSelector((appState) => getResponsiveMode(appState), []);\r\n\r\n  const ChipIcon = useMemo(() => responsiveMode==='off' ? ()=>null : CheckedIcon, [responsiveMode]);\r\n\r\n  const dispatch                = useDispatch();\r\n  const maintainResponsiveMode  = useCallback(() => {\r\n    confirm.success({ \r\n      msg: `This app is designed with mobile devices in mind (i.e. cell phones).\r\n\r\nWhen the \"responsive\" mode is enabled, selected screens will dynamically adjust to take advantage of the additional screen real estate.  As an example, a simple list can morph into a detailed table.\r\n\r\nYou can define the \"responsive\" boundary where additional content is manifest (based on the screen width), or disable it altogether.\r\n\r\nSet the \"responsive\" boundary to:\r\n(** is current)`,\r\n      actions: [\r\n        ...defineActions(responsiveMode, dispatch),\r\n        { txt: 'Close' },\r\n      ]\r\n    });\r\n  }, [dispatch, responsiveMode]);\r\n\r\n  return (\r\n    <span {...props} ref={ref}>\r\n      <UserMenuItem onClick={maintainResponsiveMode}>\r\n        <Chip label=\"responsive\"\r\n              icon={<ChipIcon/>}/>\r\n      </UserMenuItem>\r\n      <Divider/>\r\n    </span>\r\n  );\r\n});  \r\nexport default MaintainResponsiveMode;\r\n\r\n\r\nconst breakpoints = [\r\n//{name: 'Phone',      value: 'xs'},  // xs, extra-small:    0px ... breakpoint ranges are from this point TO the next range (inclusive)\r\n  {name: 'Tablet',     value: 'sm'},  // sm, small:        600px\r\n  {name: 'Desktop',    value: 'md'},  // md, medium:       960px\r\n  {name: 'Landscape',  value: 'lg'},  // lg, large:       1280px\r\n//{name: 'Super-Wide', value: 'xl'},  // xl, extra-large: 1920px\r\n  {name: 'Disable',    value: 'off'},\r\n];\r\n\r\nconst defineActions = (curResponsiveMode, dispatch) => breakpoints.map( (breakpoint) => ({\r\n  txt:    `${ curResponsiveMode===breakpoint.value ? '**' : '' }${breakpoint.name}`,\r\n  action: () => dispatch( _baseUIAct.setResponsiveMode(breakpoint.value) ),\r\n}) );\r\n","import React         from 'react';\r\n\r\nimport {alert}       from 'util/notify';\r\n\r\nimport Divider       from '@material-ui/core/Divider';\r\nimport UserMenuItem  from 'features/common/baseUI/comp/UserMenuItem';\r\n\r\n\r\n/**\r\n * About: display info about this app (gleaned from package.json)\r\n *\r\n * NOTE: These env vars require the following .env file (in your project root per CRA):\r\n *\r\n *   .env\r\n *   ====\r\n *   REACT_APP_NAME=$npm_package_name\r\n *   REACT_APP_VERSION=$npm_package_version\r\n *   REACT_APP_DESCRIPTION=$npm_package_description\r\n *   REACT_APP_ABOUT_DOCS=$npm_package_about_docs\r\n *   REACT_APP_ABOUT_HIST=$npm_package_about_hist\r\n *\r\n * NOTE: Because this is a \"custom\" component that is held in Menu\r\n *       (a ButtonBase MenuItem) it must be able to hold a ref ... hence\r\n *       the React.forwardRef()!\r\n *       see: https://material-ui.com/guides/migration-v3/#button\r\n *            https://material-ui.com/guides/composition/#caveat-with-refs\r\n *            AVOIDS following log:\r\n *            Warning: Function components cannot be given refs. Attempts to access\r\n *                     this ref will fail. Did you mean to use React.forwardRef()?\r\n * NOTE: Subsequent Discovery: I think this is really due to the fact that\r\n *       we were injecting <Divider/> too!\r\n *       This React.forwardRef() was NOT needed in src/features/common/auth/comp/AuthUserMenu.js,\r\n *       where it simply injected a series of <UserMenuItem>s in a React.Fragment ... hmmmm\r\n */\r\nconst About = React.forwardRef( (props, ref) => (\r\n  <span {...props} ref={ref}>\r\n    <Divider/>\r\n    <UserMenuItem onClick={showAbout}>About ...</UserMenuItem>\r\n  </span>\r\n) );\r\nexport default About;\r\n\r\nfunction showAbout() {\r\n  const name    = process.env.REACT_APP_NAME        || 'UNKNOWN name (from package.json: name)';\r\n  const desc    = process.env.REACT_APP_DESCRIPTION || 'UNKNOWN desc (from package.json: description)';\r\n  const ver     = process.env.REACT_APP_VERSION     || 'UNKNOWN (from package.json: version)';\r\n  const docsUrl = process.env.REACT_APP_ABOUT_DOCS;\r\n  const histUrl = process.env.REACT_APP_ABOUT_HIST;\r\n\r\n  const msg = `${name}\\n\\n${desc}\\n\\nversion: ${ver}`;\r\n\r\n  const actions = [];\r\n  if (docsUrl)\r\n    actions.push({ txt: 'Docs',    action: () => window.open(docsUrl, '_blank') });\r\n  if (histUrl)\r\n    actions.push({ txt: 'History', action: () => window.open(histUrl, '_blank') });\r\n  actions.push({ txt: 'Close' });\r\n\r\n  alert.success({msg, actions});\r\n}\r\n","import React                  from 'react';\r\nimport {createFeature,\r\n        fassetValidations}    from 'feature-u';\r\n\r\nimport _baseUI                from './featureName';\r\nimport _baseUIAct             from './actions';\r\nimport reducer                from './state';\r\nimport * as _baseUISel        from './state';\r\nimport logic                  from './logic';\r\nimport leftNavManager         from './LeftNavManager';\r\n\r\nimport MainLayout             from './comp/MainLayout';\r\nimport ToggleUITheme          from './comp/ToggleUITheme';\r\nimport MaintainResponsiveMode from './comp/MaintainResponsiveMode';\r\nimport About                  from './comp/About';\r\n\r\n// feature: baseUI <<< full details in README\r\n//          Provides a UI foundation for an entire application.\r\n//          It manages the following characteristics:\r\n//          - a Responsive Design that auto adjusts for desktops, cell phones, and\r\n//            portable devices.\r\n//          - a UI Theme allowing the user to choose from light/dark renditions\r\n//          - when an active user is signed-in, the following items are also\r\n//            manifest:\r\n//            - a \"Left Nav\" menu\r\n//            - a \"User Menu\" menu\r\n//            - a \"Current View\" state (orchestrating which application view is active)\r\n//            - a \"Tool Bar\" with various artifacts (ex: title bar and footer)\r\nexport default createFeature({\r\n  name: _baseUI,\r\n\r\n  // our public face ...\r\n  fassets: {\r\n\r\n    define: {\r\n      'actions.changeView': _baseUIAct.changeView, // changeView(viewName)\r\n      'sel.curView':        _baseUISel.curView,    // curView(appState): string\r\n\r\n      'actions.addLeftNavItem':    _baseUIAct.addLeftNavItem,    // addLeftNavItem(leftNavKey, LeftNavComp)\r\n      'actions.removeLeftNavItem': _baseUIAct.removeLeftNavItem, // removeLeftNavItem(leftNavKey)\r\n    },\r\n\r\n    defineUse: {\r\n      // inject User Menu entries\r\n      // ... to ToggleUITheme ('light'/'dark')\r\n      'AppMotif.UserMenuItem.aa1_UIThemeToggle': ToggleUITheme,\r\n      // ... to MaintainResponsiveMode ('md'/'lg'/'off')\r\n      'AppMotif.UserMenuItem.aa2_MaintainResponsiveMode': MaintainResponsiveMode,\r\n      // ... to display About info (gleaned from package.json)\r\n      'AppMotif.UserMenuItem.zz8_About': About,\r\n    },\r\n\r\n    use: [\r\n      // full details in README\r\n      ['AppMotif.UserMenuItem.*',   {required: true,  type: fassetValidations.comp}],\r\n      ['AppMotif.auxViewContent.*', {required: false, type: fassetValidations.any}],\r\n    ],\r\n  },\r\n\r\n  reducer,\r\n  logic,\r\n\r\n  // inject our baseUI components into the root of our app\r\n  appWillStart({fassets, curRootAppElm}) {\r\n    return (\r\n      <MainLayout>\r\n        {curRootAppElm}\r\n      </MainLayout>\r\n    );\r\n  },\r\n\r\n  // inject operational dependencies into leftNavManager\r\n  appInit({showStatus, fassets, getState, dispatch}) {\r\n    leftNavManager.injectDependency(fassets, dispatch);\r\n  },\r\n\r\n});\r\n","import {combineReducers}    from 'redux';\r\nimport {reducerHash}        from 'astx-redux-util';\r\nimport {slicedReducer}      from 'feature-redux';\r\nimport _changeManager       from './featureName';\r\nimport _changeManagerAct    from './actions';\r\n\r\n\r\n// ***\r\n// *** Our feature reducer, managing state for our changeManager process.\r\n// ***\r\n\r\nconst reducer = slicedReducer(_changeManager, combineReducers({\r\n\r\n  // ePkgs: {      // indexed ePkg entries\r\n  //   [ePkgId]: { // ex: 'com.astx.ACME' for pkg (SmartPkg) or 'com.astx.ACME/scene1' for pkgEntry\r\n  //     crc:     123,\r\n  //     baseCrc: 456\r\n  //   },\r\n  //   ...\r\n  // }\r\n  ePkgs: reducerHash({\r\n    [_changeManagerAct.registerEPkg]: updateCrcs,\r\n    [_changeManagerAct.ePkgChanged]:  updateCrcs,\r\n  }, {}), // initialState\r\n\r\n  \r\n  // undoRedo: {       // indexed PkgEntries\r\n  //   [pkgEntryId]: { // ex: 'com.astx.ACME/scene1'\r\n  //     undoAvail: true,\r\n  //     redoAvail: false\r\n  //   },\r\n  //   ...\r\n  // }\r\n  undoRedo: reducerHash({\r\n    [_changeManagerAct.undoRedoChanged]: (state, action) => ({...state, ...{ [action.pkgEntryId]:{undoAvail: action.undoAvail, redoAvail: action.redoAvail} } }),\r\n  }, {}), // initialState\r\n\r\n\r\n\r\n}) );\r\n\r\nexport default reducer;\r\n\r\nfunction updateCrcs(state, action) {\r\n  const ePkgs = state;\r\n  const {ePkgId, crc, baseCrc} = action;\r\n  return {...ePkgs, ...{\r\n    [ePkgId]: {crc, baseCrc}\r\n  }};\r\n}\r\n\r\n// ***\r\n// *** Various Selectors\r\n// ***\r\n\r\n// Our feature state root (via slicedReducer as a single-source-of-truth)\r\nconst getFeatureState  = (appState) => reducer.getSlicedState(appState);\r\nconst gfs              = getFeatureState; // ... concise alias (used internally)\r\n\r\n// getEPkgState(appState, ePkgId): ePkgState (undefined if bad ePkgId param ... ?? undefined is needed till we get class entries fully resolved\r\nexport const getEPkgState = (appState, ePkgId) => gfs(appState).ePkgs[ePkgId];\r\n\r\n// isEPkgInSync(appState, ePkgId): boolean\r\nexport const isEPkgInSync = (appState, ePkgId) => {\r\n  const ePkgState = getEPkgState(appState, ePkgId);\r\n  //console.log(`xx sel.isEPkgInSync ePkgId: ${ePkgId} ... `, {ePkgState});\r\n  return ePkgState ? (ePkgState.crc === ePkgState.baseCrc) : true;  // if we couldn't find it call it in-sync ... ?? needed till we get class entries fully resolved\r\n}\r\n\r\n// getUndoRedo(appState, pkgEntryId): UndoRedo - {undoAvail: boolean, redoAvail: boolean} ?? undefined if bad ePkgId param ... ?? undefined is needed till we get class entries fully resolved\r\nexport const getUndoRedo = (appState, pkgEntryId) => {\r\n  const undoRedo = gfs(appState).undoRedo[pkgEntryId];\r\n  return undoRedo || {undoAvail: false, redoAvail: false}; // default to false/false\r\n}\r\n\r\nexport const isUndoAvail = (appState, pkgEntryId) => getUndoRedo(appState, pkgEntryId).undoAvail; // isUndoAvail(appState, pkgEntryId): boolean\r\nexport const isRedoAvail = (appState, pkgEntryId) => getUndoRedo(appState, pkgEntryId).redoAvail; // isRedoAvail(appState, pkgEntryId): boolean\r\n","import {createFeature}    from 'feature-u';\r\nimport _changeManager     from './featureName';\r\nimport reducer,\r\n       {isEPkgInSync,\r\n        isUndoAvail,\r\n        isRedoAvail}      from './state';\r\nimport changeManager      from './changeManager';\r\n\r\n\r\n// feature: changeManager\r\n//          a manager of change (retaining critical crcs in state)\r\nexport default createFeature({\r\n  name: _changeManager,\r\n\r\n  fassets: {\r\n    define: {\r\n      'sel.isEPkgInSync':  isEPkgInSync,  // isEPkgInSync(appState, ePkgId): boolean\r\n      'sel.isUndoAvail':   isUndoAvail,   // isUndoAvail(appState, pkgEntryId): boolean\r\n      'sel.isRedoAvail':   isRedoAvail,   // isRedoAvail(appState, pkgEntryId): boolean\r\n    },\r\n  },\r\n\r\n  reducer,\r\n\r\n  // inject operational dependencies into changeManager\r\n  appInit({showStatus, fassets, getState, dispatch}) {\r\n    changeManager.injectDependency(dispatch);\r\n  },\r\n\r\n});\r\n","import {generateActions}    from 'action-u';\r\nimport _tabManager          from './featureName';\r\n\r\nexport default generateActions.root({\r\n  [_tabManager]: { // prefix all actions with our feature name, guaranteeing they unique app-wide!\r\n\r\n    activateTab: { // actions.activateTab(tabId, preview=true): Action\r\n                   // > activate the specified tab (may exist, or will create on first reference)\r\n                   actionMeta: { // NOTE: logic supplements this action to simplify reducer (see docs)\r\n                     traits: ['tabId', 'preview'],\r\n                     ratify: (tabId, preview=true) => [tabId, preview],\r\n                   },\r\n    },\r\n\r\n    closeTab: { // actions.closeTab(tabId): Action\r\n                // > close specified tab\r\n                actionMeta: { // NOTE: logic supplements this action to simplify reducer (see docs)\r\n                  traits: ['tabId'],\r\n                },\r\n    },\r\n\r\n  },\r\n\r\n});\r\n","/**\r\n * Expose our featureName through a mini-meta module that is\r\n * \"importable\" in all use-cases (a single-source-of-truth).\r\n */\r\nexport default 'tabManager';\r\n","import {combineReducers}    from 'redux';\r\nimport {reducerHash}        from 'astx-redux-util';\r\nimport {slicedReducer}      from 'feature-redux';\r\nimport _tabManager          from './featureName';\r\nimport _tabManagerAct       from './actions';\r\n\r\n// ***\r\n// *** Our feature reducer, managing state for our tabManager process.\r\n// ***\r\n\r\nconst reducer = slicedReducer(_tabManager, combineReducers({\r\n\r\n  // activeTabId: string ... the tabId of the active tab\r\n  activeTabId: reducerHash({\r\n    [_tabManagerAct.activateTab]:     (state, action) => action.pgmDirectives.next_activeTabId,\r\n    [_tabManagerAct.closeTab]:        (state, action) => action.pgmDirectives.next_activeTabId,\r\n  }, null), // initialState\r\n\r\n  // previewTabId: string ... the tabId of the optional tab that is in preview mode (will be re-used)\r\n  previewTabId: reducerHash({\r\n    [_tabManagerAct.activateTab]:     (previewTabId, action) => action.pgmDirectives.next_previewTabId,\r\n    [_tabManagerAct.closeTab]:        (previewTabId, action) => previewTabId===action.tabId ? null : previewTabId,\r\n  }, null), // initialState\r\n\r\n  // tabs: [{tabId, tabName}, ...] ... all of our tab objects, fed from the activateTab action\r\n  tabs: reducerHash({\r\n    [_tabManagerAct.activateTab]: (tabs, action) => {\r\n      let   newTabs = tabs;\r\n      const {tabId, tabName}         = action;\r\n      const {removeTabId, addNewTab} = action.pgmDirectives;\r\n\r\n      if (removeTabId) {\r\n        newTabs = newTabs.filter( (tab) => tab.tabId !== removeTabId );\r\n      }\r\n      if (addNewTab) {\r\n        newTabs = [...newTabs, {tabId, tabName}];\r\n      }\r\n      return newTabs;\r\n    },\r\n\r\n    [_tabManagerAct.closeTab]: (tabs, action) => tabs.filter( (tab) => tab.tabId !== action.tabId ),\r\n\r\n  }, []), // initialState\r\n\r\n}) );\r\n\r\nexport default reducer;\r\n\r\n\r\n// ***\r\n// *** Various Selectors\r\n// ***\r\n\r\n// Our feature state root (via slicedReducer as a single-source-of-truth)\r\nconst getFeatureState  = (appState) => reducer.getSlicedState(appState);\r\nconst gfs              = getFeatureState; // ... concise alias (used internally)\r\n\r\nexport const getActiveTabId  = (appState) => gfs(appState).activeTabId;\r\nexport const getPreviewTabId = (appState) => gfs(appState).previewTabId;\r\nexport const getTabs         = (appState) => gfs(appState).tabs;\r\nexport const getTotalTabs    = (appState) => gfs(appState).tabs.length;\r\n","import {createLogic}        from 'redux-logic';\r\nimport _tabManager          from './featureName';\r\nimport _tabManagerAct       from './actions';\r\nimport * as sel             from './state';\r\nimport tabRegistry          from './tabRegistry';\r\n\r\n/**\r\n * Supplement the 'activateTab' action with the following directives\r\n * (centralize logic and simplifying our reducers):\r\n *\r\n * ```\r\n * action: {\r\n *   ... from incoming action:\r\n *   tabId:   'xyz'\r\n *   preview: true\r\n * \r\n *   ... supplemented by logic:\r\n *   tabName: 'ValveXyz'  ... strictly a convenience\r\n *   pgmDirectives: {     ... simplifies reducer\r\n *     next_activeTabId:  'xyz' (or null when NO tabs)\r\n *     next_previewTabId: 'xyz' (or null when NO preview tab)\r\n *     removeTabId:       'xyz' (or null) ... supports previewTab removal\r\n *     addNewTab:         true/false ... supports new tab creation (on first reference)\r\n *   }\r\n * }\r\n *```\r\n */\r\nexport const supplementActivateTab = createLogic({\r\n\r\n  name: `${_tabManager}.supplementActivateTab`,\r\n  type: String(_tabManagerAct.activateTab),\r\n\r\n  transform({getState, action, fassets}, next, reject) {\r\n\r\n    const appState = getState();\r\n\r\n    //***\r\n    //*** Request Aliases: req_ (from original action)\r\n    //***\r\n\r\n    const req_tabId   = action.tabId;\r\n    const req_preview = action.preview; // true: preview tab (single-click), false: permanent tab (double-click)\r\n\r\n\r\n    //***\r\n    //*** Current State Aliases: cur_ (from redux state)\r\n    //***\r\n\r\n//  const cur_activeTabId  = sel.getActiveTabId(appState);\r\n    const cur_previewTabId = sel.getPreviewTabId(appState);\r\n    const cur_tabs         = sel.getTabs(appState);\r\n\r\n    // the requested current tab entry (when it previously exists) ... undefined for new tab request\r\n    const cur_targetTab = cur_tabs.find( (tab) => req_tabId === tab.tabId );\r\n    \r\n    // does the requested target tab pre-exist?\r\n    const cur_targetTabPreExists = cur_targetTab ? true : false;\r\n\r\n    //***\r\n    //*** transform logic\r\n    //***\r\n\r\n    // reason about next_activeTabId\r\n    // ... for 'activateTab' action, this is ALWAYS our incoming tabId\r\n    const next_activeTabId = req_tabId;\r\n\r\n    // manage addNewTab directive\r\n    // ... action may direct the dynamic addition of a NEW tab FROM the tabCreator ReactComp found our Tab Registry\r\n    const addNewTab = !cur_targetTabPreExists;\r\n\r\n    // manage our preview tab directives\r\n    // ... this is the only complex aspect of this process\r\n\r\n    // ... default our directives to NO CHANGE\r\n    let next_previewTabId = cur_previewTabId; // DEFAULT: NO change\r\n    let removeTabId       = null;             // DEFAULT: null (i.e. NO preview tab to remove)\r\n\r\n    // ... when activating a new tab\r\n    if (addNewTab) {\r\n      if (req_preview) { // ... our new tab is a \"preview\" mode request\r\n        next_previewTabId = req_tabId;        // this new tab will now be the preview tab\r\n        removeTabId       = cur_previewTabId; // displacing prior preview tab (if any - may be null)\r\n      }\r\n      else { // ... our new tab is a \"permanent\" mode request (any prior preview should NOT change)\r\n        // ... this is our default setting\r\n      }\r\n    }\r\n    // ... when activating an existing tab\r\n    else {\r\n\r\n      // KEY: THIS IS THE REAL TESTING POINT\r\n      // if request is permanent, and this existing tab was previously preview\r\n      // ... we want to remove the preview connotation\r\n      if ( (!req_preview) && (req_tabId === cur_previewTabId) ) {\r\n        next_previewTabId = null; // remove ANY preview connotation\r\n      }\r\n      // .. otherwise we leave preview as-is (I THINK)\r\n\r\n    }\r\n\r\n    //***\r\n    //*** supplement our action with pgmDirectives (see JSDocs above)\r\n    //***\r\n\r\n    const tabController = tabRegistry.getTabController(req_tabId); // ... undefined when tab NOT registered\r\n    action.tabName = tabController ? tabController.getTabName() : 'UNKNOWN';\r\n\r\n    action.pgmDirectives = {\r\n      next_activeTabId,\r\n      next_previewTabId,\r\n      removeTabId,\r\n      addNewTab,\r\n    };\r\n\r\n    next(action);\r\n  },\r\n\r\n});\r\n\r\n\r\n/**\r\n * Supplement the 'closeTab' action with the following directives\r\n * (centralize logic and simplifying our reducers):\r\n *\r\n * ```\r\n * action: {\r\n *   ... from incoming action:\r\n *   tabId:   'xyz'\r\n * \r\n *   ... supplemented by logic:\r\n *   pgmDirectives: {     ... simplifies reducer\r\n *     next_activeTabId:  'xyz' (or null when NO tabs)\r\n *   }\r\n * }\r\n *```\r\n */\r\nexport const supplementCloseTab = createLogic({\r\n\r\n  name: `${_tabManager}.supplementCloseTab`,\r\n  type: String(_tabManagerAct.closeTab),\r\n\r\n  transform({getState, action, fassets}, next, reject) {\r\n\r\n    const appState = getState();\r\n\r\n    const tabs         = sel.getTabs(appState);\r\n    const closeTabIndx = tabs.findIndex( (tab) => action.tabId === tab.tabId );\r\n\r\n    // we shift our next active tab to the right (except on end - to the left)\r\n    // ... REMEMBER: we are dealing with the state (array) BEFORE it has been altered\r\n\r\n    //                                                     AT END ...       NOT AT END ...\r\n    //                                                     ==============   ==============\r\n    const nextTabIndx = (closeTabIndx === tabs.length-1) ? closeTabIndx-1 : closeTabIndx+1;\r\n    const nextTabId   = nextTabIndx < 0 ? null : tabs[nextTabIndx].tabId;\r\n\r\n\r\n    //***\r\n    //*** supplement our action with pgmDirectives (see JSDocs above)\r\n    //***\r\n\r\n    action.pgmDirectives = {\r\n      next_activeTabId: nextTabId,\r\n    };\r\n\r\n    next(action);\r\n  },\r\n\r\n});\r\n\r\n\r\n/**\r\n * Synchronize the target tab's DispMode each time a tab is activated.\r\n *\r\n * This will insure the internal Konva state matches the object\r\n * model's initial state!\r\n * \r\n * BACKGROUND: Normally a DispMode starts out in a 'view\" mode.\r\n *             HOWEVER: If we close a tab that is in edit mode, \r\n *                      and then when we bring the tab back\r\n *                      (from the LeftNav) the model will now\r\n *                       match the last DispMode!\r\n */\r\nexport const syncTargetDispMode = createLogic({\r\n\r\n  name: `${_tabManager}.syncTargetDispMode`,\r\n  type: String(_tabManagerAct.activateTab),\r\n\r\n  // NOTE: we perform this in the \"process\" phase because Konva must be mounted to work :-(\r\n  process({getState, action, fassets}, dispatch, done) {\r\n\r\n    // when this is a new tab ...\r\n    if (action.pgmDirectives.addNewTab) {\r\n\r\n      // sync it's Konva state to match the object model's initial state\r\n      // ... see JavaDoc (above)\r\n      // console.log(`xx LOGIC: ${_tabManager}.syncTargetDispMode ... syncing now!`);\r\n      const tabController = tabRegistry.getTabController(action.tabId); // ... AI: may error - returns undefined if NOT registered?\r\n      const target        = tabController.getTarget();\r\n      target.setDispMode( target.getDispMode() );\r\n    }\r\n\r\n    done();\r\n  },\r\n\r\n});\r\n\r\n\r\n/**\r\n * Synchronize any out-of-date class references each time a tab is\r\n * activated.\r\n *\r\n * Class versioning can become out-of-sync when interactive edits\r\n * occur to the class master (visualized in a separate tab).\r\n *\r\n * Currently, this is only operational for pseudo classes.  Real\r\n * code-based class versioning is not currently tracked, and will\r\n * therefore always be in-sync.\r\n */\r\nexport const syncOutOfDateClasses = createLogic({\r\n\r\n  name: `${_tabManager}.syncOutOfDateClasses`,\r\n  type: String(_tabManagerAct.activateTab),\r\n\r\n  // NOTE: we perform this in the \"process\" phase because Konva must be mounted to work :-(\r\n  process({getState, action, fassets}, dispatch, done) {\r\n\r\n    // locate the tab's top-level PkgEntry\r\n    const tabController = tabRegistry.getTabController(action.tabId); // ... AI: may error - returns undefined if NOT registered?\r\n    const pkgEntry      = tabController.getTarget();\r\n\r\n    // whe package is out-of-sync ...\r\n    if (pkgEntry.areClassesOutOfSync()) {\r\n      // console.log(`xx activateTab for ${pkgEntry.getName()} ... something is out-of-sync!`);\r\n\r\n      // locate the top-level SmartView\r\n      const view = pkgEntry.getView();\r\n      const containingHtmlElm = view.containingHtmlElm;\r\n\r\n      // unmount the Konva visuals\r\n      view.unmount();\r\n\r\n      // sync our object model\r\n      pkgEntry.syncClassInstances();\r\n\r\n      // re-mount the Konva visuals\r\n      view.mount(containingHtmlElm);\r\n\r\n      // re-establish our pkgEntry DispMode\r\n      // ... this resets all our event handlers given the re-mount :-)\r\n      pkgEntry.setDispMode( pkgEntry.getDispMode() );\r\n    }\r\n    else {\r\n      // console.log(`xx activateTab for ${pkgEntry.getName()} ... everything is in-sync!`);\r\n    }\r\n\r\n    done();\r\n  },\r\n});\r\n\r\n\r\n/**\r\n * Unmount the Konva visuals, whenever a tab is closed.\r\n */\r\nexport const unmountKonva = createLogic({\r\n\r\n  name: `${_tabManager}.unmountKonva`,\r\n  type: String(_tabManagerAct.closeTab),\r\n\r\n  // NOTE: we perform this in the \"process\" phase because Konva must be mounted to work :-(\r\n  process({getState, action, fassets}, dispatch, done) {\r\n\r\n    // locate the tab's top-level PkgEntry\r\n    const tabController = tabRegistry.getTabController(action.tabId); // ... AI: may error - returns undefined if NOT registered?\r\n    const pkgEntry      = tabController.getTarget();\r\n\r\n    // locate the top-level SmartView\r\n    const view = pkgEntry.getView();\r\n\r\n    // unmount the Konva visuals\r\n    view.unmount();\r\n\r\n    // that's all folks\r\n    done();\r\n  },\r\n\r\n});\r\n\r\n\r\n// promote all logic modules for this feature\r\n// ... NOTE: individual logic modules are unit tested using the named exports.\r\nexport default [\r\n  supplementActivateTab,\r\n  supplementCloseTab,\r\n\r\n  syncTargetDispMode,\r\n\r\n  syncOutOfDateClasses,\r\n\r\n  unmountKonva,\r\n];\r\n","import React,\r\n       {useCallback}       from 'react';\r\n\r\nimport {useSelector,\r\n        useDispatch}       from 'react-redux'\r\n\r\nimport {createLogger}      from 'util/logger';\r\n\r\nimport * as _tabManagerSel from '../state';\r\nimport _tabManagerAct      from '../actions';\r\nimport tabRegistry         from '../tabRegistry';\r\n\r\nimport AppBar              from '@material-ui/core/AppBar';\r\nimport Box                 from '@material-ui/core/Box';\r\nimport CloseIcon           from '@material-ui/icons/Close';\r\nimport Grid                from '@material-ui/core/Grid';\r\nimport Paper               from '@material-ui/core/Paper';\r\nimport Tab                 from '@material-ui/core/Tab';\r\nimport Tabs                from '@material-ui/core/Tabs';\r\nimport Typography          from '@material-ui/core/Typography';\r\nimport {makeStyles}        from '@material-ui/core/styles';\r\n\r\n// our internal diagnostic logger (normally disabled)\r\nconst log = createLogger('***DIAG*** <TabManager> ... ').disable();\r\n\r\n/**\r\n * TabManager: Our top-level manager of tabs.\r\n */\r\nexport default function TabManager() {\r\n\r\n  const classes = useStyles();\r\n\r\n  const activeTabId  = useSelector((appState) => _tabManagerSel.getActiveTabId(appState), []);\r\n  const previewTabId = useSelector((appState) => _tabManagerSel.getPreviewTabId(appState), []);\r\n  const tabs         = useSelector((appState) => _tabManagerSel.getTabs(appState), []);\r\n  const dispatch     = useDispatch();\r\n  const handleTabChanged   = useCallback((event, tabId) => {\r\n    log(`handleTabChanged('${tabId}')`);\r\n    dispatch( _tabManagerAct.activateTab(tabId) );\r\n  }, [dispatch]);\r\n\r\n  // NOTE: handleCloseTab is currently NOT cached because I am creating multiple inline funcs within the render (below)\r\n  const handleCloseTab = (event, tabId) => {\r\n    log('in handleCloseTab: ', tabId);\r\n    event.stopPropagation(); // prevent parent tabChanged event from firing ... if not done, it can fire AFTER closeTab - which is bad (because the tab is gone)\r\n    dispatch( _tabManagerAct.closeTab(tabId) );\r\n  };\r\n\r\n  // PERF: TabManager renders 2 times every tab change ... performance doesn't appear to be a problem :-)\r\n  log('rendering');\r\n\r\n  // NOTE: Each TabPanel content is app-specific,\r\n  //       dynamically created through the tab registry's tabCreator ReactComp.\r\n\r\n  // TABS NOTE: <Tabs> value IS the currently selected Tab value\r\n  //            ... can be false - NO tab selected (NOT all that useful)\r\n  //            ... onChange is fired when <Tab> clicked, passing new active <Tab> value\r\n\r\n  return (\r\n    <>\r\n      <AppBar position=\"static\" color=\"default\">\r\n        <Tabs value={activeTabId}\r\n              onChange={handleTabChanged}\r\n              indicatorColor=\"primary\"\r\n              textColor=\"primary\"\r\n              variant=\"scrollable\"\r\n              scrollButtons=\"auto\">\r\n          {tabs.map( (tab) => {\r\n\r\n             const pkgEntry = tabRegistry.getTabController(tab.tabId).getTarget(); // ... tabId IS pkgEntry\r\n             const tabLabel = tab.tabName + (pkgEntry.isInSync() ? '' : ' **');\r\n\r\n             return (\r\n               <Tab className={tab.tabId===previewTabId ? classes.tabPreview : classes.tabPermanent}\r\n                    key={tab.tabId}\r\n                    value={tab.tabId}\r\n                    label={(\r\n                      <Grid container\r\n                            // force dual items to edge\r\n                            justify=\"space-between\">\r\n                        <Grid item>\r\n                          <Typography variant=\"subtitle2\" color=\"inherit\">\r\n                            {tabLabel}\r\n                          </Typography>\r\n                        </Grid>\r\n                        <Grid item>\r\n                          <CloseIcon onClick={(e) => handleCloseTab(e, tab.tabId)}/>\r\n                        </Grid>\r\n                      </Grid>\r\n                    )}\r\n               />\r\n             );\r\n           } )}\r\n        </Tabs>\r\n      </AppBar>\r\n      {tabs.map( tab => {\r\n         const tabController = tabRegistry.getTabController(tab.tabId); // ... AI: may error - returns undefined if NOT registered?\r\n         const TabCreator    = tabController.getTabPanelComp();\r\n         return (\r\n           <TabPanel key={tab.tabId}\r\n                     tabId={tab.tabId}\r\n                     activeTabId={activeTabId}>\r\n             {/* AI: this content will be dynamically rendered\r\n           \r\n                     NOTE: the following div/Box (if used) will show you the results of a big content and where the scroll bars appear\r\n                          <div style={{height: 2000, width: 1000, border: '1px solid orange'}}>\r\n           \r\n                          <Box border={1}\r\n                                borderColor=\"secondary.light\">\r\n           \r\n                          <Box border={1}\r\n                               borderColor=\"secondary.light\"\r\n                               width={1000}\r\n                               height={2000}>\r\n           \r\n                               primary.light: green diff shade\r\n                               primary.main:  green\r\n                               primary.dark:  green diff shade\r\n           \r\n                               secondary.light: grayish <<< like this one\r\n                               secondary.main:  purple\r\n                               secondary.dark:  almost black\r\n               */}\r\n             <TabCreator/>\r\n           </TabPanel>\r\n         );\r\n       } )}\r\n    </>\r\n  );\r\n}\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n  tabPreview: {\r\n    fontStyle: 'italic',\r\n  },\r\n  tabPermanent: {\r\n  },\r\n}) );\r\n\r\n\r\n// TODO: consider moving TabPanel out into it's own module (possibly NOT if we only use it here)\r\n// TODO: something above TabPanel is giving it the full width\r\n//       how to fill all vertical space?\r\n//        - a style height: '100%' kinda works, but it doesn't account for filler under AppBar\r\n//          ... style={{height: '100%'}}\r\n//        - can use css calc(): 97px = 48px AppBar + 49px TabBar <<< number calculation is a real hack\r\n//          ... style={{height: 'calc(100% - 97px)'}}\r\n// NOTE: the box (below) is giving us a bit of styling (currently padding so as to not place content right up to the edge)\r\nconst TabPanel = ({tabId, activeTabId, children}) => (\r\n  <Paper hidden={tabId !== activeTabId} style={{height: 'calc(100% - 97px)'}}>\r\n    <Box padding={1}>\r\n      {children}\r\n    </Box>\r\n  </Paper>\r\n);\r\n","import React from 'react';\r\nimport Grid  from '@material-ui/core/Grid';\r\n\r\n/**\r\n * A component that centers all contained children within a Grid (both horizontally and vertically).\r\n */\r\nexport default function CenterItems({children}) {\r\n  return (\r\n    <Grid container direction=\"row\" justify=\"center\" alignItems=\"center\">\r\n      {children}\r\n    </Grid>\r\n  );\r\n}\r\n\r\n/**\r\n * A component that horizontally centers all contained children within a Grid.\r\n * AI: Currently not used (added in an attempt to fix icon alignment with text, but found better solution)\r\n */\r\nexport function CenterItemsHorizontally({children}) {\r\n  return (\r\n    <Grid container direction=\"row\" justify=\"flex-start\" alignItems=\"center\">\r\n      {children}\r\n    </Grid>\r\n  );\r\n}\r\n","import React           from 'react';\r\n\r\nimport {makeStyles}    from '@material-ui/core/styles';\r\nimport Typography      from '@material-ui/core/Typography';\r\nimport Paper           from '@material-ui/core/Paper';\r\nimport CenterItems     from 'util/CenterItems';\r\n\r\n\r\n/**\r\n * StartUpPage: our initial display when NO tabs are active.\r\n */\r\nexport default function StartUpPage() {\r\n\r\n  const classes = useStyles();\r\n\r\n  // NOTE: relative path (in imgs below) support server deployment in sub-directory\r\n  // ?? HACK: how to fill all vertical space (using calc below) see TabManager.js note\r\n  return (\r\n    <Paper className={classes.root} style={{height: 'calc(100% - 48px)'}}>\r\n      <CenterItems>\r\n        <img src=\"visualize-it-logo.png\" width=\"300\" alt=\"Logo\" className={classes.entry} />\r\n      </CenterItems>\r\n      <CenterItems>\r\n        <Typography variant=\"h4\" color=\"inherit\" noWrap className={classes.entry} >\r\n          Your View into External Systems!\r\n        </Typography>\r\n      </CenterItems>\r\n      <CenterItems>\r\n        <img src=\"visualize-it-logo-eyes.jpg\" alt=\"Logo Eyes\" className={classes.entry}/>\r\n      </CenterItems>\r\n    </Paper>\r\n  );\r\n}\r\n\r\nconst useStyles = makeStyles( theme => ({\r\n  root: {\r\n    padding: theme.spacing(3, 2, 15),\r\n  },\r\n\r\n  entry: {\r\n    marginTop: theme.spacing(2),\r\n  },\r\n}) );\r\n","import React           from 'react';\r\nimport {featureRoute}  from 'feature-router';\r\nimport TabManager      from './comp/TabManager';\r\nimport StartUpPage     from './comp/StartUpPage';\r\nimport {getTotalTabs}  from './state';\r\n\r\n// ***\r\n// *** The routes for this feature.\r\n// ***\r\n\r\nexport default [\r\n\r\n  featureRoute({\r\n    content: ({fassets, appState}) => getTotalTabs(appState) === 0 ? <StartUpPage/> : <TabManager/>,\r\n  }),\r\n\r\n];\r\n","import {createFeature}    from 'feature-u';\r\nimport _tabManager        from './featureName';\r\nimport _tabManagerAct     from './actions';\r\nimport reducer,\r\n       {getTotalTabs,\r\n        getActiveTabId}   from './state';\r\nimport logic              from './logic';\r\nimport route              from './route';\r\n\r\n\r\n// feature: tabManager\r\n//          a manager of tabs\r\nexport default createFeature({\r\n  name: _tabManager,\r\n\r\n  fassets: {\r\n    define: {\r\n      'actions.activateTab': _tabManagerAct.activateTab, // activateTab(tabId, preview=true): Action\r\n      'actions.closeTab':    _tabManagerAct.closeTab,    // closeTab(tabId): Action\r\n\r\n      'sel.getTotalTabs':    getTotalTabs,\r\n      'sel.getActiveTabId':  getActiveTabId,\r\n    },\r\n  },\r\n\r\n  reducer,\r\n  logic,\r\n  route,\r\n});\r\n","import {createLogic}       from 'redux-logic';\r\nimport _toolBar            from './featureName';\r\nimport _toolBarAct         from './actions';\r\nimport {tabRegistry}       from 'features/xtra';\r\n\r\n\r\n/**\r\n * Sync DispMode changes to the object model.\r\n */\r\nexport const syncDispModeChangesToObjectModel = createLogic({\r\n\r\n  name: `${_toolBar}.syncDispModeChangesToObjectModel`,\r\n  type: String(_toolBarAct.dispModeChanged),\r\n\r\n  process({getState, action, fassets}, dispatch, done) {\r\n\r\n    // propagate this change to the object model via the TabController\r\n    const appState      = getState();\r\n    const activeTabId   = fassets.sel.getActiveTabId(appState);\r\n    const tabController = tabRegistry.getTabController(activeTabId);\r\n    tabController.getTarget().setDispMode(action.dispMode);\r\n\r\n    done();\r\n  },\r\n\r\n});\r\n\r\n\r\n// promote all logic modules for this feature\r\n// ... NOTE: individual logic modules are unit tested using the named exports.\r\nexport default [\r\n  syncDispModeChangesToObjectModel,\r\n];\r\n","import {createFeature}  from 'feature-u';\r\nimport _toolBar         from './featureName';\r\nimport reducer          from './state';\r\nimport logic            from './logic';\r\n\r\n// feature: toolBar\r\n//          manages the toolbar and it's dynamics\r\nexport default createFeature({\r\n  name: _toolBar,\r\n  reducer,\r\n  logic,\r\n});\r\n","import {createLogic}      from 'redux-logic';\r\nimport _logActions        from './featureName';\r\nimport featureFlags       from 'featureFlags';\r\n\r\nlet lastState = null;\r\n\r\n/**\r\n * Log all dispatched actions.\r\n *\r\n * TODO: retrofit to use real logger:\r\n *       using the following Log levels:\r\n *         - TRACE:   see dispatched actions\r\n *         - VERBOSE: see dispatched actions INCLUDING action content (CAUTION: action content can be BIG)\r\n */\r\nexport const actionLogger = createLogic({\r\n\r\n  name: `${_logActions}.actionLogger`,\r\n  type: '*', // monitor ALL action types\r\n\r\n  transform({getState, action}, next) {\r\n\r\n    if (featureFlags.log === 'verbose') { // group action/state together\r\n      console.group(`Action: ${action.type}`);\r\n    }\r\n\r\n    console.log('Dispatched Action: ', action);\r\n\r\n    // TODO: retrofit to use log-u:\r\n    // // log dispatched action\r\n    // if (log.isVerboseEnabled()) {\r\n    //   log.verbose(()=> `Dispatched Action: ${FMT(action.type)} with content:\\n${FMT(action)}`);\r\n    // }\r\n    // else {\r\n    //   log.trace(()=>   `Dispatched Action: ${FMT(action.type)}`);\r\n    // }\r\n\r\n    // continue processing\r\n    next(action);\r\n  },\r\n\r\n  process({getState, action, fassets}, dispatch, done) {\r\n\r\n    if (featureFlags.log === 'verbose') { // state can be big ... log conditionally\r\n\r\n      const curState = getState();\r\n      if (curState === lastState) {\r\n        console.log('Current State: UNCHANGED');\r\n      }\r\n      else {\r\n        console.log('Current State: ', curState);\r\n      }\r\n      lastState = curState;\r\n\r\n      console.groupEnd();\r\n    }\r\n\r\n    done();\r\n  },\r\n\r\n});\r\n\r\n\r\n// promote all logic modules for this feature\r\n// ... NOTE: individual logic modules are unit tested using the named exports.\r\nexport default [\r\n  actionLogger,\r\n];\r\n","/**\r\n * Expose our featureName through a mini-meta module that is\r\n * \"importable\" in all use-cases (a single-source-of-truth).\r\n */\r\nexport default 'logActions';\r\n","import {createFeature}  from 'feature-u';\r\nimport _logActions      from './featureName';\r\nimport logic            from './logic';\r\nimport featureFlags     from 'featureFlags';\r\n\r\n// feature: logActions\r\n//          log all dispatched actions and resulting state (full details in README)\r\nexport default createFeature({\r\n  name:    _logActions,\r\n  enabled: featureFlags.log ? true : false, // NOTE: feature-u requires boolean, but featureFlags.log can be a string (e.g. 'verbose')\r\n  logic,\r\n});\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n           .register(swUrl)\n           .then(registration => {\n             registration.onupdatefound = () => {\n               const installingWorker = registration.installing;\n               if (installingWorker == null) {\n                 return;\n               }\n               installingWorker.onstatechange = () => {\n                 if (installingWorker.state === 'installed') {\n                   if (navigator.serviceWorker.controller) {\n                     // At this point, the updated precached content has been fetched,\n                     // but the previous service worker will still serve the older\n                     // content until all client tabs are closed.\n                     console.log(\n                       'New content is available and will be used when all ' +\n                       'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                     );\n\n                     // Execute callback\n                     if (config && config.onUpdate) {\n                       config.onUpdate(registration);\n                     }\n                   } else {\n                     // At this point, everything has been precached.\n                     // It's the perfect time to display a\n                     // \"Content is cached for offline use.\" message.\n                     console.log('Content is cached for offline use.');\n\n                     // Execute callback\n                     if (config && config.onSuccess) {\n                       config.onSuccess(registration);\n                     }\n                   }\n                 }\n               };\n             };\n           })\n           .catch(error => {\n             console.error('Error during service worker registration:', error);\n           });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import {createFeature}    from 'feature-u';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\n// feature: pwa\r\n//          orchestrates the Progressive Web App hooks (as defined by Create React App)\r\nexport default createFeature({\r\n  name:    'pwa',\r\n\r\n  appInit({showStatus, fassets, getState, dispatch}) {\r\n    // FROM: CRA (Create React App):\r\n    // If you want your app to work offline and load faster, you can change\r\n    // unregister() to register() below. Note this comes with some pitfalls.\r\n    // Learn more about service workers: http://bit.ly/CRA-PWA\r\n    serviceWorker.unregister();\r\n  }\r\n});\r\n","import sandbox                from './sandbox/feature';\r\n//import auth                   from './common/auth/feature';    // AI: DECIDE_AUTH_USER_NEEDED\r\n//import authService            from './common/auth/subFeatures/authService/feature';\r\n//import authServiceFirebase    from './common/auth/subFeatures/authServiceFirebase/feature';\r\n//import authServiceMock        from './common/auth/subFeatures/authServiceMock/feature';\r\nimport initFirebase           from './common/initFirebase/feature';\r\nimport baseUI                 from './common/baseUI/feature';\r\nimport changeManager          from './common/changeManager/feature';\r\nimport tabManager             from './common/tabManager/feature';\r\nimport toolBar                from './toolBar/feature';\r\nimport logActions             from './common/diagnostic/logActions/feature';\r\nimport pwa                    from './common/pwa/feature';\r\n\r\n\r\n//***\r\n//*** Promote ALL features that make up our app\r\n//***\r\n\r\nexport default [\r\n\r\n  // app-specific features\r\n\r\n  sandbox,\r\n\r\n  // common app-neutral features\r\n\r\n  baseUI,\r\n  changeManager,\r\n  tabManager,\r\n  toolBar,\r\n  \r\n//auth,\r\n//authService,\r\n//authServiceFirebase,\r\n//authServiceMock,\r\n  \r\n  initFirebase,\r\n  \r\n  pwa,\r\n\r\n  // diagnostic features ...\r\n  logActions,\r\n];\r\n","import React                  from 'react';\r\nimport {createReducerAspect}  from 'feature-redux';\r\nimport {createLogicAspect}    from 'feature-redux-logic';\r\nimport {createRouteAspect}    from 'feature-router';\r\nimport SplashScreen           from 'util/SplashScreen';\r\n\r\n\r\n//***\r\n//*** define/configure the aspects representing our app's run-time stack\r\n//***\r\n\r\n// redux - extending: Feature.reducer\r\nconst reducerAspect = createReducerAspect();\r\n\r\n// redux-logic - extending: Feature.logic\r\nconst logicAspect   = createLogicAspect();\r\n\r\n// Feature Routes - extending: Feature.route\r\nconst routeAspect   = createRouteAspect({\r\n  // ... define fallback screen (used when no routes are in effect)\r\n  fallbackElm: <SplashScreen msg=\"I'm trying to think but it hurts!\"/>,\r\n});\r\n\r\n\r\n//***\r\n//*** promote the aspects representing our app's run-time stack\r\n//***\r\n\r\nexport default [\r\n  reducerAspect,\r\n  logicAspect,\r\n  routeAspect,\r\n];\r\n","import 'core/preregisterCoreClasses';  // pre-register our \"core\" SmartPkg very early, allowing pkgManager to resolve \"core\" packages\r\nimport ReactDOM     from 'react-dom';\r\nimport {launchApp}  from 'feature-u';\r\nimport features     from 'features';\r\nimport aspects      from 'aspects';\r\nimport {splash}     from 'util/SplashScreen';\r\n\r\n// launch our app, exposing the Fassets object (facilitating cross-feature-communication)\r\nexport default launchApp({\r\n\r\n  features,\r\n  aspects,\r\n\r\n  registerRootAppElm(rootAppElm) {\r\n    ReactDOM.render(rootAppElm,\r\n                    document.getElementById('root'));\r\n  },\r\n\r\n  showStatus(msg='', err=null) {\r\n    splash(msg, err);\r\n  },\r\n});\r\n","import 'util/ErrorExtensionPolyfill';\r\nexport {default}  from 'app'; // redirect to app.js\r\n"],"sourceRoot":""}